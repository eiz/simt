/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceArch_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl hipDeviceArch_t {
    #[inline]
    pub fn hasGlobalInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFloatAtomicAdd(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFloatAtomicAdd(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDoubles(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDoubles(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpVote(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpVote(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpBallot(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpBallot(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpShuffle(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpShuffle(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFunnelShift(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFunnelShift(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasThreadFenceSystem(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasThreadFenceSystem(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSyncThreadsExt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSyncThreadsExt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSurfaceFuncs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSurfaceFuncs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dGrid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has3dGrid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDynamicParallelism(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDynamicParallelism(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasGlobalInt32Atomics: ::std::os::raw::c_uint,
        hasGlobalFloatAtomicExch: ::std::os::raw::c_uint,
        hasSharedInt32Atomics: ::std::os::raw::c_uint,
        hasSharedFloatAtomicExch: ::std::os::raw::c_uint,
        hasFloatAtomicAdd: ::std::os::raw::c_uint,
        hasGlobalInt64Atomics: ::std::os::raw::c_uint,
        hasSharedInt64Atomics: ::std::os::raw::c_uint,
        hasDoubles: ::std::os::raw::c_uint,
        hasWarpVote: ::std::os::raw::c_uint,
        hasWarpBallot: ::std::os::raw::c_uint,
        hasWarpShuffle: ::std::os::raw::c_uint,
        hasFunnelShift: ::std::os::raw::c_uint,
        hasThreadFenceSystem: ::std::os::raw::c_uint,
        hasSyncThreadsExt: ::std::os::raw::c_uint,
        hasSurfaceFuncs: ::std::os::raw::c_uint,
        has3dGrid: ::std::os::raw::c_uint,
        hasDynamicParallelism: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasGlobalInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt32Atomics) };
            hasGlobalInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hasGlobalFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasGlobalFloatAtomicExch) };
            hasGlobalFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hasSharedInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt32Atomics) };
            hasSharedInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hasSharedFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasSharedFloatAtomicExch) };
            hasSharedFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hasFloatAtomicAdd: u32 = unsafe { ::std::mem::transmute(hasFloatAtomicAdd) };
            hasFloatAtomicAdd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasGlobalInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt64Atomics) };
            hasGlobalInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasSharedInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt64Atomics) };
            hasSharedInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasDoubles: u32 = unsafe { ::std::mem::transmute(hasDoubles) };
            hasDoubles as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hasWarpVote: u32 = unsafe { ::std::mem::transmute(hasWarpVote) };
            hasWarpVote as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hasWarpBallot: u32 = unsafe { ::std::mem::transmute(hasWarpBallot) };
            hasWarpBallot as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasWarpShuffle: u32 = unsafe { ::std::mem::transmute(hasWarpShuffle) };
            hasWarpShuffle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hasFunnelShift: u32 = unsafe { ::std::mem::transmute(hasFunnelShift) };
            hasFunnelShift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasThreadFenceSystem: u32 = unsafe { ::std::mem::transmute(hasThreadFenceSystem) };
            hasThreadFenceSystem as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasSyncThreadsExt: u32 = unsafe { ::std::mem::transmute(hasSyncThreadsExt) };
            hasSyncThreadsExt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hasSurfaceFuncs: u32 = unsafe { ::std::mem::transmute(hasSurfaceFuncs) };
            hasSurfaceFuncs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let has3dGrid: u32 = unsafe { ::std::mem::transmute(has3dGrid) };
            has3dGrid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let hasDynamicParallelism: u32 =
                unsafe { ::std::mem::transmute(hasDynamicParallelism) };
            hasDynamicParallelism as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipUUID_t {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
pub type hipUUID = hipUUID_t;
#[doc = " hipDeviceProp\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceProp_t {
    #[doc = "< Device name."]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< Size of global memory region (in bytes)."]
    pub totalGlobalMem: usize,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub sharedMemPerBlock: usize,
    #[doc = "< Registers per block."]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Warp size."]
    pub warpSize: ::std::os::raw::c_int,
    #[doc = "< Max work items per work group or workgroup max size."]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Max number of threads in each dimension (XYZ) of a block."]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max grid dimensions (XYZ)."]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max clock frequency of the multiProcessors in khz."]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Max global memory clock frequency in khz."]
    pub memoryClockRate: ::std::os::raw::c_int,
    #[doc = "< Global memory bus width in bits."]
    pub memoryBusWidth: ::std::os::raw::c_int,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub major: ::std::os::raw::c_int,
    #[doc = "< Minor compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< Number of multi-processors (compute units)."]
    pub multiProcessorCount: ::std::os::raw::c_int,
    #[doc = "< L2 cache size."]
    pub l2CacheSize: ::std::os::raw::c_int,
    #[doc = "< Maximum resident threads per multi-processor."]
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Compute mode."]
    pub computeMode: ::std::os::raw::c_int,
    #[doc = "< Frequency in khz of the timer used by the device-side \"clock*\"\n< instructions.  New for HIP."]
    pub clockInstructionRate: ::std::os::raw::c_int,
    #[doc = "< Architectural feature flags.  New for HIP."]
    pub arch: hipDeviceArch_t,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    pub concurrentKernels: ::std::os::raw::c_int,
    #[doc = "< PCI Domain ID"]
    pub pciDomainID: ::std::os::raw::c_int,
    #[doc = "< PCI Bus ID."]
    pub pciBusID: ::std::os::raw::c_int,
    #[doc = "< PCI Device ID."]
    pub pciDeviceID: ::std::os::raw::c_int,
    #[doc = "< Maximum Shared Memory Per Multiprocessor."]
    pub maxSharedMemoryPerMultiProcessor: usize,
    #[doc = "< 1 if device is on a multi-GPU board, 0 if not."]
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    #[doc = "< Check whether HIP can map host memory"]
    pub canMapHostMemory: ::std::os::raw::c_int,
    #[doc = "< DEPRECATED: use gcnArchName instead"]
    pub gcnArch: ::std::os::raw::c_int,
    #[doc = "< AMD GCN Arch Name."]
    pub gcnArchName: [::std::os::raw::c_char; 256usize],
    #[doc = "< APU vs dGPU"]
    pub integrated: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch"]
    pub cooperativeLaunch: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple devices"]
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    #[doc = "< Maximum size for 1D textures bound to linear memory"]
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    #[doc = "< Maximum number of elements in 1D images"]
    pub maxTexture1D: ::std::os::raw::c_int,
    #[doc = "< Maximum dimensions (width, height) of 2D images, in image elements"]
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, depth) of 3D images, in image elements"]
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub hdpMemFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "< Addres of HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub hdpRegFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "<Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: usize,
    #[doc = "<Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "<Pitch alignment requirement for texture references bound to pitched memory"]
    pub texturePitchAlignment: usize,
    #[doc = "<Run time limit for kernels executed on the device"]
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    #[doc = "<Device has ECC support enabled"]
    pub ECCEnabled: ::std::os::raw::c_int,
    #[doc = "< 1:If device is Tesla device using TCC driver, else 0"]
    pub tccDriver: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedFunc: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedGridDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedBlockDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedSharedMem: ::std::os::raw::c_int,
    #[doc = "< 1: if it is a large PCI bar device, else 0"]
    pub isLargeBar: ::std::os::raw::c_int,
    #[doc = "< Revision of the GPU in this device"]
    pub asicRevision: ::std::os::raw::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::std::os::raw::c_int,
    #[doc = "< Host can directly access managed memory on the device without migration"]
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    #[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
}
#[repr(u32)]
#[doc = " Memory type (for pointer attributes)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemoryType {
    #[doc = "< Memory is physically located on host"]
    hipMemoryTypeHost = 0,
    #[doc = "< Memory is physically located on device. (see deviceId for specific\n< device)"]
    hipMemoryTypeDevice = 1,
    #[doc = "< Array memory, physically located on device. (see deviceId for specific\n< device)"]
    hipMemoryTypeArray = 2,
    #[doc = "< Not used currently"]
    hipMemoryTypeUnified = 3,
    #[doc = "< Managed memory, automaticallly managed by the unified memory system"]
    hipMemoryTypeManaged = 4,
}
#[doc = " Pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPointerAttribute_t {
    pub memoryType: hipMemoryType,
    pub device: ::std::os::raw::c_int,
    pub devicePointer: *mut ::std::os::raw::c_void,
    pub hostPointer: *mut ::std::os::raw::c_void,
    pub isManaged: ::std::os::raw::c_int,
    pub allocationFlags: ::std::os::raw::c_uint,
}
impl hipError_t {
    pub const hipErrorMemoryAllocation: hipError_t = hipError_t::hipErrorOutOfMemory;
}
impl hipError_t {
    pub const hipErrorInitializationError: hipError_t = hipError_t::hipErrorNotInitialized;
}
impl hipError_t {
    pub const hipErrorMapBufferObjectFailed: hipError_t = hipError_t::hipErrorMapFailed;
}
impl hipError_t {
    pub const hipErrorInvalidResourceHandle: hipError_t = hipError_t::hipErrorInvalidHandle;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipError_t {
    #[doc = "< Successful completion."]
    hipSuccess = 0,
    #[doc = "< One or more of the parameters passed to the API call is NULL\n< or not in an acceptable range."]
    hipErrorInvalidValue = 1,
    hipErrorOutOfMemory = 2,
    hipErrorNotInitialized = 3,
    hipErrorDeinitialized = 4,
    hipErrorProfilerDisabled = 5,
    hipErrorProfilerNotInitialized = 6,
    hipErrorProfilerAlreadyStarted = 7,
    hipErrorProfilerAlreadyStopped = 8,
    hipErrorInvalidConfiguration = 9,
    hipErrorInvalidPitchValue = 12,
    hipErrorInvalidSymbol = 13,
    #[doc = "< Invalid Device Pointer"]
    hipErrorInvalidDevicePointer = 17,
    #[doc = "< Invalid memory copy direction"]
    hipErrorInvalidMemcpyDirection = 21,
    hipErrorInsufficientDriver = 35,
    hipErrorMissingConfiguration = 52,
    hipErrorPriorLaunchFailure = 53,
    hipErrorInvalidDeviceFunction = 98,
    #[doc = "< Call to hipGetDeviceCount returned 0 devices"]
    hipErrorNoDevice = 100,
    #[doc = "< DeviceID must be in range 0...#compute-devices."]
    hipErrorInvalidDevice = 101,
    hipErrorInvalidImage = 200,
    #[doc = "< Produced when input context is invalid."]
    hipErrorInvalidContext = 201,
    hipErrorContextAlreadyCurrent = 202,
    hipErrorMapFailed = 205,
    hipErrorUnmapFailed = 206,
    hipErrorArrayIsMapped = 207,
    hipErrorAlreadyMapped = 208,
    hipErrorNoBinaryForGpu = 209,
    hipErrorAlreadyAcquired = 210,
    hipErrorNotMapped = 211,
    hipErrorNotMappedAsArray = 212,
    hipErrorNotMappedAsPointer = 213,
    hipErrorECCNotCorrectable = 214,
    hipErrorUnsupportedLimit = 215,
    hipErrorContextAlreadyInUse = 216,
    hipErrorPeerAccessUnsupported = 217,
    #[doc = "< In CUDA DRV, it is CUDA_ERROR_INVALID_PTX"]
    hipErrorInvalidKernelFile = 218,
    hipErrorInvalidGraphicsContext = 219,
    hipErrorInvalidSource = 300,
    hipErrorFileNotFound = 301,
    hipErrorSharedObjectSymbolNotFound = 302,
    hipErrorSharedObjectInitFailed = 303,
    hipErrorOperatingSystem = 304,
    hipErrorInvalidHandle = 400,
    #[doc = "< Resource required is not in a valid state to perform operation."]
    hipErrorIllegalState = 401,
    hipErrorNotFound = 500,
    #[doc = "< Indicates that asynchronous operations enqueued earlier are not\n< ready.  This is not actually an error, but is used to distinguish\n< from hipSuccess (which indicates completion).  APIs that return\n< this error include hipEventQuery and hipStreamQuery."]
    hipErrorNotReady = 600,
    hipErrorIllegalAddress = 700,
    #[doc = "< Out of resources error."]
    hipErrorLaunchOutOfResources = 701,
    hipErrorLaunchTimeOut = 702,
    hipErrorPeerAccessAlreadyEnabled = 704,
    hipErrorPeerAccessNotEnabled = 705,
    hipErrorSetOnActiveProcess = 708,
    hipErrorContextIsDestroyed = 709,
    #[doc = "< Produced when the kernel calls assert."]
    hipErrorAssert = 710,
    hipErrorHostMemoryAlreadyRegistered = 712,
    hipErrorHostMemoryNotRegistered = 713,
    hipErrorLaunchFailure = 719,
    hipErrorCooperativeLaunchTooLarge = 720,
    #[doc = "< Produced when the hip API is not supported/implemented"]
    hipErrorNotSupported = 801,
    #[doc = "< The operation is not permitted when the stream\n< is capturing."]
    hipErrorStreamCaptureUnsupported = 900,
    #[doc = "< The current capture sequence on the stream\n< has been invalidated due to a previous error."]
    hipErrorStreamCaptureInvalidated = 901,
    #[doc = "< The operation would have resulted in a merge of\n< two independent capture sequences."]
    hipErrorStreamCaptureMerge = 902,
    #[doc = "< The capture was not initiated in this stream."]
    hipErrorStreamCaptureUnmatched = 903,
    #[doc = "< The capture sequence contains a fork that was not\n< joined to the primary stream."]
    hipErrorStreamCaptureUnjoined = 904,
    #[doc = "< A dependency would have been created which crosses\n< the capture sequence boundary. Only implicit\n< in-stream ordering dependencies  are allowed\n< to cross the boundary"]
    hipErrorStreamCaptureIsolation = 905,
    #[doc = "< The operation would have resulted in a disallowed\n< implicit dependency on a current capture sequence\n< from hipStreamLegacy."]
    hipErrorStreamCaptureImplicit = 906,
    #[doc = "< The operation is not permitted on an event which was last\n< recorded in a capturing stream."]
    hipErrorCapturedEvent = 907,
    #[doc = "< A stream capture sequence not initiated with\n< the hipStreamCaptureModeRelaxed argument to\n< hipStreamBeginCapture was passed to\n< hipStreamEndCapture in a different thread."]
    hipErrorStreamCaptureWrongThread = 908,
    #[doc = "< This error indicates that the graph update\n< not performed because it included changes which\n< violated constraintsspecific to instantiated graph\n< update."]
    hipErrorGraphExecUpdateFailure = 910,
    hipErrorUnknown = 999,
    #[doc = "< HSA runtime memory call returned error.  Typically not seen\n< in production systems."]
    hipErrorRuntimeMemory = 1052,
    #[doc = "< HSA runtime call other than memory returned error.  Typically\n< not seen in production systems."]
    hipErrorRuntimeOther = 1053,
    #[doc = "< Marker that more error codes are needed."]
    hipErrorTbd = 1054,
}
impl hipDeviceAttribute_t {
    pub const hipDeviceAttributeEccEnabled: hipDeviceAttribute_t =
        hipDeviceAttribute_t::hipDeviceAttributeCudaCompatibleBegin;
}
impl hipDeviceAttribute_t {
    pub const hipDeviceAttributeClockInstructionRate: hipDeviceAttribute_t =
        hipDeviceAttribute_t::hipDeviceAttributeAmdSpecificBegin;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipDeviceAttribute_t {
    hipDeviceAttributeCudaCompatibleBegin = 0,
    #[doc = "< Cuda only. The maximum size of the window policy in bytes."]
    hipDeviceAttributeAccessPolicyMaxWindowSize = 1,
    #[doc = "< Cuda only. Asynchronous engines number."]
    hipDeviceAttributeAsyncEngineCount = 2,
    #[doc = "< Whether host memory can be mapped into device address space"]
    hipDeviceAttributeCanMapHostMemory = 3,
    #[doc = "< Cuda only. Device can access host registered memory\n< at the same virtual address as the CPU"]
    hipDeviceAttributeCanUseHostPointerForRegisteredMem = 4,
    #[doc = "< Peak clock frequency in kilohertz."]
    hipDeviceAttributeClockRate = 5,
    #[doc = "< Compute mode that device is currently in."]
    hipDeviceAttributeComputeMode = 6,
    #[doc = "< Cuda only. Device supports Compute Preemption."]
    hipDeviceAttributeComputePreemptionSupported = 7,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    hipDeviceAttributeConcurrentKernels = 8,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    hipDeviceAttributeConcurrentManagedAccess = 9,
    #[doc = "< Support cooperative launch"]
    hipDeviceAttributeCooperativeLaunch = 10,
    #[doc = "< Support cooperative launch on multiple devices"]
    hipDeviceAttributeCooperativeMultiDeviceLaunch = 11,
    #[doc = "< Cuda only. Device can concurrently copy memory and execute a kernel.\n< Deprecated. Use instead asyncEngineCount."]
    hipDeviceAttributeDeviceOverlap = 12,
    #[doc = "< Host can directly access managed memory on\n< the device without migration"]
    hipDeviceAttributeDirectManagedMemAccessFromHost = 13,
    #[doc = "< Cuda only. Device supports caching globals in L1"]
    hipDeviceAttributeGlobalL1CacheSupported = 14,
    #[doc = "< Cuda only. Link between the device and the host supports native atomic operations"]
    hipDeviceAttributeHostNativeAtomicSupported = 15,
    #[doc = "< Device is integrated GPU"]
    hipDeviceAttributeIntegrated = 16,
    #[doc = "< Multiple GPU devices."]
    hipDeviceAttributeIsMultiGpuBoard = 17,
    #[doc = "< Run time limit for kernels executed on the device"]
    hipDeviceAttributeKernelExecTimeout = 18,
    #[doc = "< Size of L2 cache in bytes. 0 if the device doesn't have L2 cache."]
    hipDeviceAttributeL2CacheSize = 19,
    #[doc = "< caching locals in L1 is supported"]
    hipDeviceAttributeLocalL1CacheSupported = 20,
    #[doc = "< Cuda only. 8-byte locally unique identifier in 8 bytes. Undefined on TCC and non-Windows platforms"]
    hipDeviceAttributeLuid = 21,
    #[doc = "< Cuda only. Luid device node mask. Undefined on TCC and non-Windows platforms"]
    hipDeviceAttributeLuidDeviceNodeMask = 22,
    #[doc = "< Major compute capability version number."]
    hipDeviceAttributeComputeCapabilityMajor = 23,
    #[doc = "< Device supports allocating managed memory on this system"]
    hipDeviceAttributeManagedMemory = 24,
    #[doc = "< Cuda only. Max block size per multiprocessor"]
    hipDeviceAttributeMaxBlocksPerMultiProcessor = 25,
    #[doc = "< Max block size in width."]
    hipDeviceAttributeMaxBlockDimX = 26,
    #[doc = "< Max block size in height."]
    hipDeviceAttributeMaxBlockDimY = 27,
    #[doc = "< Max block size in depth."]
    hipDeviceAttributeMaxBlockDimZ = 28,
    #[doc = "< Max grid size  in width."]
    hipDeviceAttributeMaxGridDimX = 29,
    #[doc = "< Max grid size  in height."]
    hipDeviceAttributeMaxGridDimY = 30,
    #[doc = "< Max grid size  in depth."]
    hipDeviceAttributeMaxGridDimZ = 31,
    #[doc = "< Maximum size of 1D surface."]
    hipDeviceAttributeMaxSurface1D = 32,
    #[doc = "< Cuda only. Maximum dimensions of 1D layered surface."]
    hipDeviceAttributeMaxSurface1DLayered = 33,
    #[doc = "< Maximum dimension (width, height) of 2D surface."]
    hipDeviceAttributeMaxSurface2D = 34,
    #[doc = "< Cuda only. Maximum dimensions of 2D layered surface."]
    hipDeviceAttributeMaxSurface2DLayered = 35,
    #[doc = "< Maximum dimension (width, height, depth) of 3D surface."]
    hipDeviceAttributeMaxSurface3D = 36,
    #[doc = "< Cuda only. Maximum dimensions of Cubemap surface."]
    hipDeviceAttributeMaxSurfaceCubemap = 37,
    #[doc = "< Cuda only. Maximum dimension of Cubemap layered surface."]
    hipDeviceAttributeMaxSurfaceCubemapLayered = 38,
    #[doc = "< Maximum size of 1D texture."]
    hipDeviceAttributeMaxTexture1DWidth = 39,
    #[doc = "< Cuda only. Maximum dimensions of 1D layered texture."]
    hipDeviceAttributeMaxTexture1DLayered = 40,
    #[doc = "< Maximum number of elements allocatable in a 1D linear texture.\n< Use cudaDeviceGetTexture1DLinearMaxWidth() instead on Cuda."]
    hipDeviceAttributeMaxTexture1DLinear = 41,
    #[doc = "< Cuda only. Maximum size of 1D mipmapped texture."]
    hipDeviceAttributeMaxTexture1DMipmap = 42,
    #[doc = "< Maximum dimension width of 2D texture."]
    hipDeviceAttributeMaxTexture2DWidth = 43,
    #[doc = "< Maximum dimension hight of 2D texture."]
    hipDeviceAttributeMaxTexture2DHeight = 44,
    #[doc = "< Cuda only. Maximum dimensions of 2D texture if gather operations  performed."]
    hipDeviceAttributeMaxTexture2DGather = 45,
    #[doc = "< Cuda only. Maximum dimensions of 2D layered texture."]
    hipDeviceAttributeMaxTexture2DLayered = 46,
    #[doc = "< Cuda only. Maximum dimensions (width, height, pitch) of 2D textures bound to pitched memory."]
    hipDeviceAttributeMaxTexture2DLinear = 47,
    #[doc = "< Cuda only. Maximum dimensions of 2D mipmapped texture."]
    hipDeviceAttributeMaxTexture2DMipmap = 48,
    #[doc = "< Maximum dimension width of 3D texture."]
    hipDeviceAttributeMaxTexture3DWidth = 49,
    #[doc = "< Maximum dimension height of 3D texture."]
    hipDeviceAttributeMaxTexture3DHeight = 50,
    #[doc = "< Maximum dimension depth of 3D texture."]
    hipDeviceAttributeMaxTexture3DDepth = 51,
    #[doc = "< Cuda only. Maximum dimensions of alternate 3D texture."]
    hipDeviceAttributeMaxTexture3DAlt = 52,
    #[doc = "< Cuda only. Maximum dimensions of Cubemap texture"]
    hipDeviceAttributeMaxTextureCubemap = 53,
    #[doc = "< Cuda only. Maximum dimensions of Cubemap layered texture."]
    hipDeviceAttributeMaxTextureCubemapLayered = 54,
    #[doc = "< Maximum dimension of a block"]
    hipDeviceAttributeMaxThreadsDim = 55,
    #[doc = "< Maximum number of threads per block."]
    hipDeviceAttributeMaxThreadsPerBlock = 56,
    #[doc = "< Maximum resident threads per multiprocessor."]
    hipDeviceAttributeMaxThreadsPerMultiProcessor = 57,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    hipDeviceAttributeMaxPitch = 58,
    #[doc = "< Global memory bus width in bits."]
    hipDeviceAttributeMemoryBusWidth = 59,
    #[doc = "< Peak memory clock frequency in kilohertz."]
    hipDeviceAttributeMemoryClockRate = 60,
    #[doc = "< Minor compute capability version number."]
    hipDeviceAttributeComputeCapabilityMinor = 61,
    #[doc = "< Cuda only. Unique ID of device group on the same multi-GPU board"]
    hipDeviceAttributeMultiGpuBoardGroupID = 62,
    #[doc = "< Number of multiprocessors on the device."]
    hipDeviceAttributeMultiprocessorCount = 63,
    #[doc = "< Device name."]
    hipDeviceAttributeName = 64,
    #[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
    hipDeviceAttributePageableMemoryAccess = 65,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    hipDeviceAttributePageableMemoryAccessUsesHostPageTables = 66,
    #[doc = "< PCI Bus ID."]
    hipDeviceAttributePciBusId = 67,
    #[doc = "< PCI Device ID."]
    hipDeviceAttributePciDeviceId = 68,
    #[doc = "< PCI Domain ID."]
    hipDeviceAttributePciDomainID = 69,
    #[doc = "< Cuda11 only. Maximum l2 persisting lines capacity in bytes"]
    hipDeviceAttributePersistingL2CacheMaxSize = 70,
    #[doc = "< 32-bit registers available to a thread block. This number is shared\n< by all thread blocks simultaneously resident on a multiprocessor."]
    hipDeviceAttributeMaxRegistersPerBlock = 71,
    #[doc = "< 32-bit registers available per block."]
    hipDeviceAttributeMaxRegistersPerMultiprocessor = 72,
    #[doc = "< Cuda11 only. Shared memory reserved by CUDA driver per block."]
    hipDeviceAttributeReservedSharedMemPerBlock = 73,
    #[doc = "< Maximum shared memory available per block in bytes."]
    hipDeviceAttributeMaxSharedMemoryPerBlock = 74,
    #[doc = "< Cuda only. Maximum shared memory per block usable by special opt in."]
    hipDeviceAttributeSharedMemPerBlockOptin = 75,
    #[doc = "< Cuda only. Shared memory available per multiprocessor."]
    hipDeviceAttributeSharedMemPerMultiprocessor = 76,
    #[doc = "< Cuda only. Performance ratio of single precision to double precision."]
    hipDeviceAttributeSingleToDoublePrecisionPerfRatio = 77,
    #[doc = "< Cuda only. Whether to support stream priorities."]
    hipDeviceAttributeStreamPrioritiesSupported = 78,
    #[doc = "< Cuda only. Alignment requirement for surfaces"]
    hipDeviceAttributeSurfaceAlignment = 79,
    #[doc = "< Cuda only. Whether device is a Tesla device using TCC driver"]
    hipDeviceAttributeTccDriver = 80,
    #[doc = "< Alignment requirement for textures"]
    hipDeviceAttributeTextureAlignment = 81,
    #[doc = "< Pitch alignment requirement for 2D texture references bound to pitched memory;"]
    hipDeviceAttributeTexturePitchAlignment = 82,
    #[doc = "< Constant memory size in bytes."]
    hipDeviceAttributeTotalConstantMemory = 83,
    #[doc = "< Global memory available on devicice."]
    hipDeviceAttributeTotalGlobalMem = 84,
    #[doc = "< Cuda only. An unified address space shared with the host."]
    hipDeviceAttributeUnifiedAddressing = 85,
    #[doc = "< Cuda only. Unique ID in 16 byte."]
    hipDeviceAttributeUuid = 86,
    #[doc = "< Warp size in threads."]
    hipDeviceAttributeWarpSize = 87,
    #[doc = "< Device supports HIP Stream Ordered Memory Allocator"]
    hipDeviceAttributeMemoryPoolsSupported = 88,
    #[doc = "< Device supports HIP virtual memory management"]
    hipDeviceAttributeVirtualMemoryManagementSupported = 89,
    hipDeviceAttributeCudaCompatibleEnd = 9999,
    hipDeviceAttributeAmdSpecificBegin = 10000,
    #[doc = "< Device architecture"]
    hipDeviceAttributeArch = 10001,
    #[doc = "< Maximum Shared Memory PerMultiprocessor."]
    hipDeviceAttributeMaxSharedMemoryPerMultiprocessor = 10002,
    #[doc = "< Device gcn architecture"]
    hipDeviceAttributeGcnArch = 10003,
    #[doc = "< Device gcnArch name in 256 bytes"]
    hipDeviceAttributeGcnArchName = 10004,
    #[doc = "< Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpMemFlushCntl = 10005,
    #[doc = "< Address of the HDP_REG_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpRegFlushCntl = 10006,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched functions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc = 10007,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched grid dimensions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim = 10008,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched block dimensions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim = 10009,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched shared memories"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem = 10010,
    #[doc = "< Whether it is LargeBar"]
    hipDeviceAttributeIsLargeBar = 10011,
    #[doc = "< Revision of the GPU in this device"]
    hipDeviceAttributeAsicRevision = 10012,
    #[doc = "< '1' if Device supports hipStreamWaitValue32() and\n< hipStreamWaitValue64(), '0' otherwise."]
    hipDeviceAttributeCanUseStreamWaitValue = 10013,
    #[doc = "< '1' if Device supports image, '0' otherwise."]
    hipDeviceAttributeImageSupport = 10014,
    #[doc = "< All available physical compute\n< units for the device"]
    hipDeviceAttributePhysicalMultiProcessorCount = 10015,
    #[doc = "< '1' if Device supports fine grain, '0' otherwise"]
    hipDeviceAttributeFineGrainSupport = 10016,
    #[doc = "< Constant frequency of wall clock in kilohertz."]
    hipDeviceAttributeWallClockRate = 10017,
    hipDeviceAttributeAmdSpecificEnd = 19999,
    hipDeviceAttributeVendorSpecificBegin = 20000,
}
pub type hipDeviceptr_t = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipChannelFormatKind {
    hipChannelFormatKindSigned = 0,
    hipChannelFormatKindUnsigned = 1,
    hipChannelFormatKindFloat = 2,
    hipChannelFormatKindNone = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipChannelFormatDesc {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub f: hipChannelFormatKind,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipArray_Format {
    HIP_AD_FORMAT_UNSIGNED_INT8 = 1,
    HIP_AD_FORMAT_UNSIGNED_INT16 = 2,
    HIP_AD_FORMAT_UNSIGNED_INT32 = 3,
    HIP_AD_FORMAT_SIGNED_INT8 = 8,
    HIP_AD_FORMAT_SIGNED_INT16 = 9,
    HIP_AD_FORMAT_SIGNED_INT32 = 10,
    HIP_AD_FORMAT_HALF = 16,
    HIP_AD_FORMAT_FLOAT = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY3D_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArray {
    pub data: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub isDrv: bool,
    pub textureType: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hip_Memcpy2D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: *mut hipArray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: *mut hipArray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
pub type hipArray_t = *mut hipArray;
pub type hipArray_const_t = *const hipArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMipmappedArray {
    pub data: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub min_mipmap_level: ::std::os::raw::c_uint,
    pub max_mipmap_level: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub format: hipArray_Format,
}
pub type hipMipmappedArray_t = *mut hipMipmappedArray;
pub type hipMipmappedArray_const_t = *const hipMipmappedArray;
#[repr(u32)]
#[doc = " hip resource types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipResourceType {
    hipResourceTypeArray = 0,
    hipResourceTypeMipmappedArray = 1,
    hipResourceTypeLinear = 2,
    hipResourceTypePitch2D = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPresourcetype_enum {
    #[doc = "< Array resoure"]
    HIP_RESOURCE_TYPE_ARRAY = 0,
    #[doc = "< Mipmapped array resource"]
    HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    #[doc = "< Linear resource"]
    HIP_RESOURCE_TYPE_LINEAR = 2,
    #[doc = "< Pitch 2D resource"]
    HIP_RESOURCE_TYPE_PITCH2D = 3,
}
pub use self::HIPresourcetype_enum as HIPresourcetype;
#[repr(u32)]
#[doc = " hip address modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPaddress_mode_enum {
    HIP_TR_ADDRESS_MODE_WRAP = 0,
    HIP_TR_ADDRESS_MODE_CLAMP = 1,
    HIP_TR_ADDRESS_MODE_MIRROR = 2,
    HIP_TR_ADDRESS_MODE_BORDER = 3,
}
#[doc = " hip address modes"]
pub use self::HIPaddress_mode_enum as HIPaddress_mode;
#[repr(u32)]
#[doc = " hip filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPfilter_mode_enum {
    HIP_TR_FILTER_MODE_POINT = 0,
    HIP_TR_FILTER_MODE_LINEAR = 1,
}
#[doc = " hip filter modes"]
pub use self::HIPfilter_mode_enum as HIPfilter_mode;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [HIPaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: HIPfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: HIPfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[doc = " Texture descriptor"]
pub type HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st;
#[repr(u32)]
#[doc = " hip texture resource view formats"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipResourceViewFormat {
    hipResViewFormatNone = 0,
    hipResViewFormatUnsignedChar1 = 1,
    hipResViewFormatUnsignedChar2 = 2,
    hipResViewFormatUnsignedChar4 = 3,
    hipResViewFormatSignedChar1 = 4,
    hipResViewFormatSignedChar2 = 5,
    hipResViewFormatSignedChar4 = 6,
    hipResViewFormatUnsignedShort1 = 7,
    hipResViewFormatUnsignedShort2 = 8,
    hipResViewFormatUnsignedShort4 = 9,
    hipResViewFormatSignedShort1 = 10,
    hipResViewFormatSignedShort2 = 11,
    hipResViewFormatSignedShort4 = 12,
    hipResViewFormatUnsignedInt1 = 13,
    hipResViewFormatUnsignedInt2 = 14,
    hipResViewFormatUnsignedInt4 = 15,
    hipResViewFormatSignedInt1 = 16,
    hipResViewFormatSignedInt2 = 17,
    hipResViewFormatSignedInt4 = 18,
    hipResViewFormatHalf1 = 19,
    hipResViewFormatHalf2 = 20,
    hipResViewFormatHalf4 = 21,
    hipResViewFormatFloat1 = 22,
    hipResViewFormatFloat2 = 23,
    hipResViewFormatFloat4 = 24,
    hipResViewFormatUnsignedBlockCompressed1 = 25,
    hipResViewFormatUnsignedBlockCompressed2 = 26,
    hipResViewFormatUnsignedBlockCompressed3 = 27,
    hipResViewFormatUnsignedBlockCompressed4 = 28,
    hipResViewFormatSignedBlockCompressed4 = 29,
    hipResViewFormatUnsignedBlockCompressed5 = 30,
    hipResViewFormatSignedBlockCompressed5 = 31,
    hipResViewFormatUnsignedBlockCompressed6H = 32,
    hipResViewFormatSignedBlockCompressed6H = 33,
    hipResViewFormatUnsignedBlockCompressed7 = 34,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HIPresourceViewFormat_enum {
    #[doc = "< No resource view format (use underlying resource format)"]
    HIP_RES_VIEW_FORMAT_NONE = 0,
    #[doc = "< 1 channel unsigned 8-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_1X8 = 1,
    #[doc = "< 2 channel unsigned 8-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_2X8 = 2,
    #[doc = "< 4 channel unsigned 8-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_4X8 = 3,
    #[doc = "< 1 channel signed 8-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_1X8 = 4,
    #[doc = "< 2 channel signed 8-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_2X8 = 5,
    #[doc = "< 4 channel signed 8-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_4X8 = 6,
    #[doc = "< 1 channel unsigned 16-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_1X16 = 7,
    #[doc = "< 2 channel unsigned 16-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_2X16 = 8,
    #[doc = "< 4 channel unsigned 16-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_4X16 = 9,
    #[doc = "< 1 channel signed 16-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_1X16 = 10,
    #[doc = "< 2 channel signed 16-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_2X16 = 11,
    #[doc = "< 4 channel signed 16-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_4X16 = 12,
    #[doc = "< 1 channel unsigned 32-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_1X32 = 13,
    #[doc = "< 2 channel unsigned 32-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_2X32 = 14,
    #[doc = "< 4 channel unsigned 32-bit integers"]
    HIP_RES_VIEW_FORMAT_UINT_4X32 = 15,
    #[doc = "< 1 channel signed 32-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_1X32 = 16,
    #[doc = "< 2 channel signed 32-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_2X32 = 17,
    #[doc = "< 4 channel signed 32-bit integers"]
    HIP_RES_VIEW_FORMAT_SINT_4X32 = 18,
    #[doc = "< 1 channel 16-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_1X16 = 19,
    #[doc = "< 2 channel 16-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_2X16 = 20,
    #[doc = "< 4 channel 16-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_4X16 = 21,
    #[doc = "< 1 channel 32-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_1X32 = 22,
    #[doc = "< 2 channel 32-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_2X32 = 23,
    #[doc = "< 4 channel 32-bit floating point"]
    HIP_RES_VIEW_FORMAT_FLOAT_4X32 = 24,
    #[doc = "< Block compressed 1"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC1 = 25,
    #[doc = "< Block compressed 2"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC2 = 26,
    #[doc = "< Block compressed 3"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC3 = 27,
    #[doc = "< Block compressed 4 unsigned"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC4 = 28,
    #[doc = "< Block compressed 4 signed"]
    HIP_RES_VIEW_FORMAT_SIGNED_BC4 = 29,
    #[doc = "< Block compressed 5 unsigned"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC5 = 30,
    #[doc = "< Block compressed 5 signed"]
    HIP_RES_VIEW_FORMAT_SIGNED_BC5 = 31,
    #[doc = "< Block compressed 6 unsigned half-float"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H = 32,
    #[doc = "< Block compressed 6 signed half-float"]
    HIP_RES_VIEW_FORMAT_SIGNED_BC6H = 33,
    #[doc = "< Block compressed 7"]
    HIP_RES_VIEW_FORMAT_UNSIGNED_BC7 = 34,
}
pub use self::HIPresourceViewFormat_enum as HIPresourceViewFormat;
#[doc = " HIP resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipResourceDesc {
    pub resType: hipResourceType,
    pub res: hipResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipResourceDesc__bindgen_ty_1 {
    pub array: hipResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: hipResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: hipResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: hipResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: HIPresourcetype,
    pub res: HIP_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub hArray: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub hMipmappedArray: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
pub type HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st;
#[doc = " hip resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceViewDesc {
    pub format: hipResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    pub firstLayer: ::std::os::raw::c_uint,
    pub lastLayer: ::std::os::raw::c_uint,
}
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: HIPresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[doc = " Resource view descriptor"]
pub type HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemcpyKind {
    #[doc = "< Host-to-Host Copy"]
    hipMemcpyHostToHost = 0,
    #[doc = "< Host-to-Device Copy"]
    hipMemcpyHostToDevice = 1,
    #[doc = "< Device-to-Host Copy"]
    hipMemcpyDeviceToHost = 2,
    #[doc = "< Device-to-Device Copy"]
    hipMemcpyDeviceToDevice = 3,
    hipMemcpyDefault = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPitchedPtr {
    pub ptr: *mut ::std::os::raw::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemcpy3DParms {
    pub srcArray: hipArray_t,
    pub srcPos: hipPos,
    pub srcPtr: hipPitchedPtr,
    pub dstArray: hipArray_t,
    pub dstPos: hipPos,
    pub dstPtr: hipPitchedPtr,
    pub extent: hipExtent,
    pub kind: hipMemcpyKind,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_MEMCPY3D {
    pub srcXInBytes: ::std::os::raw::c_uint,
    pub srcY: ::std::os::raw::c_uint,
    pub srcZ: ::std::os::raw::c_uint,
    pub srcLOD: ::std::os::raw::c_uint,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: ::std::os::raw::c_uint,
    pub srcHeight: ::std::os::raw::c_uint,
    pub dstXInBytes: ::std::os::raw::c_uint,
    pub dstY: ::std::os::raw::c_uint,
    pub dstZ: ::std::os::raw::c_uint,
    pub dstLOD: ::std::os::raw::c_uint,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: ::std::os::raw::c_uint,
    pub dstHeight: ::std::os::raw::c_uint,
    pub WidthInBytes: ::std::os::raw::c_uint,
    pub Height: ::std::os::raw::c_uint,
    pub Depth: ::std::os::raw::c_uint,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipFunction_attribute {
    HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    HIP_FUNC_ATTRIBUTE_NUM_REGS = 4,
    HIP_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    HIP_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    HIP_FUNC_ATTRIBUTE_MAX = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipPointer_attribute {
    #[doc = "< The context on which a pointer was allocated\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_CONTEXT = 1,
    #[doc = "< memory type describing location of a pointer"]
    HIP_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    #[doc = "< address at which the pointer is allocated on device"]
    HIP_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    #[doc = "< address at which the pointer is allocated on host"]
    HIP_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    #[doc = "< A pair of tokens for use with linux kernel interface\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    #[doc = "< Synchronize every synchronous memory operation\n< initiated on this region"]
    HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    #[doc = "< Unique ID for an allocated memory region"]
    HIP_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    #[doc = "< Indicates if the pointer points to managed memory"]
    HIP_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    #[doc = "< device ordinal of a device on which a pointer\n< was allocated or registered"]
    HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
    #[doc = "< if this pointer maps to an allocation\n< that is suitable for hipIpcGetMemHandle\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE = 10,
    #[doc = "< Starting address for this requested pointer"]
    HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,
    #[doc = "< Size of the address range for this requested pointer"]
    HIP_POINTER_ATTRIBUTE_RANGE_SIZE = 12,
    #[doc = "< tells if this pointer is in a valid address range\n< that is mapped to a backing allocation"]
    HIP_POINTER_ATTRIBUTE_MAPPED = 13,
    #[doc = "< Bitmask of allowed hipmemAllocationHandleType\n< for this allocation @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,
    #[doc = "< returns if the memory referenced by\n< this pointer can be used with the GPUDirect RDMA API\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15,
    #[doc = "< Returns the access flags the device associated with\n< for the corresponding memory referenced by the ptr"]
    HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,
    #[doc = "< Returns the mempool handle for the allocation if\n< it was allocated from a mempool\n< @warning - not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17,
}
#[doc = " An opaque value that represents a hip texture object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_texture {
    _unused: [u8; 0],
}
pub type hipTextureObject_t = *mut __hip_texture;
#[repr(u32)]
#[doc = " hip texture address modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipTextureAddressMode {
    hipAddressModeWrap = 0,
    hipAddressModeClamp = 1,
    hipAddressModeMirror = 2,
    hipAddressModeBorder = 3,
}
#[repr(u32)]
#[doc = " hip texture filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipTextureFilterMode {
    hipFilterModePoint = 0,
    hipFilterModeLinear = 1,
}
#[repr(u32)]
#[doc = " hip texture read modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipTextureReadMode {
    hipReadModeElementType = 0,
    hipReadModeNormalizedFloat = 1,
}
#[doc = " hip texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    pub normalized: ::std::os::raw::c_int,
    pub readMode: hipTextureReadMode,
    pub filterMode: hipTextureFilterMode,
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub channelDesc: hipChannelFormatDesc,
    pub sRGB: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub textureObject: hipTextureObject_t,
    pub numChannels: ::std::os::raw::c_int,
    pub format: hipArray_Format,
}
#[doc = " hip texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipTextureDesc {
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub filterMode: hipTextureFilterMode,
    pub readMode: hipTextureReadMode,
    pub sRGB: ::std::os::raw::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipCtx_t {
    _unused: [u8; 0],
}
pub type hipCtx_t = *mut ihipCtx_t;
pub type hipDevice_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipDeviceP2PAttr {
    hipDevP2PAttrPerformanceRank = 0,
    hipDevP2PAttrAccessSupported = 1,
    hipDevP2PAttrNativeAtomicSupported = 2,
    hipDevP2PAttrHipArrayAccessSupported = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcMemHandle_t = hipIpcMemHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcEventHandle_t = hipIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModule_t {
    _unused: [u8; 0],
}
pub type hipModule_t = *mut ihipModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModuleSymbol_t {
    _unused: [u8; 0],
}
pub type hipFunction_t = *mut ihipModuleSymbol_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemPoolHandle_t {
    _unused: [u8; 0],
}
#[doc = " HIP memory pool"]
pub type hipMemPool_t = *mut ihipMemPoolHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFuncAttributes {
    pub binaryVersion: ::std::os::raw::c_int,
    pub cacheModeCA: ::std::os::raw::c_int,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub numRegs: ::std::os::raw::c_int,
    pub preferredShmemCarveout: ::std::os::raw::c_int,
    pub ptxVersion: ::std::os::raw::c_int,
    pub sharedSizeBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
pub type hipEvent_t = *mut ihipEvent_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipLimit_t {
    hipLimitStackSize = 0,
    hipLimitPrintfFifoSize = 1,
    hipLimitMallocHeapSize = 2,
    hipLimitRange = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemoryAdvise {
    #[doc = "< Data will mostly be read and only occassionally\n< be written to"]
    hipMemAdviseSetReadMostly = 1,
    #[doc = "< Undo the effect of hipMemAdviseSetReadMostly"]
    hipMemAdviseUnsetReadMostly = 2,
    #[doc = "< Set the preferred location for the data as\n< the specified device"]
    hipMemAdviseSetPreferredLocation = 3,
    #[doc = "< Clear the preferred location for the data"]
    hipMemAdviseUnsetPreferredLocation = 4,
    #[doc = "< Data will be accessed by the specified device,\n< so prevent page faults as much as possible"]
    hipMemAdviseSetAccessedBy = 5,
    #[doc = "< Let HIP to decide on the page faulting policy\n< for the specified device"]
    hipMemAdviseUnsetAccessedBy = 6,
    #[doc = "< The default memory model is fine-grain. That allows\n< coherent operations between host and device, while\n< executing kernels. The coarse-grain can be used\n< for data that only needs to be coherent at dispatch\n< boundaries for better performance"]
    hipMemAdviseSetCoarseGrain = 100,
    #[doc = "< Restores cache coherency policy back to fine-grain"]
    hipMemAdviseUnsetCoarseGrain = 101,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemRangeAttribute {
    #[doc = "< Whether the range will mostly be read and\n< only occassionally be written to"]
    hipMemRangeAttributeReadMostly = 1,
    #[doc = "< The preferred location of the range"]
    hipMemRangeAttributePreferredLocation = 2,
    #[doc = "< Memory range has hipMemAdviseSetAccessedBy\n< set for the specified device"]
    hipMemRangeAttributeAccessedBy = 3,
    #[doc = "< The last location to where the range was\n< prefetched"]
    hipMemRangeAttributeLastPrefetchLocation = 4,
    #[doc = "< Returns coherency mode\n< @ref hipMemRangeCoherencyMode for the range"]
    hipMemRangeAttributeCoherencyMode = 100,
}
#[repr(u32)]
#[doc = " @brief HIP memory pool attributes\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemPoolAttr {
    #[doc = " (value type = int)\n Allow @p hipMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n hip events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)"]
    hipMemPoolReuseFollowEventDependencies = 1,
    #[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)"]
    hipMemPoolReuseAllowOpportunistic = 2,
    #[doc = " (value type = int)\n Allow @p hipMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled)."]
    hipMemPoolReuseAllowInternalDependencies = 3,
    #[doc = " (value type = uint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)"]
    hipMemPoolAttrReleaseThreshold = 4,
    #[doc = " (value type = uint64_t)\n Amount of backing memory currently allocated for the mempool."]
    hipMemPoolAttrReservedMemCurrent = 5,
    #[doc = " (value type = uint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero."]
    hipMemPoolAttrReservedMemHigh = 6,
    #[doc = " (value type = uint64_t)\n Amount of memory from the pool that is currently in use by the application."]
    hipMemPoolAttrUsedMemCurrent = 7,
    #[doc = " (value type = uint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero."]
    hipMemPoolAttrUsedMemHigh = 8,
}
#[repr(u32)]
#[doc = " @brief Specifies the type of location\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemLocationType {
    hipMemLocationTypeInvalid = 0,
    #[doc = "< Device location, thus it's HIP device ID"]
    hipMemLocationTypeDevice = 1,
}
#[doc = " Specifies a memory location.\n\n To specify a gpu, set type = @p hipMemLocationTypeDevice and set id = the gpu's device ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemLocation {
    #[doc = "< Specifies the location type, which describes the meaning of id"]
    pub type_: hipMemLocationType,
    #[doc = "< Identifier for the provided location type @p hipMemLocationType"]
    pub id: ::std::os::raw::c_int,
}
#[repr(u32)]
#[doc = " @brief Specifies the memory protection flags for mapping\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAccessFlags {
    #[doc = "< Default, make the address range not accessible"]
    hipMemAccessFlagsProtNone = 0,
    #[doc = "< Set the address range read accessible"]
    hipMemAccessFlagsProtRead = 1,
    #[doc = "< Set the address range read-write accessible"]
    hipMemAccessFlagsProtReadWrite = 3,
}
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAccessDesc {
    #[doc = "< Location on which the accessibility has to change"]
    pub location: hipMemLocation,
    #[doc = "< Accessibility flags to set"]
    pub flags: hipMemAccessFlags,
}
#[repr(u32)]
#[doc = " @brief Defines the allocation types\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAllocationType {
    hipMemAllocationTypeInvalid = 0,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
    hipMemAllocationTypePinned = 1,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
    hipMemAllocationTypeMax = 2147483647,
}
#[repr(u32)]
#[doc = " @brief Flags for specifying handle types for memory pool allocations\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAllocationHandleType {
    #[doc = "< Does not allow any export mechanism"]
    hipMemHandleTypeNone = 0,
    #[doc = "< Allows a file descriptor for exporting. Permitted only on POSIX systems"]
    hipMemHandleTypePosixFileDescriptor = 1,
    #[doc = "< Allows a Win32 NT handle for exporting. (HANDLE)"]
    hipMemHandleTypeWin32 = 2,
    #[doc = "< Allows a Win32 KMT handle for exporting. (D3DKMT_HANDLE)"]
    hipMemHandleTypeWin32Kmt = 4,
}
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemPoolProps {
    #[doc = "< Allocation type. Currently must be specified as @p hipMemAllocationTypePinned"]
    pub allocType: hipMemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool"]
    pub handleTypes: hipMemAllocationHandleType,
    #[doc = "< Location where allocations should reside"]
    pub location: hipMemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when @p hipMemHandleTypeWin32 is specified"]
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved for future use, must be 0"]
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[doc = " Opaque data structure for exporting a pool allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemPoolPtrExportData {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipJitOption {
    hipJitOptionMaxRegisters = 0,
    hipJitOptionThreadsPerBlock = 1,
    hipJitOptionWallTime = 2,
    hipJitOptionInfoLogBuffer = 3,
    hipJitOptionInfoLogBufferSizeBytes = 4,
    hipJitOptionErrorLogBuffer = 5,
    hipJitOptionErrorLogBufferSizeBytes = 6,
    hipJitOptionOptimizationLevel = 7,
    hipJitOptionTargetFromContext = 8,
    hipJitOptionTarget = 9,
    hipJitOptionFallbackStrategy = 10,
    hipJitOptionGenerateDebugInfo = 11,
    hipJitOptionLogVerbose = 12,
    hipJitOptionGenerateLineInfo = 13,
    hipJitOptionCacheMode = 14,
    hipJitOptionSm3xOpt = 15,
    hipJitOptionFastCompile = 16,
    hipJitOptionNumOptions = 17,
}
#[repr(u32)]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipFuncAttribute {
    hipFuncAttributeMaxDynamicSharedMemorySize = 8,
    hipFuncAttributePreferredSharedMemoryCarveout = 9,
    hipFuncAttributeMax = 10,
}
#[repr(u32)]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipFuncCache_t {
    #[doc = "< no preference for shared memory or L1 (default)"]
    hipFuncCachePreferNone = 0,
    #[doc = "< prefer larger shared memory and smaller L1 cache"]
    hipFuncCachePreferShared = 1,
    #[doc = "< prefer larger L1 cache and smaller shared memory"]
    hipFuncCachePreferL1 = 2,
    #[doc = "< prefer equal size L1 cache and shared memory"]
    hipFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipSharedMemConfig {
    #[doc = "< The compiler selects a device-specific value for the banking."]
    hipSharedMemBankSizeDefault = 0,
    #[doc = "< Shared mem is banked at 4-bytes intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeFourByte = 1,
    #[doc = "< Shared mem is banked at 8-byte intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeEightByte = 2,
}
#[doc = " Struct for data in 3D\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    #[doc = "< x"]
    pub x: u32,
    #[doc = "< y"]
    pub y: u32,
    #[doc = "< z"]
    pub z: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipLaunchParams_t {
    #[doc = "< Device function symbol"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: hipStream_t,
}
pub type hipLaunchParams = hipLaunchParams_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipExternalMemoryHandleType_enum {
    hipExternalMemoryHandleTypeOpaqueFd = 1,
    hipExternalMemoryHandleTypeOpaqueWin32 = 2,
    hipExternalMemoryHandleTypeOpaqueWin32Kmt = 3,
    hipExternalMemoryHandleTypeD3D12Heap = 4,
    hipExternalMemoryHandleTypeD3D12Resource = 5,
    hipExternalMemoryHandleTypeD3D11Resource = 6,
    hipExternalMemoryHandleTypeD3D11ResourceKmt = 7,
}
pub use self::hipExternalMemoryHandleType_enum as hipExternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st {
    pub type_: hipExternalMemoryHandleType,
    pub handle: hipExternalMemoryHandleDesc_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalMemoryHandleDesc_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
pub type hipExternalMemoryHandleDesc = hipExternalMemoryHandleDesc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryBufferDesc_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
}
pub type hipExternalMemoryBufferDesc = hipExternalMemoryBufferDesc_st;
pub type hipExternalMemory_t = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipExternalSemaphoreHandleType_enum {
    hipExternalSemaphoreHandleTypeOpaqueFd = 1,
    hipExternalSemaphoreHandleTypeOpaqueWin32 = 2,
    hipExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    hipExternalSemaphoreHandleTypeD3D12Fence = 4,
}
pub use self::hipExternalSemaphoreHandleType_enum as hipExternalSemaphoreHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreHandleDesc_st {
    pub type_: hipExternalSemaphoreHandleType,
    pub handle: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreHandleDesc_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
pub type hipExternalSemaphoreHandleDesc = hipExternalSemaphoreHandleDesc_st;
pub type hipExternalSemaphore_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st {
    pub params: hipExternalSemaphoreSignalParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1,
    pub keyedMutex: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub key: ::std::os::raw::c_ulonglong,
}
pub type hipExternalSemaphoreSignalParams = hipExternalSemaphoreSignalParams_st;
#[doc = " External semaphore wait parameters, compatible with driver type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st {
    pub params: hipExternalSemaphoreWaitParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1,
    pub keyedMutex: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub key: ::std::os::raw::c_ulonglong,
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[doc = " External semaphore wait parameters, compatible with driver type"]
pub type hipExternalSemaphoreWaitParams = hipExternalSemaphoreWaitParams_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGLDeviceList {
    #[doc = "< All hip devices used by current OpenGL context."]
    hipGLDeviceListAll = 1,
    #[doc = "< Hip devices used by current OpenGL context in current\n< frame"]
    hipGLDeviceListCurrentFrame = 2,
    #[doc = "< Hip devices used by current OpenGL context in next\n< frame."]
    hipGLDeviceListNextFrame = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _hipGraphicsResource {
    _unused: [u8; 0],
}
pub type hipGraphicsResource = _hipGraphicsResource;
pub type hipGraphicsResource_t = *mut hipGraphicsResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipGraph {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph"]
pub type hipGraph_t = *mut ihipGraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphNode {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph node"]
pub type hipGraphNode_t = *mut hipGraphNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphExec {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph Exec"]
pub type hipGraphExec_t = *mut hipGraphExec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipUserObject {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a user obj"]
pub type hipUserObject_t = *mut hipUserObject;
#[repr(u32)]
#[doc = " @brief hipGraphNodeType\n @enum\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphNodeType {
    #[doc = "< GPU kernel node"]
    hipGraphNodeTypeKernel = 0,
    #[doc = "< Memcpy node"]
    hipGraphNodeTypeMemcpy = 1,
    #[doc = "< Memset node"]
    hipGraphNodeTypeMemset = 2,
    #[doc = "< Host (executable) node"]
    hipGraphNodeTypeHost = 3,
    #[doc = "< Node which executes an embedded graph"]
    hipGraphNodeTypeGraph = 4,
    #[doc = "< Empty (no-op) node"]
    hipGraphNodeTypeEmpty = 5,
    #[doc = "< External event wait node"]
    hipGraphNodeTypeWaitEvent = 6,
    #[doc = "< External event record node"]
    hipGraphNodeTypeEventRecord = 7,
    #[doc = "< External Semaphore signal node"]
    hipGraphNodeTypeExtSemaphoreSignal = 8,
    #[doc = "< External Semaphore wait node"]
    hipGraphNodeTypeExtSemaphoreWait = 9,
    #[doc = "< MemcpyFromSymbol node"]
    hipGraphNodeTypeMemcpyFromSymbol = 10,
    #[doc = "< MemcpyToSymbol node"]
    hipGraphNodeTypeMemcpyToSymbol = 11,
    hipGraphNodeTypeCount = 12,
}
pub type hipHostFn_t =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipHostNodeParams {
    pub fn_: hipHostFn_t,
    pub userData: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipKernelNodeParams {
    pub blockDim: dim3,
    pub extra: *mut *mut ::std::os::raw::c_void,
    pub func: *mut ::std::os::raw::c_void,
    pub gridDim: dim3,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    pub sharedMemBytes: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemsetParams {
    pub dst: *mut ::std::os::raw::c_void,
    pub elementSize: ::std::os::raw::c_uint,
    pub height: usize,
    pub pitch: usize,
    pub value: ::std::os::raw::c_uint,
    pub width: usize,
}
#[repr(u32)]
#[doc = " @brief hipKernelNodeAttrID\n @enum\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipKernelNodeAttrID {
    hipKernelNodeAttributeAccessPolicyWindow = 1,
    hipKernelNodeAttributeCooperative = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipAccessProperty {
    hipAccessPropertyNormal = 0,
    hipAccessPropertyStreaming = 1,
    hipAccessPropertyPersisting = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipAccessPolicyWindow {
    pub base_ptr: *mut ::std::os::raw::c_void,
    pub hitProp: hipAccessProperty,
    pub hitRatio: f32,
    pub missProp: hipAccessProperty,
    pub num_bytes: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipKernelNodeAttrValue {
    pub accessPolicyWindow: hipAccessPolicyWindow,
    pub cooperative: ::std::os::raw::c_int,
}
#[repr(u32)]
#[doc = " @brief hipGraphExecUpdateResult\n @enum\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphExecUpdateResult {
    #[doc = "< The update succeeded"]
    hipGraphExecUpdateSuccess = 0,
    #[doc = "< The update failed for an unexpected reason which is described\n< in the return value of the function"]
    hipGraphExecUpdateError = 1,
    #[doc = "< The update failed because the topology changed"]
    hipGraphExecUpdateErrorTopologyChanged = 2,
    #[doc = "< The update failed because a node type changed"]
    hipGraphExecUpdateErrorNodeTypeChanged = 3,
    hipGraphExecUpdateErrorFunctionChanged = 4,
    hipGraphExecUpdateErrorParametersChanged = 5,
    hipGraphExecUpdateErrorNotSupported = 6,
    hipGraphExecUpdateErrorUnsupportedFunctionChange = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipStreamCaptureMode {
    hipStreamCaptureModeGlobal = 0,
    hipStreamCaptureModeThreadLocal = 1,
    hipStreamCaptureModeRelaxed = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipStreamCaptureStatus {
    #[doc = "< Stream is not capturing"]
    hipStreamCaptureStatusNone = 0,
    #[doc = "< Stream is actively capturing"]
    hipStreamCaptureStatusActive = 1,
    #[doc = "< Stream is part of a capture sequence that has been\n< invalidated, but not terminated"]
    hipStreamCaptureStatusInvalidated = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipGraphMemAttributeType {
    #[doc = "< Amount of memory, in bytes, currently associated with graphs"]
    hipGraphMemAttrUsedMemCurrent = 0,
    #[doc = "< High watermark of memory, in bytes, associated with graphs since the last time."]
    hipGraphMemAttrUsedMemHigh = 1,
    #[doc = "< Amount of memory, in bytes, currently allocated for graphs."]
    hipGraphMemAttrReservedMemCurrent = 2,
    #[doc = "< High watermark of memory, in bytes, currently allocated for graphs"]
    hipGraphMemAttrReservedMemHigh = 3,
}
#[doc = " Memory allocation properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocationProp {
    #[doc = "< Memory allocation type"]
    pub type_: hipMemAllocationType,
    #[doc = "< Requested handle type"]
    pub requestedHandleType: hipMemAllocationHandleType,
    #[doc = "< Memory location"]
    pub location: hipMemLocation,
    #[doc = "< Metadata for Win32 handles"]
    pub win32HandleMetaData: *mut ::std::os::raw::c_void,
    pub allocFlags: hipMemAllocationProp__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocationProp__bindgen_ty_1 {
    #[doc = "< Compression type"]
    pub compressionType: ::std::os::raw::c_uchar,
    #[doc = "< RDMA capable"]
    pub gpuDirectRDMACapable: ::std::os::raw::c_uchar,
    #[doc = "< Usage"]
    pub usage: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemGenericAllocationHandle {
    _unused: [u8; 0],
}
#[doc = " Generic handle for memory allocation"]
pub type hipMemGenericAllocationHandle_t = *mut ihipMemGenericAllocationHandle;
#[repr(u32)]
#[doc = " @brief Flags for granularity\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemAllocationGranularity_flags {
    #[doc = "< Minimum granularity"]
    hipMemAllocationGranularityMinimum = 0,
    #[doc = "< Recommended granularity for performance"]
    hipMemAllocationGranularityRecommended = 1,
}
#[repr(u32)]
#[doc = " @brief Memory handle type\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemHandleType {
    #[doc = "< Generic handle type"]
    hipMemHandleTypeGeneric = 0,
}
#[repr(u32)]
#[doc = " @brief Memory operation types\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipMemOperationType {
    #[doc = "< Map operation"]
    hipMemOperationTypeMap = 1,
    #[doc = "< Unmap operation"]
    hipMemOperationTypeUnmap = 2,
}
#[repr(u32)]
#[doc = " @brief Subresource types for sparse arrays\n @enum\n @ingroup Enumerations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hipArraySparseSubresourceType {
    #[doc = "< Sparse level"]
    hipArraySparseSubresourceTypeSparseLevel = 0,
    #[doc = "< Miptail"]
    hipArraySparseSubresourceTypeMiptail = 1,
}
#[doc = " Map info for arrays"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipArrayMapInfo {
    #[doc = "< Resource type"]
    pub resourceType: hipResourceType,
    pub resource: hipArrayMapInfo__bindgen_ty_1,
    #[doc = "< Sparse subresource type"]
    pub subresourceType: hipArraySparseSubresourceType,
    pub subresource: hipArrayMapInfo__bindgen_ty_2,
    #[doc = "< Memory operation type"]
    pub memOperationType: hipMemOperationType,
    #[doc = "< Memory handle type"]
    pub memHandleType: hipMemHandleType,
    pub memHandle: hipArrayMapInfo__bindgen_ty_3,
    #[doc = "< Offset within the memory"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Device ordinal bit mask"]
    pub deviceBitMask: ::std::os::raw::c_uint,
    #[doc = "< flags for future use, must be zero now."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use, must be zero now."]
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_1 {
    pub mipmap: hipMipmappedArray,
    pub array: hipArray_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_2 {
    pub sparseLevel: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1,
    pub miptail: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< For mipmapped arrays must be a valid mipmap level. For arrays must be zero"]
    pub level: ::std::os::raw::c_uint,
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< X offset in elements"]
    pub offsetX: ::std::os::raw::c_uint,
    #[doc = "< Y offset in elements"]
    pub offsetY: ::std::os::raw::c_uint,
    #[doc = "< Z offset in elements"]
    pub offsetZ: ::std::os::raw::c_uint,
    #[doc = "< Width in elements"]
    pub extentWidth: ::std::os::raw::c_uint,
    #[doc = "< Height in elements"]
    pub extentHeight: ::std::os::raw::c_uint,
    #[doc = "< Depth in elements"]
    pub extentDepth: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< Offset within mip tail"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Extent in bytes"]
    pub size: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_3 {
    pub memHandle: hipMemGenericAllocationHandle_t,
}
#[doc = " Stream CallBack struct"]
pub type hipStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: hipStream_t,
        status: hipError_t,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup GL Interop\n  @{\n  This section describes Stream Memory Wait and Write functions of HIP runtime API."]
pub type GLuint = ::std::os::raw::c_uint;
pub type GLenum = ::std::os::raw::c_uint;
extern crate libloading;
pub struct hip {
    __library: ::libloading::Library,
    pub hipCreateChannelDesc: Result<
        unsafe extern "C" fn(
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            z: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            f: hipChannelFormatKind,
        ) -> hipChannelFormatDesc,
        ::libloading::Error,
    >,
    pub hipInit: Result<
        unsafe extern "C" fn(flags: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDriverGetVersion: Result<
        unsafe extern "C" fn(driverVersion: *mut ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipRuntimeGetVersion: Result<
        unsafe extern "C" fn(runtimeVersion: *mut ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGet: Result<
        unsafe extern "C" fn(
            device: *mut hipDevice_t,
            ordinal: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceComputeCapability: Result<
        unsafe extern "C" fn(
            major: *mut ::std::os::raw::c_int,
            minor: *mut ::std::os::raw::c_int,
            device: hipDevice_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetName: Result<
        unsafe extern "C" fn(
            name: *mut ::std::os::raw::c_char,
            len: ::std::os::raw::c_int,
            device: hipDevice_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetUuid: Result<
        unsafe extern "C" fn(uuid: *mut hipUUID, device: hipDevice_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetP2PAttribute: Result<
        unsafe extern "C" fn(
            value: *mut ::std::os::raw::c_int,
            attr: hipDeviceP2PAttr,
            srcDevice: ::std::os::raw::c_int,
            dstDevice: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetPCIBusId: Result<
        unsafe extern "C" fn(
            pciBusId: *mut ::std::os::raw::c_char,
            len: ::std::os::raw::c_int,
            device: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetByPCIBusId: Result<
        unsafe extern "C" fn(
            device: *mut ::std::os::raw::c_int,
            pciBusId: *const ::std::os::raw::c_char,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceTotalMem: Result<
        unsafe extern "C" fn(bytes: *mut usize, device: hipDevice_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceSynchronize: Result<unsafe extern "C" fn() -> hipError_t, ::libloading::Error>,
    pub hipDeviceReset: Result<unsafe extern "C" fn() -> hipError_t, ::libloading::Error>,
    pub hipSetDevice: Result<
        unsafe extern "C" fn(deviceId: ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetDevice: Result<
        unsafe extern "C" fn(deviceId: *mut ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetDeviceCount: Result<
        unsafe extern "C" fn(count: *mut ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetAttribute: Result<
        unsafe extern "C" fn(
            pi: *mut ::std::os::raw::c_int,
            attr: hipDeviceAttribute_t,
            deviceId: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetDefaultMemPool: Result<
        unsafe extern "C" fn(
            mem_pool: *mut hipMemPool_t,
            device: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceSetMemPool: Result<
        unsafe extern "C" fn(device: ::std::os::raw::c_int, mem_pool: hipMemPool_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetMemPool: Result<
        unsafe extern "C" fn(
            mem_pool: *mut hipMemPool_t,
            device: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetDeviceProperties: Result<
        unsafe extern "C" fn(
            prop: *mut hipDeviceProp_t,
            deviceId: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceSetCacheConfig: Result<
        unsafe extern "C" fn(cacheConfig: hipFuncCache_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetCacheConfig: Result<
        unsafe extern "C" fn(cacheConfig: *mut hipFuncCache_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetLimit: Result<
        unsafe extern "C" fn(pValue: *mut usize, limit: hipLimit_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceSetLimit: Result<
        unsafe extern "C" fn(limit: hipLimit_t, value: usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetSharedMemConfig: Result<
        unsafe extern "C" fn(pConfig: *mut hipSharedMemConfig) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetDeviceFlags: Result<
        unsafe extern "C" fn(flags: *mut ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceSetSharedMemConfig:
        Result<unsafe extern "C" fn(config: hipSharedMemConfig) -> hipError_t, ::libloading::Error>,
    pub hipSetDeviceFlags: Result<
        unsafe extern "C" fn(flags: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipChooseDevice: Result<
        unsafe extern "C" fn(
            device: *mut ::std::os::raw::c_int,
            prop: *const hipDeviceProp_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipExtGetLinkTypeAndHopCount: Result<
        unsafe extern "C" fn(
            device1: ::std::os::raw::c_int,
            device2: ::std::os::raw::c_int,
            linktype: *mut u32,
            hopcount: *mut u32,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipIpcGetMemHandle: Result<
        unsafe extern "C" fn(
            handle: *mut hipIpcMemHandle_t,
            devPtr: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipIpcOpenMemHandle: Result<
        unsafe extern "C" fn(
            devPtr: *mut *mut ::std::os::raw::c_void,
            handle: hipIpcMemHandle_t,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipIpcCloseMemHandle: Result<
        unsafe extern "C" fn(devPtr: *mut ::std::os::raw::c_void) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipIpcGetEventHandle: Result<
        unsafe extern "C" fn(handle: *mut hipIpcEventHandle_t, event: hipEvent_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipIpcOpenEventHandle: Result<
        unsafe extern "C" fn(event: *mut hipEvent_t, handle: hipIpcEventHandle_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFuncSetAttribute: Result<
        unsafe extern "C" fn(
            func: *const ::std::os::raw::c_void,
            attr: hipFuncAttribute,
            value: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFuncSetCacheConfig: Result<
        unsafe extern "C" fn(
            func: *const ::std::os::raw::c_void,
            config: hipFuncCache_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFuncSetSharedMemConfig: Result<
        unsafe extern "C" fn(
            func: *const ::std::os::raw::c_void,
            config: hipSharedMemConfig,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetLastError: Result<unsafe extern "C" fn() -> hipError_t, ::libloading::Error>,
    pub hipPeekAtLastError: Result<unsafe extern "C" fn() -> hipError_t, ::libloading::Error>,
    pub hipGetErrorName: Result<
        unsafe extern "C" fn(hip_error: hipError_t) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub hipGetErrorString: Result<
        unsafe extern "C" fn(hipError: hipError_t) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub hipDrvGetErrorName: Result<
        unsafe extern "C" fn(
            hipError: hipError_t,
            errorString: *mut *const ::std::os::raw::c_char,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDrvGetErrorString: Result<
        unsafe extern "C" fn(
            hipError: hipError_t,
            errorString: *mut *const ::std::os::raw::c_char,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamCreate:
        Result<unsafe extern "C" fn(stream: *mut hipStream_t) -> hipError_t, ::libloading::Error>,
    pub hipStreamCreateWithFlags: Result<
        unsafe extern "C" fn(stream: *mut hipStream_t, flags: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamCreateWithPriority: Result<
        unsafe extern "C" fn(
            stream: *mut hipStream_t,
            flags: ::std::os::raw::c_uint,
            priority: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetStreamPriorityRange: Result<
        unsafe extern "C" fn(
            leastPriority: *mut ::std::os::raw::c_int,
            greatestPriority: *mut ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamDestroy:
        Result<unsafe extern "C" fn(stream: hipStream_t) -> hipError_t, ::libloading::Error>,
    pub hipStreamQuery:
        Result<unsafe extern "C" fn(stream: hipStream_t) -> hipError_t, ::libloading::Error>,
    pub hipStreamSynchronize:
        Result<unsafe extern "C" fn(stream: hipStream_t) -> hipError_t, ::libloading::Error>,
    pub hipStreamWaitEvent: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            event: hipEvent_t,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamGetFlags: Result<
        unsafe extern "C" fn(stream: hipStream_t, flags: *mut ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamGetPriority: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            priority: *mut ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipExtStreamCreateWithCUMask: Result<
        unsafe extern "C" fn(
            stream: *mut hipStream_t,
            cuMaskSize: u32,
            cuMask: *const u32,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipExtStreamGetCUMask: Result<
        unsafe extern "C" fn(stream: hipStream_t, cuMaskSize: u32, cuMask: *mut u32) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamAddCallback: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            callback: hipStreamCallback_t,
            userData: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamWaitValue32: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            ptr: *mut ::std::os::raw::c_void,
            value: u32,
            flags: ::std::os::raw::c_uint,
            mask: u32,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamWaitValue64: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            ptr: *mut ::std::os::raw::c_void,
            value: u64,
            flags: ::std::os::raw::c_uint,
            mask: u64,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamWriteValue32: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            ptr: *mut ::std::os::raw::c_void,
            value: u32,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamWriteValue64: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            ptr: *mut ::std::os::raw::c_void,
            value: u64,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipEventCreateWithFlags: Result<
        unsafe extern "C" fn(event: *mut hipEvent_t, flags: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipEventCreate:
        Result<unsafe extern "C" fn(event: *mut hipEvent_t) -> hipError_t, ::libloading::Error>,
    pub hipEventRecord: Result<
        unsafe extern "C" fn(event: hipEvent_t, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipEventDestroy:
        Result<unsafe extern "C" fn(event: hipEvent_t) -> hipError_t, ::libloading::Error>,
    pub hipEventSynchronize:
        Result<unsafe extern "C" fn(event: hipEvent_t) -> hipError_t, ::libloading::Error>,
    pub hipEventElapsedTime: Result<
        unsafe extern "C" fn(ms: *mut f32, start: hipEvent_t, stop: hipEvent_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipEventQuery:
        Result<unsafe extern "C" fn(event: hipEvent_t) -> hipError_t, ::libloading::Error>,
    pub hipPointerGetAttributes: Result<
        unsafe extern "C" fn(
            attributes: *mut hipPointerAttribute_t,
            ptr: *const ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipPointerGetAttribute: Result<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            attribute: hipPointer_attribute,
            ptr: hipDeviceptr_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDrvPointerGetAttributes: Result<
        unsafe extern "C" fn(
            numAttributes: ::std::os::raw::c_uint,
            attributes: *mut hipPointer_attribute,
            data: *mut *mut ::std::os::raw::c_void,
            ptr: hipDeviceptr_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipImportExternalSemaphore: Result<
        unsafe extern "C" fn(
            extSem_out: *mut hipExternalSemaphore_t,
            semHandleDesc: *const hipExternalSemaphoreHandleDesc,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipSignalExternalSemaphoresAsync: Result<
        unsafe extern "C" fn(
            extSemArray: *const hipExternalSemaphore_t,
            paramsArray: *const hipExternalSemaphoreSignalParams,
            numExtSems: ::std::os::raw::c_uint,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipWaitExternalSemaphoresAsync: Result<
        unsafe extern "C" fn(
            extSemArray: *const hipExternalSemaphore_t,
            paramsArray: *const hipExternalSemaphoreWaitParams,
            numExtSems: ::std::os::raw::c_uint,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDestroyExternalSemaphore: Result<
        unsafe extern "C" fn(extSem: hipExternalSemaphore_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipImportExternalMemory: Result<
        unsafe extern "C" fn(
            extMem_out: *mut hipExternalMemory_t,
            memHandleDesc: *const hipExternalMemoryHandleDesc,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipExternalMemoryGetMappedBuffer: Result<
        unsafe extern "C" fn(
            devPtr: *mut *mut ::std::os::raw::c_void,
            extMem: hipExternalMemory_t,
            bufferDesc: *const hipExternalMemoryBufferDesc,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDestroyExternalMemory: Result<
        unsafe extern "C" fn(extMem: hipExternalMemory_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMalloc: Result<
        unsafe extern "C" fn(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipExtMallocWithFlags: Result<
        unsafe extern "C" fn(
            ptr: *mut *mut ::std::os::raw::c_void,
            sizeBytes: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMallocHost: Result<
        unsafe extern "C" fn(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemAllocHost: Result<
        unsafe extern "C" fn(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipHostMalloc: Result<
        unsafe extern "C" fn(
            ptr: *mut *mut ::std::os::raw::c_void,
            size: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMallocManaged: Result<
        unsafe extern "C" fn(
            dev_ptr: *mut *mut ::std::os::raw::c_void,
            size: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPrefetchAsync: Result<
        unsafe extern "C" fn(
            dev_ptr: *const ::std::os::raw::c_void,
            count: usize,
            device: ::std::os::raw::c_int,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemAdvise: Result<
        unsafe extern "C" fn(
            dev_ptr: *const ::std::os::raw::c_void,
            count: usize,
            advice: hipMemoryAdvise,
            device: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemRangeGetAttribute: Result<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            data_size: usize,
            attribute: hipMemRangeAttribute,
            dev_ptr: *const ::std::os::raw::c_void,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemRangeGetAttributes: Result<
        unsafe extern "C" fn(
            data: *mut *mut ::std::os::raw::c_void,
            data_sizes: *mut usize,
            attributes: *mut hipMemRangeAttribute,
            num_attributes: usize,
            dev_ptr: *const ::std::os::raw::c_void,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamAttachMemAsync: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            dev_ptr: *mut ::std::os::raw::c_void,
            length: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMallocAsync: Result<
        unsafe extern "C" fn(
            dev_ptr: *mut *mut ::std::os::raw::c_void,
            size: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFreeAsync: Result<
        unsafe extern "C" fn(
            dev_ptr: *mut ::std::os::raw::c_void,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolTrimTo: Result<
        unsafe extern "C" fn(mem_pool: hipMemPool_t, min_bytes_to_hold: usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolSetAttribute: Result<
        unsafe extern "C" fn(
            mem_pool: hipMemPool_t,
            attr: hipMemPoolAttr,
            value: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolGetAttribute: Result<
        unsafe extern "C" fn(
            mem_pool: hipMemPool_t,
            attr: hipMemPoolAttr,
            value: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolSetAccess: Result<
        unsafe extern "C" fn(
            mem_pool: hipMemPool_t,
            desc_list: *const hipMemAccessDesc,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolGetAccess: Result<
        unsafe extern "C" fn(
            flags: *mut hipMemAccessFlags,
            mem_pool: hipMemPool_t,
            location: *mut hipMemLocation,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolCreate: Result<
        unsafe extern "C" fn(
            mem_pool: *mut hipMemPool_t,
            pool_props: *const hipMemPoolProps,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolDestroy:
        Result<unsafe extern "C" fn(mem_pool: hipMemPool_t) -> hipError_t, ::libloading::Error>,
    pub hipMallocFromPoolAsync: Result<
        unsafe extern "C" fn(
            dev_ptr: *mut *mut ::std::os::raw::c_void,
            size: usize,
            mem_pool: hipMemPool_t,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolExportToShareableHandle: Result<
        unsafe extern "C" fn(
            shared_handle: *mut ::std::os::raw::c_void,
            mem_pool: hipMemPool_t,
            handle_type: hipMemAllocationHandleType,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolImportFromShareableHandle: Result<
        unsafe extern "C" fn(
            mem_pool: *mut hipMemPool_t,
            shared_handle: *mut ::std::os::raw::c_void,
            handle_type: hipMemAllocationHandleType,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolExportPointer: Result<
        unsafe extern "C" fn(
            export_data: *mut hipMemPoolPtrExportData,
            dev_ptr: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPoolImportPointer: Result<
        unsafe extern "C" fn(
            dev_ptr: *mut *mut ::std::os::raw::c_void,
            mem_pool: hipMemPool_t,
            export_data: *mut hipMemPoolPtrExportData,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipHostAlloc: Result<
        unsafe extern "C" fn(
            ptr: *mut *mut ::std::os::raw::c_void,
            size: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipHostGetDevicePointer: Result<
        unsafe extern "C" fn(
            devPtr: *mut *mut ::std::os::raw::c_void,
            hstPtr: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipHostGetFlags: Result<
        unsafe extern "C" fn(
            flagsPtr: *mut ::std::os::raw::c_uint,
            hostPtr: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipHostRegister: Result<
        unsafe extern "C" fn(
            hostPtr: *mut ::std::os::raw::c_void,
            sizeBytes: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipHostUnregister: Result<
        unsafe extern "C" fn(hostPtr: *mut ::std::os::raw::c_void) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMallocPitch: Result<
        unsafe extern "C" fn(
            ptr: *mut *mut ::std::os::raw::c_void,
            pitch: *mut usize,
            width: usize,
            height: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemAllocPitch: Result<
        unsafe extern "C" fn(
            dptr: *mut hipDeviceptr_t,
            pitch: *mut usize,
            widthInBytes: usize,
            height: usize,
            elementSizeBytes: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFree: Result<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFreeHost: Result<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipHostFree: Result<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyWithStream: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyHtoD: Result<
        unsafe extern "C" fn(
            dst: hipDeviceptr_t,
            src: *mut ::std::os::raw::c_void,
            sizeBytes: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyDtoH: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: hipDeviceptr_t,
            sizeBytes: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyDtoD: Result<
        unsafe extern "C" fn(
            dst: hipDeviceptr_t,
            src: hipDeviceptr_t,
            sizeBytes: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyHtoDAsync: Result<
        unsafe extern "C" fn(
            dst: hipDeviceptr_t,
            src: *mut ::std::os::raw::c_void,
            sizeBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyDtoHAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: hipDeviceptr_t,
            sizeBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyDtoDAsync: Result<
        unsafe extern "C" fn(
            dst: hipDeviceptr_t,
            src: hipDeviceptr_t,
            sizeBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleGetGlobal: Result<
        unsafe extern "C" fn(
            dptr: *mut hipDeviceptr_t,
            bytes: *mut usize,
            hmod: hipModule_t,
            name: *const ::std::os::raw::c_char,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetSymbolAddress: Result<
        unsafe extern "C" fn(
            devPtr: *mut *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetSymbolSize: Result<
        unsafe extern "C" fn(size: *mut usize, symbol: *const ::std::os::raw::c_void) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyToSymbol: Result<
        unsafe extern "C" fn(
            symbol: *const ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyToSymbolAsync: Result<
        unsafe extern "C" fn(
            symbol: *const ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyFromSymbol: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyFromSymbolAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            value: ::std::os::raw::c_int,
            sizeBytes: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetD8: Result<
        unsafe extern "C" fn(
            dest: hipDeviceptr_t,
            value: ::std::os::raw::c_uchar,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetD8Async: Result<
        unsafe extern "C" fn(
            dest: hipDeviceptr_t,
            value: ::std::os::raw::c_uchar,
            count: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetD16: Result<
        unsafe extern "C" fn(
            dest: hipDeviceptr_t,
            value: ::std::os::raw::c_ushort,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetD16Async: Result<
        unsafe extern "C" fn(
            dest: hipDeviceptr_t,
            value: ::std::os::raw::c_ushort,
            count: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetD32: Result<
        unsafe extern "C" fn(
            dest: hipDeviceptr_t,
            value: ::std::os::raw::c_int,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            value: ::std::os::raw::c_int,
            sizeBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetD32Async: Result<
        unsafe extern "C" fn(
            dst: hipDeviceptr_t,
            value: ::std::os::raw::c_int,
            count: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset2D: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            pitch: usize,
            value: ::std::os::raw::c_int,
            width: usize,
            height: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset2DAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            pitch: usize,
            value: ::std::os::raw::c_int,
            width: usize,
            height: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset3D: Result<
        unsafe extern "C" fn(
            pitchedDevPtr: hipPitchedPtr,
            value: ::std::os::raw::c_int,
            extent: hipExtent,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset3DAsync: Result<
        unsafe extern "C" fn(
            pitchedDevPtr: hipPitchedPtr,
            value: ::std::os::raw::c_int,
            extent: hipExtent,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemGetInfo: Result<
        unsafe extern "C" fn(free: *mut usize, total: *mut usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemPtrGetInfo: Result<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, size: *mut usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMallocArray: Result<
        unsafe extern "C" fn(
            array: *mut *mut hipArray,
            desc: *const hipChannelFormatDesc,
            width: usize,
            height: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipArrayCreate: Result<
        unsafe extern "C" fn(
            pHandle: *mut *mut hipArray,
            pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipArrayDestroy:
        Result<unsafe extern "C" fn(array: *mut hipArray) -> hipError_t, ::libloading::Error>,
    pub hipArray3DCreate: Result<
        unsafe extern "C" fn(
            array: *mut *mut hipArray,
            pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMalloc3D: Result<
        unsafe extern "C" fn(pitchedDevPtr: *mut hipPitchedPtr, extent: hipExtent) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFreeArray:
        Result<unsafe extern "C" fn(array: *mut hipArray) -> hipError_t, ::libloading::Error>,
    pub hipFreeMipmappedArray: Result<
        unsafe extern "C" fn(mipmappedArray: hipMipmappedArray_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMalloc3DArray: Result<
        unsafe extern "C" fn(
            array: *mut *mut hipArray,
            desc: *const hipChannelFormatDesc,
            extent: hipExtent,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMallocMipmappedArray: Result<
        unsafe extern "C" fn(
            mipmappedArray: *mut hipMipmappedArray_t,
            desc: *const hipChannelFormatDesc,
            extent: hipExtent,
            numLevels: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetMipmappedArrayLevel: Result<
        unsafe extern "C" fn(
            levelArray: *mut hipArray_t,
            mipmappedArray: hipMipmappedArray_const_t,
            level: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2D: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyParam2D:
        Result<unsafe extern "C" fn(pCopy: *const hip_Memcpy2D) -> hipError_t, ::libloading::Error>,
    pub hipMemcpyParam2DAsync: Result<
        unsafe extern "C" fn(pCopy: *const hip_Memcpy2D, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DToArray: Result<
        unsafe extern "C" fn(
            dst: *mut hipArray,
            wOffset: usize,
            hOffset: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DToArrayAsync: Result<
        unsafe extern "C" fn(
            dst: *mut hipArray,
            wOffset: usize,
            hOffset: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyToArray: Result<
        unsafe extern "C" fn(
            dst: *mut hipArray,
            wOffset: usize,
            hOffset: usize,
            src: *const ::std::os::raw::c_void,
            count: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyFromArray: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            srcArray: hipArray_const_t,
            wOffset: usize,
            hOffset: usize,
            count: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DFromArray: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: hipArray_const_t,
            wOffset: usize,
            hOffset: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DFromArrayAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: hipArray_const_t,
            wOffset: usize,
            hOffset: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyAtoH: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            srcArray: *mut hipArray,
            srcOffset: usize,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyHtoA: Result<
        unsafe extern "C" fn(
            dstArray: *mut hipArray,
            dstOffset: usize,
            srcHost: *const ::std::os::raw::c_void,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy3D:
        Result<unsafe extern "C" fn(p: *const hipMemcpy3DParms) -> hipError_t, ::libloading::Error>,
    pub hipMemcpy3DAsync: Result<
        unsafe extern "C" fn(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDrvMemcpy3D:
        Result<unsafe extern "C" fn(pCopy: *const HIP_MEMCPY3D) -> hipError_t, ::libloading::Error>,
    pub hipDrvMemcpy3DAsync: Result<
        unsafe extern "C" fn(pCopy: *const HIP_MEMCPY3D, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceCanAccessPeer: Result<
        unsafe extern "C" fn(
            canAccessPeer: *mut ::std::os::raw::c_int,
            deviceId: ::std::os::raw::c_int,
            peerDeviceId: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceEnablePeerAccess: Result<
        unsafe extern "C" fn(
            peerDeviceId: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceDisablePeerAccess: Result<
        unsafe extern "C" fn(peerDeviceId: ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemGetAddressRange: Result<
        unsafe extern "C" fn(
            pbase: *mut hipDeviceptr_t,
            psize: *mut usize,
            dptr: hipDeviceptr_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyPeer: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dstDeviceId: ::std::os::raw::c_int,
            src: *const ::std::os::raw::c_void,
            srcDeviceId: ::std::os::raw::c_int,
            sizeBytes: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyPeerAsync: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dstDeviceId: ::std::os::raw::c_int,
            src: *const ::std::os::raw::c_void,
            srcDevice: ::std::os::raw::c_int,
            sizeBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxCreate: Result<
        unsafe extern "C" fn(
            ctx: *mut hipCtx_t,
            flags: ::std::os::raw::c_uint,
            device: hipDevice_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxDestroy:
        Result<unsafe extern "C" fn(ctx: hipCtx_t) -> hipError_t, ::libloading::Error>,
    pub hipCtxPopCurrent:
        Result<unsafe extern "C" fn(ctx: *mut hipCtx_t) -> hipError_t, ::libloading::Error>,
    pub hipCtxPushCurrent:
        Result<unsafe extern "C" fn(ctx: hipCtx_t) -> hipError_t, ::libloading::Error>,
    pub hipCtxSetCurrent:
        Result<unsafe extern "C" fn(ctx: hipCtx_t) -> hipError_t, ::libloading::Error>,
    pub hipCtxGetCurrent:
        Result<unsafe extern "C" fn(ctx: *mut hipCtx_t) -> hipError_t, ::libloading::Error>,
    pub hipCtxGetDevice:
        Result<unsafe extern "C" fn(device: *mut hipDevice_t) -> hipError_t, ::libloading::Error>,
    pub hipCtxGetApiVersion: Result<
        unsafe extern "C" fn(ctx: hipCtx_t, apiVersion: *mut ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxGetCacheConfig: Result<
        unsafe extern "C" fn(cacheConfig: *mut hipFuncCache_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxSetCacheConfig: Result<
        unsafe extern "C" fn(cacheConfig: hipFuncCache_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxSetSharedMemConfig:
        Result<unsafe extern "C" fn(config: hipSharedMemConfig) -> hipError_t, ::libloading::Error>,
    pub hipCtxGetSharedMemConfig: Result<
        unsafe extern "C" fn(pConfig: *mut hipSharedMemConfig) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxSynchronize: Result<unsafe extern "C" fn() -> hipError_t, ::libloading::Error>,
    pub hipCtxGetFlags: Result<
        unsafe extern "C" fn(flags: *mut ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxEnablePeerAccess: Result<
        unsafe extern "C" fn(peerCtx: hipCtx_t, flags: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCtxDisablePeerAccess:
        Result<unsafe extern "C" fn(peerCtx: hipCtx_t) -> hipError_t, ::libloading::Error>,
    pub hipDevicePrimaryCtxGetState: Result<
        unsafe extern "C" fn(
            dev: hipDevice_t,
            flags: *mut ::std::os::raw::c_uint,
            active: *mut ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDevicePrimaryCtxRelease:
        Result<unsafe extern "C" fn(dev: hipDevice_t) -> hipError_t, ::libloading::Error>,
    pub hipDevicePrimaryCtxRetain: Result<
        unsafe extern "C" fn(pctx: *mut hipCtx_t, dev: hipDevice_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDevicePrimaryCtxReset:
        Result<unsafe extern "C" fn(dev: hipDevice_t) -> hipError_t, ::libloading::Error>,
    pub hipDevicePrimaryCtxSetFlags: Result<
        unsafe extern "C" fn(dev: hipDevice_t, flags: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleLoad: Result<
        unsafe extern "C" fn(
            module: *mut hipModule_t,
            fname: *const ::std::os::raw::c_char,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleUnload:
        Result<unsafe extern "C" fn(module: hipModule_t) -> hipError_t, ::libloading::Error>,
    pub hipModuleGetFunction: Result<
        unsafe extern "C" fn(
            function: *mut hipFunction_t,
            module: hipModule_t,
            kname: *const ::std::os::raw::c_char,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFuncGetAttributes: Result<
        unsafe extern "C" fn(
            attr: *mut hipFuncAttributes,
            func: *const ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipFuncGetAttribute: Result<
        unsafe extern "C" fn(
            value: *mut ::std::os::raw::c_int,
            attrib: hipFunction_attribute,
            hfunc: hipFunction_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleGetTexRef: Result<
        unsafe extern "C" fn(
            texRef: *mut *mut textureReference,
            hmod: hipModule_t,
            name: *const ::std::os::raw::c_char,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleLoadData: Result<
        unsafe extern "C" fn(
            module: *mut hipModule_t,
            image: *const ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleLoadDataEx: Result<
        unsafe extern "C" fn(
            module: *mut hipModule_t,
            image: *const ::std::os::raw::c_void,
            numOptions: ::std::os::raw::c_uint,
            options: *mut hipJitOption,
            optionValues: *mut *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleLaunchKernel: Result<
        unsafe extern "C" fn(
            f: hipFunction_t,
            gridDimX: ::std::os::raw::c_uint,
            gridDimY: ::std::os::raw::c_uint,
            gridDimZ: ::std::os::raw::c_uint,
            blockDimX: ::std::os::raw::c_uint,
            blockDimY: ::std::os::raw::c_uint,
            blockDimZ: ::std::os::raw::c_uint,
            sharedMemBytes: ::std::os::raw::c_uint,
            stream: hipStream_t,
            kernelParams: *mut *mut ::std::os::raw::c_void,
            extra: *mut *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchCooperativeKernel: Result<
        unsafe extern "C" fn(
            f: *const ::std::os::raw::c_void,
            gridDim: dim3,
            blockDimX: dim3,
            kernelParams: *mut *mut ::std::os::raw::c_void,
            sharedMemBytes: ::std::os::raw::c_uint,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchCooperativeKernelMultiDevice: Result<
        unsafe extern "C" fn(
            launchParamsList: *mut hipLaunchParams,
            numDevices: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipExtLaunchMultiKernelMultiDevice: Result<
        unsafe extern "C" fn(
            launchParamsList: *mut hipLaunchParams,
            numDevices: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleOccupancyMaxPotentialBlockSize: Result<
        unsafe extern "C" fn(
            gridSize: *mut ::std::os::raw::c_int,
            blockSize: *mut ::std::os::raw::c_int,
            f: hipFunction_t,
            dynSharedMemPerBlk: usize,
            blockSizeLimit: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleOccupancyMaxPotentialBlockSizeWithFlags: Result<
        unsafe extern "C" fn(
            gridSize: *mut ::std::os::raw::c_int,
            blockSize: *mut ::std::os::raw::c_int,
            f: hipFunction_t,
            dynSharedMemPerBlk: usize,
            blockSizeLimit: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleOccupancyMaxActiveBlocksPerMultiprocessor: Result<
        unsafe extern "C" fn(
            numBlocks: *mut ::std::os::raw::c_int,
            f: hipFunction_t,
            blockSize: ::std::os::raw::c_int,
            dynSharedMemPerBlk: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags: Result<
        unsafe extern "C" fn(
            numBlocks: *mut ::std::os::raw::c_int,
            f: hipFunction_t,
            blockSize: ::std::os::raw::c_int,
            dynSharedMemPerBlk: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipOccupancyMaxActiveBlocksPerMultiprocessor: Result<
        unsafe extern "C" fn(
            numBlocks: *mut ::std::os::raw::c_int,
            f: *const ::std::os::raw::c_void,
            blockSize: ::std::os::raw::c_int,
            dynSharedMemPerBlk: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags: Result<
        unsafe extern "C" fn(
            numBlocks: *mut ::std::os::raw::c_int,
            f: *const ::std::os::raw::c_void,
            blockSize: ::std::os::raw::c_int,
            dynSharedMemPerBlk: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipOccupancyMaxPotentialBlockSize: Result<
        unsafe extern "C" fn(
            gridSize: *mut ::std::os::raw::c_int,
            blockSize: *mut ::std::os::raw::c_int,
            f: *const ::std::os::raw::c_void,
            dynSharedMemPerBlk: usize,
            blockSizeLimit: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipProfilerStart: Result<unsafe extern "C" fn() -> hipError_t, ::libloading::Error>,
    pub hipProfilerStop: Result<unsafe extern "C" fn() -> hipError_t, ::libloading::Error>,
    pub hipConfigureCall: Result<
        unsafe extern "C" fn(
            gridDim: dim3,
            blockDim: dim3,
            sharedMem: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipSetupArgument: Result<
        unsafe extern "C" fn(
            arg: *const ::std::os::raw::c_void,
            size: usize,
            offset: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchByPtr: Result<
        unsafe extern "C" fn(func: *const ::std::os::raw::c_void) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchKernel: Result<
        unsafe extern "C" fn(
            function_address: *const ::std::os::raw::c_void,
            numBlocks: dim3,
            dimBlocks: dim3,
            args: *mut *mut ::std::os::raw::c_void,
            sharedMemBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchHostFunc: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            fn_: hipHostFn_t,
            userData: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDrvMemcpy2DUnaligned:
        Result<unsafe extern "C" fn(pCopy: *const hip_Memcpy2D) -> hipError_t, ::libloading::Error>,
    pub hipExtLaunchKernel: Result<
        unsafe extern "C" fn(
            function_address: *const ::std::os::raw::c_void,
            numBlocks: dim3,
            dimBlocks: dim3,
            args: *mut *mut ::std::os::raw::c_void,
            sharedMemBytes: usize,
            stream: hipStream_t,
            startEvent: hipEvent_t,
            stopEvent: hipEvent_t,
            flags: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipBindTextureToMipmappedArray: Result<
        unsafe extern "C" fn(
            tex: *const textureReference,
            mipmappedArray: hipMipmappedArray_const_t,
            desc: *const hipChannelFormatDesc,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipCreateTextureObject: Result<
        unsafe extern "C" fn(
            pTexObject: *mut hipTextureObject_t,
            pResDesc: *const hipResourceDesc,
            pTexDesc: *const hipTextureDesc,
            pResViewDesc: *const hipResourceViewDesc,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDestroyTextureObject: Result<
        unsafe extern "C" fn(textureObject: hipTextureObject_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetChannelDesc: Result<
        unsafe extern "C" fn(
            desc: *mut hipChannelFormatDesc,
            array: hipArray_const_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetTextureObjectResourceDesc: Result<
        unsafe extern "C" fn(
            pResDesc: *mut hipResourceDesc,
            textureObject: hipTextureObject_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetTextureObjectResourceViewDesc: Result<
        unsafe extern "C" fn(
            pResViewDesc: *mut hipResourceViewDesc,
            textureObject: hipTextureObject_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetTextureObjectTextureDesc: Result<
        unsafe extern "C" fn(
            pTexDesc: *mut hipTextureDesc,
            textureObject: hipTextureObject_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexObjectCreate: Result<
        unsafe extern "C" fn(
            pTexObject: *mut hipTextureObject_t,
            pResDesc: *const HIP_RESOURCE_DESC,
            pTexDesc: *const HIP_TEXTURE_DESC,
            pResViewDesc: *const HIP_RESOURCE_VIEW_DESC,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexObjectDestroy: Result<
        unsafe extern "C" fn(texObject: hipTextureObject_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexObjectGetResourceDesc: Result<
        unsafe extern "C" fn(
            pResDesc: *mut HIP_RESOURCE_DESC,
            texObject: hipTextureObject_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexObjectGetResourceViewDesc: Result<
        unsafe extern "C" fn(
            pResViewDesc: *mut HIP_RESOURCE_VIEW_DESC,
            texObject: hipTextureObject_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexObjectGetTextureDesc: Result<
        unsafe extern "C" fn(
            pTexDesc: *mut HIP_TEXTURE_DESC,
            texObject: hipTextureObject_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetTextureReference: Result<
        unsafe extern "C" fn(
            texref: *mut *const textureReference,
            symbol: *const ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetAddressMode: Result<
        unsafe extern "C" fn(
            texRef: *mut textureReference,
            dim: ::std::os::raw::c_int,
            am: hipTextureAddressMode,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetArray: Result<
        unsafe extern "C" fn(
            tex: *mut textureReference,
            array: hipArray_const_t,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetFilterMode: Result<
        unsafe extern "C" fn(texRef: *mut textureReference, fm: hipTextureFilterMode) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetFlags: Result<
        unsafe extern "C" fn(
            texRef: *mut textureReference,
            Flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetFormat: Result<
        unsafe extern "C" fn(
            texRef: *mut textureReference,
            fmt: hipArray_Format,
            NumPackedComponents: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipBindTexture: Result<
        unsafe extern "C" fn(
            offset: *mut usize,
            tex: *const textureReference,
            devPtr: *const ::std::os::raw::c_void,
            desc: *const hipChannelFormatDesc,
            size: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipBindTexture2D: Result<
        unsafe extern "C" fn(
            offset: *mut usize,
            tex: *const textureReference,
            devPtr: *const ::std::os::raw::c_void,
            desc: *const hipChannelFormatDesc,
            width: usize,
            height: usize,
            pitch: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipBindTextureToArray: Result<
        unsafe extern "C" fn(
            tex: *const textureReference,
            array: hipArray_const_t,
            desc: *const hipChannelFormatDesc,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGetTextureAlignmentOffset: Result<
        unsafe extern "C" fn(offset: *mut usize, texref: *const textureReference) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipUnbindTexture: Result<
        unsafe extern "C" fn(tex: *const textureReference) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetAddress: Result<
        unsafe extern "C" fn(
            dev_ptr: *mut hipDeviceptr_t,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetAddressMode: Result<
        unsafe extern "C" fn(
            pam: *mut hipTextureAddressMode,
            texRef: *const textureReference,
            dim: ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetFilterMode: Result<
        unsafe extern "C" fn(
            pfm: *mut hipTextureFilterMode,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetFlags: Result<
        unsafe extern "C" fn(
            pFlags: *mut ::std::os::raw::c_uint,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetFormat: Result<
        unsafe extern "C" fn(
            pFormat: *mut hipArray_Format,
            pNumChannels: *mut ::std::os::raw::c_int,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetMaxAnisotropy: Result<
        unsafe extern "C" fn(
            pmaxAnsio: *mut ::std::os::raw::c_int,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetMipmapFilterMode: Result<
        unsafe extern "C" fn(
            pfm: *mut hipTextureFilterMode,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetMipmapLevelBias: Result<
        unsafe extern "C" fn(pbias: *mut f32, texRef: *const textureReference) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetMipmapLevelClamp: Result<
        unsafe extern "C" fn(
            pminMipmapLevelClamp: *mut f32,
            pmaxMipmapLevelClamp: *mut f32,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefGetMipMappedArray: Result<
        unsafe extern "C" fn(
            pArray: *mut hipMipmappedArray_t,
            texRef: *const textureReference,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetAddress: Result<
        unsafe extern "C" fn(
            ByteOffset: *mut usize,
            texRef: *mut textureReference,
            dptr: hipDeviceptr_t,
            bytes: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetAddress2D: Result<
        unsafe extern "C" fn(
            texRef: *mut textureReference,
            desc: *const HIP_ARRAY_DESCRIPTOR,
            dptr: hipDeviceptr_t,
            Pitch: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetMaxAnisotropy: Result<
        unsafe extern "C" fn(
            texRef: *mut textureReference,
            maxAniso: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetBorderColor: Result<
        unsafe extern "C" fn(texRef: *mut textureReference, pBorderColor: *mut f32) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetMipmapFilterMode: Result<
        unsafe extern "C" fn(texRef: *mut textureReference, fm: hipTextureFilterMode) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetMipmapLevelBias: Result<
        unsafe extern "C" fn(texRef: *mut textureReference, bias: f32) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetMipmapLevelClamp: Result<
        unsafe extern "C" fn(
            texRef: *mut textureReference,
            minMipMapLevelClamp: f32,
            maxMipMapLevelClamp: f32,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipTexRefSetMipmappedArray: Result<
        unsafe extern "C" fn(
            texRef: *mut textureReference,
            mipmappedArray: *mut hipMipmappedArray,
            Flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMipmappedArrayCreate: Result<
        unsafe extern "C" fn(
            pHandle: *mut hipMipmappedArray_t,
            pMipmappedArrayDesc: *mut HIP_ARRAY3D_DESCRIPTOR,
            numMipmapLevels: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMipmappedArrayDestroy: Result<
        unsafe extern "C" fn(hMipmappedArray: hipMipmappedArray_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMipmappedArrayGetLevel: Result<
        unsafe extern "C" fn(
            pLevelArray: *mut hipArray_t,
            hMipMappedArray: hipMipmappedArray_t,
            level: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipApiName:
        Result<unsafe extern "C" fn(id: u32) -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub hipKernelNameRef: Result<
        unsafe extern "C" fn(f: hipFunction_t) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub hipKernelNameRefByPtr: Result<
        unsafe extern "C" fn(
            hostFunction: *const ::std::os::raw::c_void,
            stream: hipStream_t,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub hipGetStreamDeviceId: Result<
        unsafe extern "C" fn(stream: hipStream_t) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub hipStreamBeginCapture: Result<
        unsafe extern "C" fn(stream: hipStream_t, mode: hipStreamCaptureMode) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamEndCapture: Result<
        unsafe extern "C" fn(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamGetCaptureInfo: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            pCaptureStatus: *mut hipStreamCaptureStatus,
            pId: *mut ::std::os::raw::c_ulonglong,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamGetCaptureInfo_v2: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            captureStatus_out: *mut hipStreamCaptureStatus,
            id_out: *mut ::std::os::raw::c_ulonglong,
            graph_out: *mut hipGraph_t,
            dependencies_out: *mut *const hipGraphNode_t,
            numDependencies_out: *mut usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamIsCapturing: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            pCaptureStatus: *mut hipStreamCaptureStatus,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamUpdateCaptureDependencies: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            dependencies: *mut hipGraphNode_t,
            numDependencies: usize,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipThreadExchangeStreamCaptureMode: Result<
        unsafe extern "C" fn(mode: *mut hipStreamCaptureMode) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphCreate: Result<
        unsafe extern "C" fn(pGraph: *mut hipGraph_t, flags: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphDestroy:
        Result<unsafe extern "C" fn(graph: hipGraph_t) -> hipError_t, ::libloading::Error>,
    pub hipGraphAddDependencies: Result<
        unsafe extern "C" fn(
            graph: hipGraph_t,
            from: *const hipGraphNode_t,
            to: *const hipGraphNode_t,
            numDependencies: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphRemoveDependencies: Result<
        unsafe extern "C" fn(
            graph: hipGraph_t,
            from: *const hipGraphNode_t,
            to: *const hipGraphNode_t,
            numDependencies: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphGetEdges: Result<
        unsafe extern "C" fn(
            graph: hipGraph_t,
            from: *mut hipGraphNode_t,
            to: *mut hipGraphNode_t,
            numEdges: *mut usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphGetNodes: Result<
        unsafe extern "C" fn(
            graph: hipGraph_t,
            nodes: *mut hipGraphNode_t,
            numNodes: *mut usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphGetRootNodes: Result<
        unsafe extern "C" fn(
            graph: hipGraph_t,
            pRootNodes: *mut hipGraphNode_t,
            pNumRootNodes: *mut usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphNodeGetDependencies: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pDependencies: *mut hipGraphNode_t,
            pNumDependencies: *mut usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphNodeGetDependentNodes: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pDependentNodes: *mut hipGraphNode_t,
            pNumDependentNodes: *mut usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphNodeGetType: Result<
        unsafe extern "C" fn(node: hipGraphNode_t, pType: *mut hipGraphNodeType) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphDestroyNode:
        Result<unsafe extern "C" fn(node: hipGraphNode_t) -> hipError_t, ::libloading::Error>,
    pub hipGraphClone: Result<
        unsafe extern "C" fn(pGraphClone: *mut hipGraph_t, originalGraph: hipGraph_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphNodeFindInClone: Result<
        unsafe extern "C" fn(
            pNode: *mut hipGraphNode_t,
            originalNode: hipGraphNode_t,
            clonedGraph: hipGraph_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphInstantiate: Result<
        unsafe extern "C" fn(
            pGraphExec: *mut hipGraphExec_t,
            graph: hipGraph_t,
            pErrorNode: *mut hipGraphNode_t,
            pLogBuffer: *mut ::std::os::raw::c_char,
            bufferSize: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphInstantiateWithFlags: Result<
        unsafe extern "C" fn(
            pGraphExec: *mut hipGraphExec_t,
            graph: hipGraph_t,
            flags: ::std::os::raw::c_ulonglong,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphLaunch: Result<
        unsafe extern "C" fn(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphUpload: Result<
        unsafe extern "C" fn(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecDestroy:
        Result<unsafe extern "C" fn(graphExec: hipGraphExec_t) -> hipError_t, ::libloading::Error>,
    pub hipGraphExecUpdate: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            hGraph: hipGraph_t,
            hErrorNode_out: *mut hipGraphNode_t,
            updateResult_out: *mut hipGraphExecUpdateResult,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddKernelNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            pNodeParams: *const hipKernelNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphKernelNodeGetParams: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pNodeParams: *mut hipKernelNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphKernelNodeSetParams: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pNodeParams: *const hipKernelNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecKernelNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            pNodeParams: *const hipKernelNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddMemcpyNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            pCopyParams: *const hipMemcpy3DParms,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphMemcpyNodeGetParams: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pNodeParams: *mut hipMemcpy3DParms,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphMemcpyNodeSetParams: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pNodeParams: *const hipMemcpy3DParms,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphKernelNodeSetAttribute: Result<
        unsafe extern "C" fn(
            hNode: hipGraphNode_t,
            attr: hipKernelNodeAttrID,
            value: *const hipKernelNodeAttrValue,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphKernelNodeGetAttribute: Result<
        unsafe extern "C" fn(
            hNode: hipGraphNode_t,
            attr: hipKernelNodeAttrID,
            value: *mut hipKernelNodeAttrValue,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecMemcpyNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            pNodeParams: *mut hipMemcpy3DParms,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddMemcpyNode1D: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            count: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphMemcpyNodeSetParams1D: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            count: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecMemcpyNodeSetParams1D: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            count: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddMemcpyNodeFromSymbol: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            dst: *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
            count: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphMemcpyNodeSetParamsFromSymbol: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            dst: *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
            count: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecMemcpyNodeSetParamsFromSymbol: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            dst: *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
            count: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddMemcpyNodeToSymbol: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            symbol: *const ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            count: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphMemcpyNodeSetParamsToSymbol: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            symbol: *const ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            count: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecMemcpyNodeSetParamsToSymbol: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            symbol: *const ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            count: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddMemsetNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            pMemsetParams: *const hipMemsetParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphMemsetNodeGetParams: Result<
        unsafe extern "C" fn(node: hipGraphNode_t, pNodeParams: *mut hipMemsetParams) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphMemsetNodeSetParams: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pNodeParams: *const hipMemsetParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecMemsetNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            pNodeParams: *const hipMemsetParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddHostNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            pNodeParams: *const hipHostNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphHostNodeGetParams: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pNodeParams: *mut hipHostNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphHostNodeSetParams: Result<
        unsafe extern "C" fn(
            node: hipGraphNode_t,
            pNodeParams: *const hipHostNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecHostNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            pNodeParams: *const hipHostNodeParams,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddChildGraphNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            childGraph: hipGraph_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphChildGraphNodeGetGraph: Result<
        unsafe extern "C" fn(node: hipGraphNode_t, pGraph: *mut hipGraph_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecChildGraphNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            node: hipGraphNode_t,
            childGraph: hipGraph_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddEmptyNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddEventRecordNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            event: hipEvent_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphEventRecordNodeGetEvent: Result<
        unsafe extern "C" fn(node: hipGraphNode_t, event_out: *mut hipEvent_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphEventRecordNodeSetEvent: Result<
        unsafe extern "C" fn(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecEventRecordNodeSetEvent: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            hNode: hipGraphNode_t,
            event: hipEvent_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphAddEventWaitNode: Result<
        unsafe extern "C" fn(
            pGraphNode: *mut hipGraphNode_t,
            graph: hipGraph_t,
            pDependencies: *const hipGraphNode_t,
            numDependencies: usize,
            event: hipEvent_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphEventWaitNodeGetEvent: Result<
        unsafe extern "C" fn(node: hipGraphNode_t, event_out: *mut hipEvent_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphEventWaitNodeSetEvent: Result<
        unsafe extern "C" fn(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphExecEventWaitNodeSetEvent: Result<
        unsafe extern "C" fn(
            hGraphExec: hipGraphExec_t,
            hNode: hipGraphNode_t,
            event: hipEvent_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGetGraphMemAttribute: Result<
        unsafe extern "C" fn(
            device: ::std::os::raw::c_int,
            attr: hipGraphMemAttributeType,
            value: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceSetGraphMemAttribute: Result<
        unsafe extern "C" fn(
            device: ::std::os::raw::c_int,
            attr: hipGraphMemAttributeType,
            value: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipDeviceGraphMemTrim: Result<
        unsafe extern "C" fn(device: ::std::os::raw::c_int) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipUserObjectCreate: Result<
        unsafe extern "C" fn(
            object_out: *mut hipUserObject_t,
            ptr: *mut ::std::os::raw::c_void,
            destroy: hipHostFn_t,
            initialRefcount: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipUserObjectRelease: Result<
        unsafe extern "C" fn(object: hipUserObject_t, count: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipUserObjectRetain: Result<
        unsafe extern "C" fn(object: hipUserObject_t, count: ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphRetainUserObject: Result<
        unsafe extern "C" fn(
            graph: hipGraph_t,
            object: hipUserObject_t,
            count: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphReleaseUserObject: Result<
        unsafe extern "C" fn(
            graph: hipGraph_t,
            object: hipUserObject_t,
            count: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemAddressFree: Result<
        unsafe extern "C" fn(devPtr: *mut ::std::os::raw::c_void, size: usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemAddressReserve: Result<
        unsafe extern "C" fn(
            ptr: *mut *mut ::std::os::raw::c_void,
            size: usize,
            alignment: usize,
            addr: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_ulonglong,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemCreate: Result<
        unsafe extern "C" fn(
            handle: *mut hipMemGenericAllocationHandle_t,
            size: usize,
            prop: *const hipMemAllocationProp,
            flags: ::std::os::raw::c_ulonglong,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemExportToShareableHandle: Result<
        unsafe extern "C" fn(
            shareableHandle: *mut ::std::os::raw::c_void,
            handle: hipMemGenericAllocationHandle_t,
            handleType: hipMemAllocationHandleType,
            flags: ::std::os::raw::c_ulonglong,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemGetAccess: Result<
        unsafe extern "C" fn(
            flags: *mut ::std::os::raw::c_ulonglong,
            location: *const hipMemLocation,
            ptr: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemGetAllocationGranularity: Result<
        unsafe extern "C" fn(
            granularity: *mut usize,
            prop: *const hipMemAllocationProp,
            option: hipMemAllocationGranularity_flags,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemGetAllocationPropertiesFromHandle: Result<
        unsafe extern "C" fn(
            prop: *mut hipMemAllocationProp,
            handle: hipMemGenericAllocationHandle_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemImportFromShareableHandle: Result<
        unsafe extern "C" fn(
            handle: *mut hipMemGenericAllocationHandle_t,
            osHandle: *mut ::std::os::raw::c_void,
            shHandleType: hipMemAllocationHandleType,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemMap: Result<
        unsafe extern "C" fn(
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
            offset: usize,
            handle: hipMemGenericAllocationHandle_t,
            flags: ::std::os::raw::c_ulonglong,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemMapArrayAsync: Result<
        unsafe extern "C" fn(
            mapInfoList: *mut hipArrayMapInfo,
            count: ::std::os::raw::c_uint,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemRelease: Result<
        unsafe extern "C" fn(handle: hipMemGenericAllocationHandle_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemRetainAllocationHandle: Result<
        unsafe extern "C" fn(
            handle: *mut hipMemGenericAllocationHandle_t,
            addr: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemSetAccess: Result<
        unsafe extern "C" fn(
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
            desc: *const hipMemAccessDesc,
            count: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemUnmap: Result<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, size: usize) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGLGetDevices: Result<
        unsafe extern "C" fn(
            pHipDeviceCount: *mut ::std::os::raw::c_uint,
            pHipDevices: *mut ::std::os::raw::c_int,
            hipDeviceCount: ::std::os::raw::c_uint,
            deviceList: hipGLDeviceList,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphicsGLRegisterBuffer: Result<
        unsafe extern "C" fn(
            resource: *mut *mut hipGraphicsResource,
            buffer: GLuint,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphicsGLRegisterImage: Result<
        unsafe extern "C" fn(
            resource: *mut *mut hipGraphicsResource,
            image: GLuint,
            target: GLenum,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphicsMapResources: Result<
        unsafe extern "C" fn(
            count: ::std::os::raw::c_int,
            resources: *mut hipGraphicsResource_t,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphicsSubResourceGetMappedArray: Result<
        unsafe extern "C" fn(
            array: *mut hipArray_t,
            resource: hipGraphicsResource_t,
            arrayIndex: ::std::os::raw::c_uint,
            mipLevel: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphicsResourceGetMappedPointer: Result<
        unsafe extern "C" fn(
            devPtr: *mut *mut ::std::os::raw::c_void,
            size: *mut usize,
            resource: hipGraphicsResource_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphicsUnmapResources: Result<
        unsafe extern "C" fn(
            count: ::std::os::raw::c_int,
            resources: *mut hipGraphicsResource_t,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphicsUnregisterResource: Result<
        unsafe extern "C" fn(resource: hipGraphicsResource_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyToSymbol_spt: Result<
        unsafe extern "C" fn(
            symbol: *const ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyFromSymbol_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2D_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DFromArray_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: hipArray_const_t,
            wOffset: usize,
            hOffset: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy3D_spt:
        Result<unsafe extern "C" fn(p: *const hipMemcpy3DParms) -> hipError_t, ::libloading::Error>,
    pub hipMemset_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            value: ::std::os::raw::c_int,
            sizeBytes: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemsetAsync_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            value: ::std::os::raw::c_int,
            sizeBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset2D_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            pitch: usize,
            value: ::std::os::raw::c_int,
            width: usize,
            height: usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset2DAsync_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            pitch: usize,
            value: ::std::os::raw::c_int,
            width: usize,
            height: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset3DAsync_spt: Result<
        unsafe extern "C" fn(
            pitchedDevPtr: hipPitchedPtr,
            value: ::std::os::raw::c_int,
            extent: hipExtent,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemset3D_spt: Result<
        unsafe extern "C" fn(
            pitchedDevPtr: hipPitchedPtr,
            value: ::std::os::raw::c_int,
            extent: hipExtent,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyAsync_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy3DAsync_spt: Result<
        unsafe extern "C" fn(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DAsync_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyFromSymbolAsync_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            symbol: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyToSymbolAsync_spt: Result<
        unsafe extern "C" fn(
            symbol: *const ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            offset: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpyFromArray_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            src: hipArray_const_t,
            wOffsetSrc: usize,
            hOffset: usize,
            count: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DToArray_spt: Result<
        unsafe extern "C" fn(
            dst: *mut hipArray,
            wOffset: usize,
            hOffset: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DFromArrayAsync_spt: Result<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            dpitch: usize,
            src: hipArray_const_t,
            wOffsetSrc: usize,
            hOffsetSrc: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipMemcpy2DToArrayAsync_spt: Result<
        unsafe extern "C" fn(
            dst: *mut hipArray,
            wOffset: usize,
            hOffset: usize,
            src: *const ::std::os::raw::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: hipMemcpyKind,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamQuery_spt:
        Result<unsafe extern "C" fn(stream: hipStream_t) -> hipError_t, ::libloading::Error>,
    pub hipStreamSynchronize_spt:
        Result<unsafe extern "C" fn(stream: hipStream_t) -> hipError_t, ::libloading::Error>,
    pub hipStreamGetPriority_spt: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            priority: *mut ::std::os::raw::c_int,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamWaitEvent_spt: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            event: hipEvent_t,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamGetFlags_spt: Result<
        unsafe extern "C" fn(stream: hipStream_t, flags: *mut ::std::os::raw::c_uint) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamAddCallback_spt: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            callback: hipStreamCallback_t,
            userData: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_uint,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipEventRecord_spt: Result<
        unsafe extern "C" fn(event: hipEvent_t, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchCooperativeKernel_spt: Result<
        unsafe extern "C" fn(
            f: *const ::std::os::raw::c_void,
            gridDim: dim3,
            blockDim: dim3,
            kernelParams: *mut *mut ::std::os::raw::c_void,
            sharedMemBytes: u32,
            hStream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchKernel_spt: Result<
        unsafe extern "C" fn(
            function_address: *const ::std::os::raw::c_void,
            numBlocks: dim3,
            dimBlocks: dim3,
            args: *mut *mut ::std::os::raw::c_void,
            sharedMemBytes: usize,
            stream: hipStream_t,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipGraphLaunch_spt: Result<
        unsafe extern "C" fn(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamBeginCapture_spt: Result<
        unsafe extern "C" fn(stream: hipStream_t, mode: hipStreamCaptureMode) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamEndCapture_spt: Result<
        unsafe extern "C" fn(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamIsCapturing_spt: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            pCaptureStatus: *mut hipStreamCaptureStatus,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamGetCaptureInfo_spt: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            pCaptureStatus: *mut hipStreamCaptureStatus,
            pId: *mut ::std::os::raw::c_ulonglong,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipStreamGetCaptureInfo_v2_spt: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            captureStatus_out: *mut hipStreamCaptureStatus,
            id_out: *mut ::std::os::raw::c_ulonglong,
            graph_out: *mut hipGraph_t,
            dependencies_out: *mut *const hipGraphNode_t,
            numDependencies_out: *mut usize,
        ) -> hipError_t,
        ::libloading::Error,
    >,
    pub hipLaunchHostFunc_spt: Result<
        unsafe extern "C" fn(
            stream: hipStream_t,
            fn_: hipHostFn_t,
            userData: *mut ::std::os::raw::c_void,
        ) -> hipError_t,
        ::libloading::Error,
    >,
}
impl hip {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let hipCreateChannelDesc = __library.get(b"hipCreateChannelDesc\0").map(|sym| *sym);
        let hipInit = __library.get(b"hipInit\0").map(|sym| *sym);
        let hipDriverGetVersion = __library.get(b"hipDriverGetVersion\0").map(|sym| *sym);
        let hipRuntimeGetVersion = __library.get(b"hipRuntimeGetVersion\0").map(|sym| *sym);
        let hipDeviceGet = __library.get(b"hipDeviceGet\0").map(|sym| *sym);
        let hipDeviceComputeCapability = __library
            .get(b"hipDeviceComputeCapability\0")
            .map(|sym| *sym);
        let hipDeviceGetName = __library.get(b"hipDeviceGetName\0").map(|sym| *sym);
        let hipDeviceGetUuid = __library.get(b"hipDeviceGetUuid\0").map(|sym| *sym);
        let hipDeviceGetP2PAttribute = __library.get(b"hipDeviceGetP2PAttribute\0").map(|sym| *sym);
        let hipDeviceGetPCIBusId = __library.get(b"hipDeviceGetPCIBusId\0").map(|sym| *sym);
        let hipDeviceGetByPCIBusId = __library.get(b"hipDeviceGetByPCIBusId\0").map(|sym| *sym);
        let hipDeviceTotalMem = __library.get(b"hipDeviceTotalMem\0").map(|sym| *sym);
        let hipDeviceSynchronize = __library.get(b"hipDeviceSynchronize\0").map(|sym| *sym);
        let hipDeviceReset = __library.get(b"hipDeviceReset\0").map(|sym| *sym);
        let hipSetDevice = __library.get(b"hipSetDevice\0").map(|sym| *sym);
        let hipGetDevice = __library.get(b"hipGetDevice\0").map(|sym| *sym);
        let hipGetDeviceCount = __library.get(b"hipGetDeviceCount\0").map(|sym| *sym);
        let hipDeviceGetAttribute = __library.get(b"hipDeviceGetAttribute\0").map(|sym| *sym);
        let hipDeviceGetDefaultMemPool = __library
            .get(b"hipDeviceGetDefaultMemPool\0")
            .map(|sym| *sym);
        let hipDeviceSetMemPool = __library.get(b"hipDeviceSetMemPool\0").map(|sym| *sym);
        let hipDeviceGetMemPool = __library.get(b"hipDeviceGetMemPool\0").map(|sym| *sym);
        let hipGetDeviceProperties = __library.get(b"hipGetDeviceProperties\0").map(|sym| *sym);
        let hipDeviceSetCacheConfig = __library.get(b"hipDeviceSetCacheConfig\0").map(|sym| *sym);
        let hipDeviceGetCacheConfig = __library.get(b"hipDeviceGetCacheConfig\0").map(|sym| *sym);
        let hipDeviceGetLimit = __library.get(b"hipDeviceGetLimit\0").map(|sym| *sym);
        let hipDeviceSetLimit = __library.get(b"hipDeviceSetLimit\0").map(|sym| *sym);
        let hipDeviceGetSharedMemConfig = __library
            .get(b"hipDeviceGetSharedMemConfig\0")
            .map(|sym| *sym);
        let hipGetDeviceFlags = __library.get(b"hipGetDeviceFlags\0").map(|sym| *sym);
        let hipDeviceSetSharedMemConfig = __library
            .get(b"hipDeviceSetSharedMemConfig\0")
            .map(|sym| *sym);
        let hipSetDeviceFlags = __library.get(b"hipSetDeviceFlags\0").map(|sym| *sym);
        let hipChooseDevice = __library.get(b"hipChooseDevice\0").map(|sym| *sym);
        let hipExtGetLinkTypeAndHopCount = __library
            .get(b"hipExtGetLinkTypeAndHopCount\0")
            .map(|sym| *sym);
        let hipIpcGetMemHandle = __library.get(b"hipIpcGetMemHandle\0").map(|sym| *sym);
        let hipIpcOpenMemHandle = __library.get(b"hipIpcOpenMemHandle\0").map(|sym| *sym);
        let hipIpcCloseMemHandle = __library.get(b"hipIpcCloseMemHandle\0").map(|sym| *sym);
        let hipIpcGetEventHandle = __library.get(b"hipIpcGetEventHandle\0").map(|sym| *sym);
        let hipIpcOpenEventHandle = __library.get(b"hipIpcOpenEventHandle\0").map(|sym| *sym);
        let hipFuncSetAttribute = __library.get(b"hipFuncSetAttribute\0").map(|sym| *sym);
        let hipFuncSetCacheConfig = __library.get(b"hipFuncSetCacheConfig\0").map(|sym| *sym);
        let hipFuncSetSharedMemConfig = __library
            .get(b"hipFuncSetSharedMemConfig\0")
            .map(|sym| *sym);
        let hipGetLastError = __library.get(b"hipGetLastError\0").map(|sym| *sym);
        let hipPeekAtLastError = __library.get(b"hipPeekAtLastError\0").map(|sym| *sym);
        let hipGetErrorName = __library.get(b"hipGetErrorName\0").map(|sym| *sym);
        let hipGetErrorString = __library.get(b"hipGetErrorString\0").map(|sym| *sym);
        let hipDrvGetErrorName = __library.get(b"hipDrvGetErrorName\0").map(|sym| *sym);
        let hipDrvGetErrorString = __library.get(b"hipDrvGetErrorString\0").map(|sym| *sym);
        let hipStreamCreate = __library.get(b"hipStreamCreate\0").map(|sym| *sym);
        let hipStreamCreateWithFlags = __library.get(b"hipStreamCreateWithFlags\0").map(|sym| *sym);
        let hipStreamCreateWithPriority = __library
            .get(b"hipStreamCreateWithPriority\0")
            .map(|sym| *sym);
        let hipDeviceGetStreamPriorityRange = __library
            .get(b"hipDeviceGetStreamPriorityRange\0")
            .map(|sym| *sym);
        let hipStreamDestroy = __library.get(b"hipStreamDestroy\0").map(|sym| *sym);
        let hipStreamQuery = __library.get(b"hipStreamQuery\0").map(|sym| *sym);
        let hipStreamSynchronize = __library.get(b"hipStreamSynchronize\0").map(|sym| *sym);
        let hipStreamWaitEvent = __library.get(b"hipStreamWaitEvent\0").map(|sym| *sym);
        let hipStreamGetFlags = __library.get(b"hipStreamGetFlags\0").map(|sym| *sym);
        let hipStreamGetPriority = __library.get(b"hipStreamGetPriority\0").map(|sym| *sym);
        let hipExtStreamCreateWithCUMask = __library
            .get(b"hipExtStreamCreateWithCUMask\0")
            .map(|sym| *sym);
        let hipExtStreamGetCUMask = __library.get(b"hipExtStreamGetCUMask\0").map(|sym| *sym);
        let hipStreamAddCallback = __library.get(b"hipStreamAddCallback\0").map(|sym| *sym);
        let hipStreamWaitValue32 = __library.get(b"hipStreamWaitValue32\0").map(|sym| *sym);
        let hipStreamWaitValue64 = __library.get(b"hipStreamWaitValue64\0").map(|sym| *sym);
        let hipStreamWriteValue32 = __library.get(b"hipStreamWriteValue32\0").map(|sym| *sym);
        let hipStreamWriteValue64 = __library.get(b"hipStreamWriteValue64\0").map(|sym| *sym);
        let hipEventCreateWithFlags = __library.get(b"hipEventCreateWithFlags\0").map(|sym| *sym);
        let hipEventCreate = __library.get(b"hipEventCreate\0").map(|sym| *sym);
        let hipEventRecord = __library.get(b"hipEventRecord\0").map(|sym| *sym);
        let hipEventDestroy = __library.get(b"hipEventDestroy\0").map(|sym| *sym);
        let hipEventSynchronize = __library.get(b"hipEventSynchronize\0").map(|sym| *sym);
        let hipEventElapsedTime = __library.get(b"hipEventElapsedTime\0").map(|sym| *sym);
        let hipEventQuery = __library.get(b"hipEventQuery\0").map(|sym| *sym);
        let hipPointerGetAttributes = __library.get(b"hipPointerGetAttributes\0").map(|sym| *sym);
        let hipPointerGetAttribute = __library.get(b"hipPointerGetAttribute\0").map(|sym| *sym);
        let hipDrvPointerGetAttributes = __library
            .get(b"hipDrvPointerGetAttributes\0")
            .map(|sym| *sym);
        let hipImportExternalSemaphore = __library
            .get(b"hipImportExternalSemaphore\0")
            .map(|sym| *sym);
        let hipSignalExternalSemaphoresAsync = __library
            .get(b"hipSignalExternalSemaphoresAsync\0")
            .map(|sym| *sym);
        let hipWaitExternalSemaphoresAsync = __library
            .get(b"hipWaitExternalSemaphoresAsync\0")
            .map(|sym| *sym);
        let hipDestroyExternalSemaphore = __library
            .get(b"hipDestroyExternalSemaphore\0")
            .map(|sym| *sym);
        let hipImportExternalMemory = __library.get(b"hipImportExternalMemory\0").map(|sym| *sym);
        let hipExternalMemoryGetMappedBuffer = __library
            .get(b"hipExternalMemoryGetMappedBuffer\0")
            .map(|sym| *sym);
        let hipDestroyExternalMemory = __library.get(b"hipDestroyExternalMemory\0").map(|sym| *sym);
        let hipMalloc = __library.get(b"hipMalloc\0").map(|sym| *sym);
        let hipExtMallocWithFlags = __library.get(b"hipExtMallocWithFlags\0").map(|sym| *sym);
        let hipMallocHost = __library.get(b"hipMallocHost\0").map(|sym| *sym);
        let hipMemAllocHost = __library.get(b"hipMemAllocHost\0").map(|sym| *sym);
        let hipHostMalloc = __library.get(b"hipHostMalloc\0").map(|sym| *sym);
        let hipMallocManaged = __library.get(b"hipMallocManaged\0").map(|sym| *sym);
        let hipMemPrefetchAsync = __library.get(b"hipMemPrefetchAsync\0").map(|sym| *sym);
        let hipMemAdvise = __library.get(b"hipMemAdvise\0").map(|sym| *sym);
        let hipMemRangeGetAttribute = __library.get(b"hipMemRangeGetAttribute\0").map(|sym| *sym);
        let hipMemRangeGetAttributes = __library.get(b"hipMemRangeGetAttributes\0").map(|sym| *sym);
        let hipStreamAttachMemAsync = __library.get(b"hipStreamAttachMemAsync\0").map(|sym| *sym);
        let hipMallocAsync = __library.get(b"hipMallocAsync\0").map(|sym| *sym);
        let hipFreeAsync = __library.get(b"hipFreeAsync\0").map(|sym| *sym);
        let hipMemPoolTrimTo = __library.get(b"hipMemPoolTrimTo\0").map(|sym| *sym);
        let hipMemPoolSetAttribute = __library.get(b"hipMemPoolSetAttribute\0").map(|sym| *sym);
        let hipMemPoolGetAttribute = __library.get(b"hipMemPoolGetAttribute\0").map(|sym| *sym);
        let hipMemPoolSetAccess = __library.get(b"hipMemPoolSetAccess\0").map(|sym| *sym);
        let hipMemPoolGetAccess = __library.get(b"hipMemPoolGetAccess\0").map(|sym| *sym);
        let hipMemPoolCreate = __library.get(b"hipMemPoolCreate\0").map(|sym| *sym);
        let hipMemPoolDestroy = __library.get(b"hipMemPoolDestroy\0").map(|sym| *sym);
        let hipMallocFromPoolAsync = __library.get(b"hipMallocFromPoolAsync\0").map(|sym| *sym);
        let hipMemPoolExportToShareableHandle = __library
            .get(b"hipMemPoolExportToShareableHandle\0")
            .map(|sym| *sym);
        let hipMemPoolImportFromShareableHandle = __library
            .get(b"hipMemPoolImportFromShareableHandle\0")
            .map(|sym| *sym);
        let hipMemPoolExportPointer = __library.get(b"hipMemPoolExportPointer\0").map(|sym| *sym);
        let hipMemPoolImportPointer = __library.get(b"hipMemPoolImportPointer\0").map(|sym| *sym);
        let hipHostAlloc = __library.get(b"hipHostAlloc\0").map(|sym| *sym);
        let hipHostGetDevicePointer = __library.get(b"hipHostGetDevicePointer\0").map(|sym| *sym);
        let hipHostGetFlags = __library.get(b"hipHostGetFlags\0").map(|sym| *sym);
        let hipHostRegister = __library.get(b"hipHostRegister\0").map(|sym| *sym);
        let hipHostUnregister = __library.get(b"hipHostUnregister\0").map(|sym| *sym);
        let hipMallocPitch = __library.get(b"hipMallocPitch\0").map(|sym| *sym);
        let hipMemAllocPitch = __library.get(b"hipMemAllocPitch\0").map(|sym| *sym);
        let hipFree = __library.get(b"hipFree\0").map(|sym| *sym);
        let hipFreeHost = __library.get(b"hipFreeHost\0").map(|sym| *sym);
        let hipHostFree = __library.get(b"hipHostFree\0").map(|sym| *sym);
        let hipMemcpy = __library.get(b"hipMemcpy\0").map(|sym| *sym);
        let hipMemcpyWithStream = __library.get(b"hipMemcpyWithStream\0").map(|sym| *sym);
        let hipMemcpyHtoD = __library.get(b"hipMemcpyHtoD\0").map(|sym| *sym);
        let hipMemcpyDtoH = __library.get(b"hipMemcpyDtoH\0").map(|sym| *sym);
        let hipMemcpyDtoD = __library.get(b"hipMemcpyDtoD\0").map(|sym| *sym);
        let hipMemcpyHtoDAsync = __library.get(b"hipMemcpyHtoDAsync\0").map(|sym| *sym);
        let hipMemcpyDtoHAsync = __library.get(b"hipMemcpyDtoHAsync\0").map(|sym| *sym);
        let hipMemcpyDtoDAsync = __library.get(b"hipMemcpyDtoDAsync\0").map(|sym| *sym);
        let hipModuleGetGlobal = __library.get(b"hipModuleGetGlobal\0").map(|sym| *sym);
        let hipGetSymbolAddress = __library.get(b"hipGetSymbolAddress\0").map(|sym| *sym);
        let hipGetSymbolSize = __library.get(b"hipGetSymbolSize\0").map(|sym| *sym);
        let hipMemcpyToSymbol = __library.get(b"hipMemcpyToSymbol\0").map(|sym| *sym);
        let hipMemcpyToSymbolAsync = __library.get(b"hipMemcpyToSymbolAsync\0").map(|sym| *sym);
        let hipMemcpyFromSymbol = __library.get(b"hipMemcpyFromSymbol\0").map(|sym| *sym);
        let hipMemcpyFromSymbolAsync = __library.get(b"hipMemcpyFromSymbolAsync\0").map(|sym| *sym);
        let hipMemcpyAsync = __library.get(b"hipMemcpyAsync\0").map(|sym| *sym);
        let hipMemset = __library.get(b"hipMemset\0").map(|sym| *sym);
        let hipMemsetD8 = __library.get(b"hipMemsetD8\0").map(|sym| *sym);
        let hipMemsetD8Async = __library.get(b"hipMemsetD8Async\0").map(|sym| *sym);
        let hipMemsetD16 = __library.get(b"hipMemsetD16\0").map(|sym| *sym);
        let hipMemsetD16Async = __library.get(b"hipMemsetD16Async\0").map(|sym| *sym);
        let hipMemsetD32 = __library.get(b"hipMemsetD32\0").map(|sym| *sym);
        let hipMemsetAsync = __library.get(b"hipMemsetAsync\0").map(|sym| *sym);
        let hipMemsetD32Async = __library.get(b"hipMemsetD32Async\0").map(|sym| *sym);
        let hipMemset2D = __library.get(b"hipMemset2D\0").map(|sym| *sym);
        let hipMemset2DAsync = __library.get(b"hipMemset2DAsync\0").map(|sym| *sym);
        let hipMemset3D = __library.get(b"hipMemset3D\0").map(|sym| *sym);
        let hipMemset3DAsync = __library.get(b"hipMemset3DAsync\0").map(|sym| *sym);
        let hipMemGetInfo = __library.get(b"hipMemGetInfo\0").map(|sym| *sym);
        let hipMemPtrGetInfo = __library.get(b"hipMemPtrGetInfo\0").map(|sym| *sym);
        let hipMallocArray = __library.get(b"hipMallocArray\0").map(|sym| *sym);
        let hipArrayCreate = __library.get(b"hipArrayCreate\0").map(|sym| *sym);
        let hipArrayDestroy = __library.get(b"hipArrayDestroy\0").map(|sym| *sym);
        let hipArray3DCreate = __library.get(b"hipArray3DCreate\0").map(|sym| *sym);
        let hipMalloc3D = __library.get(b"hipMalloc3D\0").map(|sym| *sym);
        let hipFreeArray = __library.get(b"hipFreeArray\0").map(|sym| *sym);
        let hipFreeMipmappedArray = __library.get(b"hipFreeMipmappedArray\0").map(|sym| *sym);
        let hipMalloc3DArray = __library.get(b"hipMalloc3DArray\0").map(|sym| *sym);
        let hipMallocMipmappedArray = __library.get(b"hipMallocMipmappedArray\0").map(|sym| *sym);
        let hipGetMipmappedArrayLevel = __library
            .get(b"hipGetMipmappedArrayLevel\0")
            .map(|sym| *sym);
        let hipMemcpy2D = __library.get(b"hipMemcpy2D\0").map(|sym| *sym);
        let hipMemcpyParam2D = __library.get(b"hipMemcpyParam2D\0").map(|sym| *sym);
        let hipMemcpyParam2DAsync = __library.get(b"hipMemcpyParam2DAsync\0").map(|sym| *sym);
        let hipMemcpy2DAsync = __library.get(b"hipMemcpy2DAsync\0").map(|sym| *sym);
        let hipMemcpy2DToArray = __library.get(b"hipMemcpy2DToArray\0").map(|sym| *sym);
        let hipMemcpy2DToArrayAsync = __library.get(b"hipMemcpy2DToArrayAsync\0").map(|sym| *sym);
        let hipMemcpyToArray = __library.get(b"hipMemcpyToArray\0").map(|sym| *sym);
        let hipMemcpyFromArray = __library.get(b"hipMemcpyFromArray\0").map(|sym| *sym);
        let hipMemcpy2DFromArray = __library.get(b"hipMemcpy2DFromArray\0").map(|sym| *sym);
        let hipMemcpy2DFromArrayAsync = __library
            .get(b"hipMemcpy2DFromArrayAsync\0")
            .map(|sym| *sym);
        let hipMemcpyAtoH = __library.get(b"hipMemcpyAtoH\0").map(|sym| *sym);
        let hipMemcpyHtoA = __library.get(b"hipMemcpyHtoA\0").map(|sym| *sym);
        let hipMemcpy3D = __library.get(b"hipMemcpy3D\0").map(|sym| *sym);
        let hipMemcpy3DAsync = __library.get(b"hipMemcpy3DAsync\0").map(|sym| *sym);
        let hipDrvMemcpy3D = __library.get(b"hipDrvMemcpy3D\0").map(|sym| *sym);
        let hipDrvMemcpy3DAsync = __library.get(b"hipDrvMemcpy3DAsync\0").map(|sym| *sym);
        let hipDeviceCanAccessPeer = __library.get(b"hipDeviceCanAccessPeer\0").map(|sym| *sym);
        let hipDeviceEnablePeerAccess = __library
            .get(b"hipDeviceEnablePeerAccess\0")
            .map(|sym| *sym);
        let hipDeviceDisablePeerAccess = __library
            .get(b"hipDeviceDisablePeerAccess\0")
            .map(|sym| *sym);
        let hipMemGetAddressRange = __library.get(b"hipMemGetAddressRange\0").map(|sym| *sym);
        let hipMemcpyPeer = __library.get(b"hipMemcpyPeer\0").map(|sym| *sym);
        let hipMemcpyPeerAsync = __library.get(b"hipMemcpyPeerAsync\0").map(|sym| *sym);
        let hipCtxCreate = __library.get(b"hipCtxCreate\0").map(|sym| *sym);
        let hipCtxDestroy = __library.get(b"hipCtxDestroy\0").map(|sym| *sym);
        let hipCtxPopCurrent = __library.get(b"hipCtxPopCurrent\0").map(|sym| *sym);
        let hipCtxPushCurrent = __library.get(b"hipCtxPushCurrent\0").map(|sym| *sym);
        let hipCtxSetCurrent = __library.get(b"hipCtxSetCurrent\0").map(|sym| *sym);
        let hipCtxGetCurrent = __library.get(b"hipCtxGetCurrent\0").map(|sym| *sym);
        let hipCtxGetDevice = __library.get(b"hipCtxGetDevice\0").map(|sym| *sym);
        let hipCtxGetApiVersion = __library.get(b"hipCtxGetApiVersion\0").map(|sym| *sym);
        let hipCtxGetCacheConfig = __library.get(b"hipCtxGetCacheConfig\0").map(|sym| *sym);
        let hipCtxSetCacheConfig = __library.get(b"hipCtxSetCacheConfig\0").map(|sym| *sym);
        let hipCtxSetSharedMemConfig = __library.get(b"hipCtxSetSharedMemConfig\0").map(|sym| *sym);
        let hipCtxGetSharedMemConfig = __library.get(b"hipCtxGetSharedMemConfig\0").map(|sym| *sym);
        let hipCtxSynchronize = __library.get(b"hipCtxSynchronize\0").map(|sym| *sym);
        let hipCtxGetFlags = __library.get(b"hipCtxGetFlags\0").map(|sym| *sym);
        let hipCtxEnablePeerAccess = __library.get(b"hipCtxEnablePeerAccess\0").map(|sym| *sym);
        let hipCtxDisablePeerAccess = __library.get(b"hipCtxDisablePeerAccess\0").map(|sym| *sym);
        let hipDevicePrimaryCtxGetState = __library
            .get(b"hipDevicePrimaryCtxGetState\0")
            .map(|sym| *sym);
        let hipDevicePrimaryCtxRelease = __library
            .get(b"hipDevicePrimaryCtxRelease\0")
            .map(|sym| *sym);
        let hipDevicePrimaryCtxRetain = __library
            .get(b"hipDevicePrimaryCtxRetain\0")
            .map(|sym| *sym);
        let hipDevicePrimaryCtxReset = __library.get(b"hipDevicePrimaryCtxReset\0").map(|sym| *sym);
        let hipDevicePrimaryCtxSetFlags = __library
            .get(b"hipDevicePrimaryCtxSetFlags\0")
            .map(|sym| *sym);
        let hipModuleLoad = __library.get(b"hipModuleLoad\0").map(|sym| *sym);
        let hipModuleUnload = __library.get(b"hipModuleUnload\0").map(|sym| *sym);
        let hipModuleGetFunction = __library.get(b"hipModuleGetFunction\0").map(|sym| *sym);
        let hipFuncGetAttributes = __library.get(b"hipFuncGetAttributes\0").map(|sym| *sym);
        let hipFuncGetAttribute = __library.get(b"hipFuncGetAttribute\0").map(|sym| *sym);
        let hipModuleGetTexRef = __library.get(b"hipModuleGetTexRef\0").map(|sym| *sym);
        let hipModuleLoadData = __library.get(b"hipModuleLoadData\0").map(|sym| *sym);
        let hipModuleLoadDataEx = __library.get(b"hipModuleLoadDataEx\0").map(|sym| *sym);
        let hipModuleLaunchKernel = __library.get(b"hipModuleLaunchKernel\0").map(|sym| *sym);
        let hipLaunchCooperativeKernel = __library
            .get(b"hipLaunchCooperativeKernel\0")
            .map(|sym| *sym);
        let hipLaunchCooperativeKernelMultiDevice = __library
            .get(b"hipLaunchCooperativeKernelMultiDevice\0")
            .map(|sym| *sym);
        let hipExtLaunchMultiKernelMultiDevice = __library
            .get(b"hipExtLaunchMultiKernelMultiDevice\0")
            .map(|sym| *sym);
        let hipModuleOccupancyMaxPotentialBlockSize = __library
            .get(b"hipModuleOccupancyMaxPotentialBlockSize\0")
            .map(|sym| *sym);
        let hipModuleOccupancyMaxPotentialBlockSizeWithFlags = __library
            .get(b"hipModuleOccupancyMaxPotentialBlockSizeWithFlags\0")
            .map(|sym| *sym);
        let hipModuleOccupancyMaxActiveBlocksPerMultiprocessor = __library
            .get(b"hipModuleOccupancyMaxActiveBlocksPerMultiprocessor\0")
            .map(|sym| *sym);
        let hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags = __library
            .get(b"hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags\0")
            .map(|sym| *sym);
        let hipOccupancyMaxActiveBlocksPerMultiprocessor = __library
            .get(b"hipOccupancyMaxActiveBlocksPerMultiprocessor\0")
            .map(|sym| *sym);
        let hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags = __library
            .get(b"hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags\0")
            .map(|sym| *sym);
        let hipOccupancyMaxPotentialBlockSize = __library
            .get(b"hipOccupancyMaxPotentialBlockSize\0")
            .map(|sym| *sym);
        let hipProfilerStart = __library.get(b"hipProfilerStart\0").map(|sym| *sym);
        let hipProfilerStop = __library.get(b"hipProfilerStop\0").map(|sym| *sym);
        let hipConfigureCall = __library.get(b"hipConfigureCall\0").map(|sym| *sym);
        let hipSetupArgument = __library.get(b"hipSetupArgument\0").map(|sym| *sym);
        let hipLaunchByPtr = __library.get(b"hipLaunchByPtr\0").map(|sym| *sym);
        let hipLaunchKernel = __library.get(b"hipLaunchKernel\0").map(|sym| *sym);
        let hipLaunchHostFunc = __library.get(b"hipLaunchHostFunc\0").map(|sym| *sym);
        let hipDrvMemcpy2DUnaligned = __library.get(b"hipDrvMemcpy2DUnaligned\0").map(|sym| *sym);
        let hipExtLaunchKernel = __library.get(b"hipExtLaunchKernel\0").map(|sym| *sym);
        let hipBindTextureToMipmappedArray = __library
            .get(b"hipBindTextureToMipmappedArray\0")
            .map(|sym| *sym);
        let hipCreateTextureObject = __library.get(b"hipCreateTextureObject\0").map(|sym| *sym);
        let hipDestroyTextureObject = __library.get(b"hipDestroyTextureObject\0").map(|sym| *sym);
        let hipGetChannelDesc = __library.get(b"hipGetChannelDesc\0").map(|sym| *sym);
        let hipGetTextureObjectResourceDesc = __library
            .get(b"hipGetTextureObjectResourceDesc\0")
            .map(|sym| *sym);
        let hipGetTextureObjectResourceViewDesc = __library
            .get(b"hipGetTextureObjectResourceViewDesc\0")
            .map(|sym| *sym);
        let hipGetTextureObjectTextureDesc = __library
            .get(b"hipGetTextureObjectTextureDesc\0")
            .map(|sym| *sym);
        let hipTexObjectCreate = __library.get(b"hipTexObjectCreate\0").map(|sym| *sym);
        let hipTexObjectDestroy = __library.get(b"hipTexObjectDestroy\0").map(|sym| *sym);
        let hipTexObjectGetResourceDesc = __library
            .get(b"hipTexObjectGetResourceDesc\0")
            .map(|sym| *sym);
        let hipTexObjectGetResourceViewDesc = __library
            .get(b"hipTexObjectGetResourceViewDesc\0")
            .map(|sym| *sym);
        let hipTexObjectGetTextureDesc = __library
            .get(b"hipTexObjectGetTextureDesc\0")
            .map(|sym| *sym);
        let hipGetTextureReference = __library.get(b"hipGetTextureReference\0").map(|sym| *sym);
        let hipTexRefSetAddressMode = __library.get(b"hipTexRefSetAddressMode\0").map(|sym| *sym);
        let hipTexRefSetArray = __library.get(b"hipTexRefSetArray\0").map(|sym| *sym);
        let hipTexRefSetFilterMode = __library.get(b"hipTexRefSetFilterMode\0").map(|sym| *sym);
        let hipTexRefSetFlags = __library.get(b"hipTexRefSetFlags\0").map(|sym| *sym);
        let hipTexRefSetFormat = __library.get(b"hipTexRefSetFormat\0").map(|sym| *sym);
        let hipBindTexture = __library.get(b"hipBindTexture\0").map(|sym| *sym);
        let hipBindTexture2D = __library.get(b"hipBindTexture2D\0").map(|sym| *sym);
        let hipBindTextureToArray = __library.get(b"hipBindTextureToArray\0").map(|sym| *sym);
        let hipGetTextureAlignmentOffset = __library
            .get(b"hipGetTextureAlignmentOffset\0")
            .map(|sym| *sym);
        let hipUnbindTexture = __library.get(b"hipUnbindTexture\0").map(|sym| *sym);
        let hipTexRefGetAddress = __library.get(b"hipTexRefGetAddress\0").map(|sym| *sym);
        let hipTexRefGetAddressMode = __library.get(b"hipTexRefGetAddressMode\0").map(|sym| *sym);
        let hipTexRefGetFilterMode = __library.get(b"hipTexRefGetFilterMode\0").map(|sym| *sym);
        let hipTexRefGetFlags = __library.get(b"hipTexRefGetFlags\0").map(|sym| *sym);
        let hipTexRefGetFormat = __library.get(b"hipTexRefGetFormat\0").map(|sym| *sym);
        let hipTexRefGetMaxAnisotropy = __library
            .get(b"hipTexRefGetMaxAnisotropy\0")
            .map(|sym| *sym);
        let hipTexRefGetMipmapFilterMode = __library
            .get(b"hipTexRefGetMipmapFilterMode\0")
            .map(|sym| *sym);
        let hipTexRefGetMipmapLevelBias = __library
            .get(b"hipTexRefGetMipmapLevelBias\0")
            .map(|sym| *sym);
        let hipTexRefGetMipmapLevelClamp = __library
            .get(b"hipTexRefGetMipmapLevelClamp\0")
            .map(|sym| *sym);
        let hipTexRefGetMipMappedArray = __library
            .get(b"hipTexRefGetMipMappedArray\0")
            .map(|sym| *sym);
        let hipTexRefSetAddress = __library.get(b"hipTexRefSetAddress\0").map(|sym| *sym);
        let hipTexRefSetAddress2D = __library.get(b"hipTexRefSetAddress2D\0").map(|sym| *sym);
        let hipTexRefSetMaxAnisotropy = __library
            .get(b"hipTexRefSetMaxAnisotropy\0")
            .map(|sym| *sym);
        let hipTexRefSetBorderColor = __library.get(b"hipTexRefSetBorderColor\0").map(|sym| *sym);
        let hipTexRefSetMipmapFilterMode = __library
            .get(b"hipTexRefSetMipmapFilterMode\0")
            .map(|sym| *sym);
        let hipTexRefSetMipmapLevelBias = __library
            .get(b"hipTexRefSetMipmapLevelBias\0")
            .map(|sym| *sym);
        let hipTexRefSetMipmapLevelClamp = __library
            .get(b"hipTexRefSetMipmapLevelClamp\0")
            .map(|sym| *sym);
        let hipTexRefSetMipmappedArray = __library
            .get(b"hipTexRefSetMipmappedArray\0")
            .map(|sym| *sym);
        let hipMipmappedArrayCreate = __library.get(b"hipMipmappedArrayCreate\0").map(|sym| *sym);
        let hipMipmappedArrayDestroy = __library.get(b"hipMipmappedArrayDestroy\0").map(|sym| *sym);
        let hipMipmappedArrayGetLevel = __library
            .get(b"hipMipmappedArrayGetLevel\0")
            .map(|sym| *sym);
        let hipApiName = __library.get(b"hipApiName\0").map(|sym| *sym);
        let hipKernelNameRef = __library.get(b"hipKernelNameRef\0").map(|sym| *sym);
        let hipKernelNameRefByPtr = __library.get(b"hipKernelNameRefByPtr\0").map(|sym| *sym);
        let hipGetStreamDeviceId = __library.get(b"hipGetStreamDeviceId\0").map(|sym| *sym);
        let hipStreamBeginCapture = __library.get(b"hipStreamBeginCapture\0").map(|sym| *sym);
        let hipStreamEndCapture = __library.get(b"hipStreamEndCapture\0").map(|sym| *sym);
        let hipStreamGetCaptureInfo = __library.get(b"hipStreamGetCaptureInfo\0").map(|sym| *sym);
        let hipStreamGetCaptureInfo_v2 = __library
            .get(b"hipStreamGetCaptureInfo_v2\0")
            .map(|sym| *sym);
        let hipStreamIsCapturing = __library.get(b"hipStreamIsCapturing\0").map(|sym| *sym);
        let hipStreamUpdateCaptureDependencies = __library
            .get(b"hipStreamUpdateCaptureDependencies\0")
            .map(|sym| *sym);
        let hipThreadExchangeStreamCaptureMode = __library
            .get(b"hipThreadExchangeStreamCaptureMode\0")
            .map(|sym| *sym);
        let hipGraphCreate = __library.get(b"hipGraphCreate\0").map(|sym| *sym);
        let hipGraphDestroy = __library.get(b"hipGraphDestroy\0").map(|sym| *sym);
        let hipGraphAddDependencies = __library.get(b"hipGraphAddDependencies\0").map(|sym| *sym);
        let hipGraphRemoveDependencies = __library
            .get(b"hipGraphRemoveDependencies\0")
            .map(|sym| *sym);
        let hipGraphGetEdges = __library.get(b"hipGraphGetEdges\0").map(|sym| *sym);
        let hipGraphGetNodes = __library.get(b"hipGraphGetNodes\0").map(|sym| *sym);
        let hipGraphGetRootNodes = __library.get(b"hipGraphGetRootNodes\0").map(|sym| *sym);
        let hipGraphNodeGetDependencies = __library
            .get(b"hipGraphNodeGetDependencies\0")
            .map(|sym| *sym);
        let hipGraphNodeGetDependentNodes = __library
            .get(b"hipGraphNodeGetDependentNodes\0")
            .map(|sym| *sym);
        let hipGraphNodeGetType = __library.get(b"hipGraphNodeGetType\0").map(|sym| *sym);
        let hipGraphDestroyNode = __library.get(b"hipGraphDestroyNode\0").map(|sym| *sym);
        let hipGraphClone = __library.get(b"hipGraphClone\0").map(|sym| *sym);
        let hipGraphNodeFindInClone = __library.get(b"hipGraphNodeFindInClone\0").map(|sym| *sym);
        let hipGraphInstantiate = __library.get(b"hipGraphInstantiate\0").map(|sym| *sym);
        let hipGraphInstantiateWithFlags = __library
            .get(b"hipGraphInstantiateWithFlags\0")
            .map(|sym| *sym);
        let hipGraphLaunch = __library.get(b"hipGraphLaunch\0").map(|sym| *sym);
        let hipGraphUpload = __library.get(b"hipGraphUpload\0").map(|sym| *sym);
        let hipGraphExecDestroy = __library.get(b"hipGraphExecDestroy\0").map(|sym| *sym);
        let hipGraphExecUpdate = __library.get(b"hipGraphExecUpdate\0").map(|sym| *sym);
        let hipGraphAddKernelNode = __library.get(b"hipGraphAddKernelNode\0").map(|sym| *sym);
        let hipGraphKernelNodeGetParams = __library
            .get(b"hipGraphKernelNodeGetParams\0")
            .map(|sym| *sym);
        let hipGraphKernelNodeSetParams = __library
            .get(b"hipGraphKernelNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphExecKernelNodeSetParams = __library
            .get(b"hipGraphExecKernelNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphAddMemcpyNode = __library.get(b"hipGraphAddMemcpyNode\0").map(|sym| *sym);
        let hipGraphMemcpyNodeGetParams = __library
            .get(b"hipGraphMemcpyNodeGetParams\0")
            .map(|sym| *sym);
        let hipGraphMemcpyNodeSetParams = __library
            .get(b"hipGraphMemcpyNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphKernelNodeSetAttribute = __library
            .get(b"hipGraphKernelNodeSetAttribute\0")
            .map(|sym| *sym);
        let hipGraphKernelNodeGetAttribute = __library
            .get(b"hipGraphKernelNodeGetAttribute\0")
            .map(|sym| *sym);
        let hipGraphExecMemcpyNodeSetParams = __library
            .get(b"hipGraphExecMemcpyNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphAddMemcpyNode1D = __library.get(b"hipGraphAddMemcpyNode1D\0").map(|sym| *sym);
        let hipGraphMemcpyNodeSetParams1D = __library
            .get(b"hipGraphMemcpyNodeSetParams1D\0")
            .map(|sym| *sym);
        let hipGraphExecMemcpyNodeSetParams1D = __library
            .get(b"hipGraphExecMemcpyNodeSetParams1D\0")
            .map(|sym| *sym);
        let hipGraphAddMemcpyNodeFromSymbol = __library
            .get(b"hipGraphAddMemcpyNodeFromSymbol\0")
            .map(|sym| *sym);
        let hipGraphMemcpyNodeSetParamsFromSymbol = __library
            .get(b"hipGraphMemcpyNodeSetParamsFromSymbol\0")
            .map(|sym| *sym);
        let hipGraphExecMemcpyNodeSetParamsFromSymbol = __library
            .get(b"hipGraphExecMemcpyNodeSetParamsFromSymbol\0")
            .map(|sym| *sym);
        let hipGraphAddMemcpyNodeToSymbol = __library
            .get(b"hipGraphAddMemcpyNodeToSymbol\0")
            .map(|sym| *sym);
        let hipGraphMemcpyNodeSetParamsToSymbol = __library
            .get(b"hipGraphMemcpyNodeSetParamsToSymbol\0")
            .map(|sym| *sym);
        let hipGraphExecMemcpyNodeSetParamsToSymbol = __library
            .get(b"hipGraphExecMemcpyNodeSetParamsToSymbol\0")
            .map(|sym| *sym);
        let hipGraphAddMemsetNode = __library.get(b"hipGraphAddMemsetNode\0").map(|sym| *sym);
        let hipGraphMemsetNodeGetParams = __library
            .get(b"hipGraphMemsetNodeGetParams\0")
            .map(|sym| *sym);
        let hipGraphMemsetNodeSetParams = __library
            .get(b"hipGraphMemsetNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphExecMemsetNodeSetParams = __library
            .get(b"hipGraphExecMemsetNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphAddHostNode = __library.get(b"hipGraphAddHostNode\0").map(|sym| *sym);
        let hipGraphHostNodeGetParams = __library
            .get(b"hipGraphHostNodeGetParams\0")
            .map(|sym| *sym);
        let hipGraphHostNodeSetParams = __library
            .get(b"hipGraphHostNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphExecHostNodeSetParams = __library
            .get(b"hipGraphExecHostNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphAddChildGraphNode = __library
            .get(b"hipGraphAddChildGraphNode\0")
            .map(|sym| *sym);
        let hipGraphChildGraphNodeGetGraph = __library
            .get(b"hipGraphChildGraphNodeGetGraph\0")
            .map(|sym| *sym);
        let hipGraphExecChildGraphNodeSetParams = __library
            .get(b"hipGraphExecChildGraphNodeSetParams\0")
            .map(|sym| *sym);
        let hipGraphAddEmptyNode = __library.get(b"hipGraphAddEmptyNode\0").map(|sym| *sym);
        let hipGraphAddEventRecordNode = __library
            .get(b"hipGraphAddEventRecordNode\0")
            .map(|sym| *sym);
        let hipGraphEventRecordNodeGetEvent = __library
            .get(b"hipGraphEventRecordNodeGetEvent\0")
            .map(|sym| *sym);
        let hipGraphEventRecordNodeSetEvent = __library
            .get(b"hipGraphEventRecordNodeSetEvent\0")
            .map(|sym| *sym);
        let hipGraphExecEventRecordNodeSetEvent = __library
            .get(b"hipGraphExecEventRecordNodeSetEvent\0")
            .map(|sym| *sym);
        let hipGraphAddEventWaitNode = __library.get(b"hipGraphAddEventWaitNode\0").map(|sym| *sym);
        let hipGraphEventWaitNodeGetEvent = __library
            .get(b"hipGraphEventWaitNodeGetEvent\0")
            .map(|sym| *sym);
        let hipGraphEventWaitNodeSetEvent = __library
            .get(b"hipGraphEventWaitNodeSetEvent\0")
            .map(|sym| *sym);
        let hipGraphExecEventWaitNodeSetEvent = __library
            .get(b"hipGraphExecEventWaitNodeSetEvent\0")
            .map(|sym| *sym);
        let hipDeviceGetGraphMemAttribute = __library
            .get(b"hipDeviceGetGraphMemAttribute\0")
            .map(|sym| *sym);
        let hipDeviceSetGraphMemAttribute = __library
            .get(b"hipDeviceSetGraphMemAttribute\0")
            .map(|sym| *sym);
        let hipDeviceGraphMemTrim = __library.get(b"hipDeviceGraphMemTrim\0").map(|sym| *sym);
        let hipUserObjectCreate = __library.get(b"hipUserObjectCreate\0").map(|sym| *sym);
        let hipUserObjectRelease = __library.get(b"hipUserObjectRelease\0").map(|sym| *sym);
        let hipUserObjectRetain = __library.get(b"hipUserObjectRetain\0").map(|sym| *sym);
        let hipGraphRetainUserObject = __library.get(b"hipGraphRetainUserObject\0").map(|sym| *sym);
        let hipGraphReleaseUserObject = __library
            .get(b"hipGraphReleaseUserObject\0")
            .map(|sym| *sym);
        let hipMemAddressFree = __library.get(b"hipMemAddressFree\0").map(|sym| *sym);
        let hipMemAddressReserve = __library.get(b"hipMemAddressReserve\0").map(|sym| *sym);
        let hipMemCreate = __library.get(b"hipMemCreate\0").map(|sym| *sym);
        let hipMemExportToShareableHandle = __library
            .get(b"hipMemExportToShareableHandle\0")
            .map(|sym| *sym);
        let hipMemGetAccess = __library.get(b"hipMemGetAccess\0").map(|sym| *sym);
        let hipMemGetAllocationGranularity = __library
            .get(b"hipMemGetAllocationGranularity\0")
            .map(|sym| *sym);
        let hipMemGetAllocationPropertiesFromHandle = __library
            .get(b"hipMemGetAllocationPropertiesFromHandle\0")
            .map(|sym| *sym);
        let hipMemImportFromShareableHandle = __library
            .get(b"hipMemImportFromShareableHandle\0")
            .map(|sym| *sym);
        let hipMemMap = __library.get(b"hipMemMap\0").map(|sym| *sym);
        let hipMemMapArrayAsync = __library.get(b"hipMemMapArrayAsync\0").map(|sym| *sym);
        let hipMemRelease = __library.get(b"hipMemRelease\0").map(|sym| *sym);
        let hipMemRetainAllocationHandle = __library
            .get(b"hipMemRetainAllocationHandle\0")
            .map(|sym| *sym);
        let hipMemSetAccess = __library.get(b"hipMemSetAccess\0").map(|sym| *sym);
        let hipMemUnmap = __library.get(b"hipMemUnmap\0").map(|sym| *sym);
        let hipGLGetDevices = __library.get(b"hipGLGetDevices\0").map(|sym| *sym);
        let hipGraphicsGLRegisterBuffer = __library
            .get(b"hipGraphicsGLRegisterBuffer\0")
            .map(|sym| *sym);
        let hipGraphicsGLRegisterImage = __library
            .get(b"hipGraphicsGLRegisterImage\0")
            .map(|sym| *sym);
        let hipGraphicsMapResources = __library.get(b"hipGraphicsMapResources\0").map(|sym| *sym);
        let hipGraphicsSubResourceGetMappedArray = __library
            .get(b"hipGraphicsSubResourceGetMappedArray\0")
            .map(|sym| *sym);
        let hipGraphicsResourceGetMappedPointer = __library
            .get(b"hipGraphicsResourceGetMappedPointer\0")
            .map(|sym| *sym);
        let hipGraphicsUnmapResources = __library
            .get(b"hipGraphicsUnmapResources\0")
            .map(|sym| *sym);
        let hipGraphicsUnregisterResource = __library
            .get(b"hipGraphicsUnregisterResource\0")
            .map(|sym| *sym);
        let hipMemcpy_spt = __library.get(b"hipMemcpy_spt\0").map(|sym| *sym);
        let hipMemcpyToSymbol_spt = __library.get(b"hipMemcpyToSymbol_spt\0").map(|sym| *sym);
        let hipMemcpyFromSymbol_spt = __library.get(b"hipMemcpyFromSymbol_spt\0").map(|sym| *sym);
        let hipMemcpy2D_spt = __library.get(b"hipMemcpy2D_spt\0").map(|sym| *sym);
        let hipMemcpy2DFromArray_spt = __library.get(b"hipMemcpy2DFromArray_spt\0").map(|sym| *sym);
        let hipMemcpy3D_spt = __library.get(b"hipMemcpy3D_spt\0").map(|sym| *sym);
        let hipMemset_spt = __library.get(b"hipMemset_spt\0").map(|sym| *sym);
        let hipMemsetAsync_spt = __library.get(b"hipMemsetAsync_spt\0").map(|sym| *sym);
        let hipMemset2D_spt = __library.get(b"hipMemset2D_spt\0").map(|sym| *sym);
        let hipMemset2DAsync_spt = __library.get(b"hipMemset2DAsync_spt\0").map(|sym| *sym);
        let hipMemset3DAsync_spt = __library.get(b"hipMemset3DAsync_spt\0").map(|sym| *sym);
        let hipMemset3D_spt = __library.get(b"hipMemset3D_spt\0").map(|sym| *sym);
        let hipMemcpyAsync_spt = __library.get(b"hipMemcpyAsync_spt\0").map(|sym| *sym);
        let hipMemcpy3DAsync_spt = __library.get(b"hipMemcpy3DAsync_spt\0").map(|sym| *sym);
        let hipMemcpy2DAsync_spt = __library.get(b"hipMemcpy2DAsync_spt\0").map(|sym| *sym);
        let hipMemcpyFromSymbolAsync_spt = __library
            .get(b"hipMemcpyFromSymbolAsync_spt\0")
            .map(|sym| *sym);
        let hipMemcpyToSymbolAsync_spt = __library
            .get(b"hipMemcpyToSymbolAsync_spt\0")
            .map(|sym| *sym);
        let hipMemcpyFromArray_spt = __library.get(b"hipMemcpyFromArray_spt\0").map(|sym| *sym);
        let hipMemcpy2DToArray_spt = __library.get(b"hipMemcpy2DToArray_spt\0").map(|sym| *sym);
        let hipMemcpy2DFromArrayAsync_spt = __library
            .get(b"hipMemcpy2DFromArrayAsync_spt\0")
            .map(|sym| *sym);
        let hipMemcpy2DToArrayAsync_spt = __library
            .get(b"hipMemcpy2DToArrayAsync_spt\0")
            .map(|sym| *sym);
        let hipStreamQuery_spt = __library.get(b"hipStreamQuery_spt\0").map(|sym| *sym);
        let hipStreamSynchronize_spt = __library.get(b"hipStreamSynchronize_spt\0").map(|sym| *sym);
        let hipStreamGetPriority_spt = __library.get(b"hipStreamGetPriority_spt\0").map(|sym| *sym);
        let hipStreamWaitEvent_spt = __library.get(b"hipStreamWaitEvent_spt\0").map(|sym| *sym);
        let hipStreamGetFlags_spt = __library.get(b"hipStreamGetFlags_spt\0").map(|sym| *sym);
        let hipStreamAddCallback_spt = __library.get(b"hipStreamAddCallback_spt\0").map(|sym| *sym);
        let hipEventRecord_spt = __library.get(b"hipEventRecord_spt\0").map(|sym| *sym);
        let hipLaunchCooperativeKernel_spt = __library
            .get(b"hipLaunchCooperativeKernel_spt\0")
            .map(|sym| *sym);
        let hipLaunchKernel_spt = __library.get(b"hipLaunchKernel_spt\0").map(|sym| *sym);
        let hipGraphLaunch_spt = __library.get(b"hipGraphLaunch_spt\0").map(|sym| *sym);
        let hipStreamBeginCapture_spt = __library
            .get(b"hipStreamBeginCapture_spt\0")
            .map(|sym| *sym);
        let hipStreamEndCapture_spt = __library.get(b"hipStreamEndCapture_spt\0").map(|sym| *sym);
        let hipStreamIsCapturing_spt = __library.get(b"hipStreamIsCapturing_spt\0").map(|sym| *sym);
        let hipStreamGetCaptureInfo_spt = __library
            .get(b"hipStreamGetCaptureInfo_spt\0")
            .map(|sym| *sym);
        let hipStreamGetCaptureInfo_v2_spt = __library
            .get(b"hipStreamGetCaptureInfo_v2_spt\0")
            .map(|sym| *sym);
        let hipLaunchHostFunc_spt = __library.get(b"hipLaunchHostFunc_spt\0").map(|sym| *sym);
        Ok(hip {
            __library,
            hipCreateChannelDesc,
            hipInit,
            hipDriverGetVersion,
            hipRuntimeGetVersion,
            hipDeviceGet,
            hipDeviceComputeCapability,
            hipDeviceGetName,
            hipDeviceGetUuid,
            hipDeviceGetP2PAttribute,
            hipDeviceGetPCIBusId,
            hipDeviceGetByPCIBusId,
            hipDeviceTotalMem,
            hipDeviceSynchronize,
            hipDeviceReset,
            hipSetDevice,
            hipGetDevice,
            hipGetDeviceCount,
            hipDeviceGetAttribute,
            hipDeviceGetDefaultMemPool,
            hipDeviceSetMemPool,
            hipDeviceGetMemPool,
            hipGetDeviceProperties,
            hipDeviceSetCacheConfig,
            hipDeviceGetCacheConfig,
            hipDeviceGetLimit,
            hipDeviceSetLimit,
            hipDeviceGetSharedMemConfig,
            hipGetDeviceFlags,
            hipDeviceSetSharedMemConfig,
            hipSetDeviceFlags,
            hipChooseDevice,
            hipExtGetLinkTypeAndHopCount,
            hipIpcGetMemHandle,
            hipIpcOpenMemHandle,
            hipIpcCloseMemHandle,
            hipIpcGetEventHandle,
            hipIpcOpenEventHandle,
            hipFuncSetAttribute,
            hipFuncSetCacheConfig,
            hipFuncSetSharedMemConfig,
            hipGetLastError,
            hipPeekAtLastError,
            hipGetErrorName,
            hipGetErrorString,
            hipDrvGetErrorName,
            hipDrvGetErrorString,
            hipStreamCreate,
            hipStreamCreateWithFlags,
            hipStreamCreateWithPriority,
            hipDeviceGetStreamPriorityRange,
            hipStreamDestroy,
            hipStreamQuery,
            hipStreamSynchronize,
            hipStreamWaitEvent,
            hipStreamGetFlags,
            hipStreamGetPriority,
            hipExtStreamCreateWithCUMask,
            hipExtStreamGetCUMask,
            hipStreamAddCallback,
            hipStreamWaitValue32,
            hipStreamWaitValue64,
            hipStreamWriteValue32,
            hipStreamWriteValue64,
            hipEventCreateWithFlags,
            hipEventCreate,
            hipEventRecord,
            hipEventDestroy,
            hipEventSynchronize,
            hipEventElapsedTime,
            hipEventQuery,
            hipPointerGetAttributes,
            hipPointerGetAttribute,
            hipDrvPointerGetAttributes,
            hipImportExternalSemaphore,
            hipSignalExternalSemaphoresAsync,
            hipWaitExternalSemaphoresAsync,
            hipDestroyExternalSemaphore,
            hipImportExternalMemory,
            hipExternalMemoryGetMappedBuffer,
            hipDestroyExternalMemory,
            hipMalloc,
            hipExtMallocWithFlags,
            hipMallocHost,
            hipMemAllocHost,
            hipHostMalloc,
            hipMallocManaged,
            hipMemPrefetchAsync,
            hipMemAdvise,
            hipMemRangeGetAttribute,
            hipMemRangeGetAttributes,
            hipStreamAttachMemAsync,
            hipMallocAsync,
            hipFreeAsync,
            hipMemPoolTrimTo,
            hipMemPoolSetAttribute,
            hipMemPoolGetAttribute,
            hipMemPoolSetAccess,
            hipMemPoolGetAccess,
            hipMemPoolCreate,
            hipMemPoolDestroy,
            hipMallocFromPoolAsync,
            hipMemPoolExportToShareableHandle,
            hipMemPoolImportFromShareableHandle,
            hipMemPoolExportPointer,
            hipMemPoolImportPointer,
            hipHostAlloc,
            hipHostGetDevicePointer,
            hipHostGetFlags,
            hipHostRegister,
            hipHostUnregister,
            hipMallocPitch,
            hipMemAllocPitch,
            hipFree,
            hipFreeHost,
            hipHostFree,
            hipMemcpy,
            hipMemcpyWithStream,
            hipMemcpyHtoD,
            hipMemcpyDtoH,
            hipMemcpyDtoD,
            hipMemcpyHtoDAsync,
            hipMemcpyDtoHAsync,
            hipMemcpyDtoDAsync,
            hipModuleGetGlobal,
            hipGetSymbolAddress,
            hipGetSymbolSize,
            hipMemcpyToSymbol,
            hipMemcpyToSymbolAsync,
            hipMemcpyFromSymbol,
            hipMemcpyFromSymbolAsync,
            hipMemcpyAsync,
            hipMemset,
            hipMemsetD8,
            hipMemsetD8Async,
            hipMemsetD16,
            hipMemsetD16Async,
            hipMemsetD32,
            hipMemsetAsync,
            hipMemsetD32Async,
            hipMemset2D,
            hipMemset2DAsync,
            hipMemset3D,
            hipMemset3DAsync,
            hipMemGetInfo,
            hipMemPtrGetInfo,
            hipMallocArray,
            hipArrayCreate,
            hipArrayDestroy,
            hipArray3DCreate,
            hipMalloc3D,
            hipFreeArray,
            hipFreeMipmappedArray,
            hipMalloc3DArray,
            hipMallocMipmappedArray,
            hipGetMipmappedArrayLevel,
            hipMemcpy2D,
            hipMemcpyParam2D,
            hipMemcpyParam2DAsync,
            hipMemcpy2DAsync,
            hipMemcpy2DToArray,
            hipMemcpy2DToArrayAsync,
            hipMemcpyToArray,
            hipMemcpyFromArray,
            hipMemcpy2DFromArray,
            hipMemcpy2DFromArrayAsync,
            hipMemcpyAtoH,
            hipMemcpyHtoA,
            hipMemcpy3D,
            hipMemcpy3DAsync,
            hipDrvMemcpy3D,
            hipDrvMemcpy3DAsync,
            hipDeviceCanAccessPeer,
            hipDeviceEnablePeerAccess,
            hipDeviceDisablePeerAccess,
            hipMemGetAddressRange,
            hipMemcpyPeer,
            hipMemcpyPeerAsync,
            hipCtxCreate,
            hipCtxDestroy,
            hipCtxPopCurrent,
            hipCtxPushCurrent,
            hipCtxSetCurrent,
            hipCtxGetCurrent,
            hipCtxGetDevice,
            hipCtxGetApiVersion,
            hipCtxGetCacheConfig,
            hipCtxSetCacheConfig,
            hipCtxSetSharedMemConfig,
            hipCtxGetSharedMemConfig,
            hipCtxSynchronize,
            hipCtxGetFlags,
            hipCtxEnablePeerAccess,
            hipCtxDisablePeerAccess,
            hipDevicePrimaryCtxGetState,
            hipDevicePrimaryCtxRelease,
            hipDevicePrimaryCtxRetain,
            hipDevicePrimaryCtxReset,
            hipDevicePrimaryCtxSetFlags,
            hipModuleLoad,
            hipModuleUnload,
            hipModuleGetFunction,
            hipFuncGetAttributes,
            hipFuncGetAttribute,
            hipModuleGetTexRef,
            hipModuleLoadData,
            hipModuleLoadDataEx,
            hipModuleLaunchKernel,
            hipLaunchCooperativeKernel,
            hipLaunchCooperativeKernelMultiDevice,
            hipExtLaunchMultiKernelMultiDevice,
            hipModuleOccupancyMaxPotentialBlockSize,
            hipModuleOccupancyMaxPotentialBlockSizeWithFlags,
            hipModuleOccupancyMaxActiveBlocksPerMultiprocessor,
            hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags,
            hipOccupancyMaxActiveBlocksPerMultiprocessor,
            hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags,
            hipOccupancyMaxPotentialBlockSize,
            hipProfilerStart,
            hipProfilerStop,
            hipConfigureCall,
            hipSetupArgument,
            hipLaunchByPtr,
            hipLaunchKernel,
            hipLaunchHostFunc,
            hipDrvMemcpy2DUnaligned,
            hipExtLaunchKernel,
            hipBindTextureToMipmappedArray,
            hipCreateTextureObject,
            hipDestroyTextureObject,
            hipGetChannelDesc,
            hipGetTextureObjectResourceDesc,
            hipGetTextureObjectResourceViewDesc,
            hipGetTextureObjectTextureDesc,
            hipTexObjectCreate,
            hipTexObjectDestroy,
            hipTexObjectGetResourceDesc,
            hipTexObjectGetResourceViewDesc,
            hipTexObjectGetTextureDesc,
            hipGetTextureReference,
            hipTexRefSetAddressMode,
            hipTexRefSetArray,
            hipTexRefSetFilterMode,
            hipTexRefSetFlags,
            hipTexRefSetFormat,
            hipBindTexture,
            hipBindTexture2D,
            hipBindTextureToArray,
            hipGetTextureAlignmentOffset,
            hipUnbindTexture,
            hipTexRefGetAddress,
            hipTexRefGetAddressMode,
            hipTexRefGetFilterMode,
            hipTexRefGetFlags,
            hipTexRefGetFormat,
            hipTexRefGetMaxAnisotropy,
            hipTexRefGetMipmapFilterMode,
            hipTexRefGetMipmapLevelBias,
            hipTexRefGetMipmapLevelClamp,
            hipTexRefGetMipMappedArray,
            hipTexRefSetAddress,
            hipTexRefSetAddress2D,
            hipTexRefSetMaxAnisotropy,
            hipTexRefSetBorderColor,
            hipTexRefSetMipmapFilterMode,
            hipTexRefSetMipmapLevelBias,
            hipTexRefSetMipmapLevelClamp,
            hipTexRefSetMipmappedArray,
            hipMipmappedArrayCreate,
            hipMipmappedArrayDestroy,
            hipMipmappedArrayGetLevel,
            hipApiName,
            hipKernelNameRef,
            hipKernelNameRefByPtr,
            hipGetStreamDeviceId,
            hipStreamBeginCapture,
            hipStreamEndCapture,
            hipStreamGetCaptureInfo,
            hipStreamGetCaptureInfo_v2,
            hipStreamIsCapturing,
            hipStreamUpdateCaptureDependencies,
            hipThreadExchangeStreamCaptureMode,
            hipGraphCreate,
            hipGraphDestroy,
            hipGraphAddDependencies,
            hipGraphRemoveDependencies,
            hipGraphGetEdges,
            hipGraphGetNodes,
            hipGraphGetRootNodes,
            hipGraphNodeGetDependencies,
            hipGraphNodeGetDependentNodes,
            hipGraphNodeGetType,
            hipGraphDestroyNode,
            hipGraphClone,
            hipGraphNodeFindInClone,
            hipGraphInstantiate,
            hipGraphInstantiateWithFlags,
            hipGraphLaunch,
            hipGraphUpload,
            hipGraphExecDestroy,
            hipGraphExecUpdate,
            hipGraphAddKernelNode,
            hipGraphKernelNodeGetParams,
            hipGraphKernelNodeSetParams,
            hipGraphExecKernelNodeSetParams,
            hipGraphAddMemcpyNode,
            hipGraphMemcpyNodeGetParams,
            hipGraphMemcpyNodeSetParams,
            hipGraphKernelNodeSetAttribute,
            hipGraphKernelNodeGetAttribute,
            hipGraphExecMemcpyNodeSetParams,
            hipGraphAddMemcpyNode1D,
            hipGraphMemcpyNodeSetParams1D,
            hipGraphExecMemcpyNodeSetParams1D,
            hipGraphAddMemcpyNodeFromSymbol,
            hipGraphMemcpyNodeSetParamsFromSymbol,
            hipGraphExecMemcpyNodeSetParamsFromSymbol,
            hipGraphAddMemcpyNodeToSymbol,
            hipGraphMemcpyNodeSetParamsToSymbol,
            hipGraphExecMemcpyNodeSetParamsToSymbol,
            hipGraphAddMemsetNode,
            hipGraphMemsetNodeGetParams,
            hipGraphMemsetNodeSetParams,
            hipGraphExecMemsetNodeSetParams,
            hipGraphAddHostNode,
            hipGraphHostNodeGetParams,
            hipGraphHostNodeSetParams,
            hipGraphExecHostNodeSetParams,
            hipGraphAddChildGraphNode,
            hipGraphChildGraphNodeGetGraph,
            hipGraphExecChildGraphNodeSetParams,
            hipGraphAddEmptyNode,
            hipGraphAddEventRecordNode,
            hipGraphEventRecordNodeGetEvent,
            hipGraphEventRecordNodeSetEvent,
            hipGraphExecEventRecordNodeSetEvent,
            hipGraphAddEventWaitNode,
            hipGraphEventWaitNodeGetEvent,
            hipGraphEventWaitNodeSetEvent,
            hipGraphExecEventWaitNodeSetEvent,
            hipDeviceGetGraphMemAttribute,
            hipDeviceSetGraphMemAttribute,
            hipDeviceGraphMemTrim,
            hipUserObjectCreate,
            hipUserObjectRelease,
            hipUserObjectRetain,
            hipGraphRetainUserObject,
            hipGraphReleaseUserObject,
            hipMemAddressFree,
            hipMemAddressReserve,
            hipMemCreate,
            hipMemExportToShareableHandle,
            hipMemGetAccess,
            hipMemGetAllocationGranularity,
            hipMemGetAllocationPropertiesFromHandle,
            hipMemImportFromShareableHandle,
            hipMemMap,
            hipMemMapArrayAsync,
            hipMemRelease,
            hipMemRetainAllocationHandle,
            hipMemSetAccess,
            hipMemUnmap,
            hipGLGetDevices,
            hipGraphicsGLRegisterBuffer,
            hipGraphicsGLRegisterImage,
            hipGraphicsMapResources,
            hipGraphicsSubResourceGetMappedArray,
            hipGraphicsResourceGetMappedPointer,
            hipGraphicsUnmapResources,
            hipGraphicsUnregisterResource,
            hipMemcpy_spt,
            hipMemcpyToSymbol_spt,
            hipMemcpyFromSymbol_spt,
            hipMemcpy2D_spt,
            hipMemcpy2DFromArray_spt,
            hipMemcpy3D_spt,
            hipMemset_spt,
            hipMemsetAsync_spt,
            hipMemset2D_spt,
            hipMemset2DAsync_spt,
            hipMemset3DAsync_spt,
            hipMemset3D_spt,
            hipMemcpyAsync_spt,
            hipMemcpy3DAsync_spt,
            hipMemcpy2DAsync_spt,
            hipMemcpyFromSymbolAsync_spt,
            hipMemcpyToSymbolAsync_spt,
            hipMemcpyFromArray_spt,
            hipMemcpy2DToArray_spt,
            hipMemcpy2DFromArrayAsync_spt,
            hipMemcpy2DToArrayAsync_spt,
            hipStreamQuery_spt,
            hipStreamSynchronize_spt,
            hipStreamGetPriority_spt,
            hipStreamWaitEvent_spt,
            hipStreamGetFlags_spt,
            hipStreamAddCallback_spt,
            hipEventRecord_spt,
            hipLaunchCooperativeKernel_spt,
            hipLaunchKernel_spt,
            hipGraphLaunch_spt,
            hipStreamBeginCapture_spt,
            hipStreamEndCapture_spt,
            hipStreamIsCapturing_spt,
            hipStreamGetCaptureInfo_spt,
            hipStreamGetCaptureInfo_v2_spt,
            hipLaunchHostFunc_spt,
        })
    }
    pub unsafe fn hipCreateChannelDesc(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        f: hipChannelFormatKind,
    ) -> hipChannelFormatDesc {
        (self
            .hipCreateChannelDesc
            .as_ref()
            .expect("Expected function, got error."))(x, y, z, w, f)
    }
    #[doc = "  @defgroup API HIP API\n  @{\n\n  Defines the HIP API.  See the individual sections for more information.\n/\n/**\n  @defgroup Driver Initialization and Version\n  @{\n  This section describes the initializtion and version functions of HIP runtime API.\n\n/\n/**\n @brief Explicitly initializes the HIP runtime.\n\n Most HIP APIs implicitly initialize the HIP runtime.\n This API provides control over the timing of the initialization."]
    pub unsafe fn hipInit(&self, flags: ::std::os::raw::c_uint) -> hipError_t {
        (self
            .hipInit
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    #[doc = " @brief Returns the approximate HIP driver version.\n\n @param [out] driverVersion\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The HIP feature set does not correspond to an exact CUDA SDK driver revision.\n This function always set *driverVersion to 4 as an approximation though HIP supports\n some features which were introduced in later CUDA SDK revisions.\n HIP apps code should not rely on the driver revision number here and should\n use arch feature flags to test device capabilities or conditional compilation.\n\n @see hipRuntimeGetVersion"]
    pub unsafe fn hipDriverGetVersion(
        &self,
        driverVersion: *mut ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDriverGetVersion
            .as_ref()
            .expect("Expected function, got error."))(driverVersion)
    }
    #[doc = " @brief Returns the approximate HIP Runtime version.\n\n @param [out] runtimeVersion\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The version definition of HIP runtime is different from CUDA.\n On AMD platform, the function returns HIP runtime version,\n while on NVIDIA platform, it returns CUDA runtime version.\n And there is no mapping/correlation between HIP version and CUDA version.\n\n @see hipDriverGetVersion"]
    pub unsafe fn hipRuntimeGetVersion(
        &self,
        runtimeVersion: *mut ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipRuntimeGetVersion
            .as_ref()
            .expect("Expected function, got error."))(runtimeVersion)
    }
    #[doc = " @brief Returns a handle to a compute device\n @param [out] device\n @param [in] ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub unsafe fn hipDeviceGet(
        &self,
        device: *mut hipDevice_t,
        ordinal: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceGet
            .as_ref()
            .expect("Expected function, got error."))(device, ordinal)
    }
    #[doc = " @brief Returns the compute capability of the device\n @param [out] major\n @param [out] minor\n @param [in] device\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub unsafe fn hipDeviceComputeCapability(
        &self,
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t {
        (self
            .hipDeviceComputeCapability
            .as_ref()
            .expect("Expected function, got error."))(major, minor, device)
    }
    #[doc = " @brief Returns an identifer string for the device.\n @param [out] name\n @param [in] len\n @param [in] device\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub unsafe fn hipDeviceGetName(
        &self,
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t {
        (self
            .hipDeviceGetName
            .as_ref()
            .expect("Expected function, got error."))(name, len, device)
    }
    #[doc = " @brief Returns an UUID for the device.[BETA]\n @param [out] uuid\n @param [in] device\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorDeinitialized"]
    pub unsafe fn hipDeviceGetUuid(&self, uuid: *mut hipUUID, device: hipDevice_t) -> hipError_t {
        (self
            .hipDeviceGetUuid
            .as_ref()
            .expect("Expected function, got error."))(uuid, device)
    }
    #[doc = " @brief Returns a value for attr of link between two devices\n @param [out] value\n @param [in] attr\n @param [in] srcDevice\n @param [in] dstDevice\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub unsafe fn hipDeviceGetP2PAttribute(
        &self,
        value: *mut ::std::os::raw::c_int,
        attr: hipDeviceP2PAttr,
        srcDevice: ::std::os::raw::c_int,
        dstDevice: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceGetP2PAttribute
            .as_ref()
            .expect("Expected function, got error."))(value, attr, srcDevice, dstDevice)
    }
    #[doc = " @brief Returns a PCI Bus Id string for the device, overloaded to take int device ID.\n @param [out] pciBusId\n @param [in] len\n @param [in] device\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub unsafe fn hipDeviceGetPCIBusId(
        &self,
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceGetPCIBusId
            .as_ref()
            .expect("Expected function, got error."))(pciBusId, len, device)
    }
    #[doc = " @brief Returns a handle to a compute device.\n @param [out] device handle\n @param [in] PCI Bus ID\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub unsafe fn hipDeviceGetByPCIBusId(
        &self,
        device: *mut ::std::os::raw::c_int,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> hipError_t {
        (self
            .hipDeviceGetByPCIBusId
            .as_ref()
            .expect("Expected function, got error."))(device, pciBusId)
    }
    #[doc = " @brief Returns the total amount of memory on the device.\n @param [out] bytes\n @param [in] device\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub unsafe fn hipDeviceTotalMem(&self, bytes: *mut usize, device: hipDevice_t) -> hipError_t {
        (self
            .hipDeviceTotalMem
            .as_ref()
            .expect("Expected function, got error."))(bytes, device)
    }
    #[doc = " @}\n/\n/**\n  @defgroup Device Device Management\n  @{\n  This section describes the device management functions of HIP runtime API.\n/\n/**\n @brief Waits on all active streams on current device\n\n When this command is invoked, the host thread gets blocked until all the commands associated\n with streams associated with the device. HIP does not support multiple blocking modes (yet!).\n\n @returns #hipSuccess\n\n @see hipSetDevice, hipDeviceReset"]
    pub unsafe fn hipDeviceSynchronize(&self) -> hipError_t {
        (self
            .hipDeviceSynchronize
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " @brief The state of current device is discarded and updated to a fresh state.\n\n Calling this function deletes all streams created, memory allocated, kernels running, events\n created. Make sure that no other thread is using the device or streams, memory, kernels, events\n associated with the current device.\n\n @returns #hipSuccess\n\n @see hipDeviceSynchronize"]
    pub unsafe fn hipDeviceReset(&self) -> hipError_t {
        (self
            .hipDeviceReset
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " @brief Set default device to be used for subsequent hip API calls from this thread.\n\n @param[in] deviceId Valid device in range 0...hipGetDeviceCount().\n\n Sets @p device as the default device for the calling host thread.  Valid device id's are 0...\n (hipGetDeviceCount()-1).\n\n Many HIP APIs implicitly use the \"default device\" :\n\n - Any device memory subsequently allocated from this host thread (using hipMalloc) will be\n allocated on device.\n - Any streams or events created from this host thread will be associated with device.\n - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device\n (unless a specific stream is specified, in which case the device associated with that stream will\n be used).\n\n This function may be called from any host thread.  Multiple host threads may use the same device.\n This function does no synchronization with the previous or new device, and has very little\n runtime overhead. Applications can use hipSetDevice to quickly switch the default device before\n making a HIP runtime call which uses the default device.\n\n The default device is stored in thread-local-storage for each thread.\n Thread-pool implementations may inherit the default device of the previous thread.  A good\n practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known\n standard device.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorDeviceAlreadyInUse\n\n @see hipGetDevice, hipGetDeviceCount"]
    pub unsafe fn hipSetDevice(&self, deviceId: ::std::os::raw::c_int) -> hipError_t {
        (self
            .hipSetDevice
            .as_ref()
            .expect("Expected function, got error."))(deviceId)
    }
    #[doc = " @brief Return the default device id for the calling host thread.\n\n @param [out] device *device is written with the default device\n\n HIP maintains an default device for each thread using thread-local-storage.\n This device is used implicitly for HIP runtime APIs called by this thread.\n hipGetDevice returns in * @p device the default device for the calling host thread.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n @see hipSetDevice, hipGetDevicesizeBytes"]
    pub unsafe fn hipGetDevice(&self, deviceId: *mut ::std::os::raw::c_int) -> hipError_t {
        (self
            .hipGetDevice
            .as_ref()
            .expect("Expected function, got error."))(deviceId)
    }
    #[doc = " @brief Return number of compute-capable devices.\n\n @param [output] count Returns number of compute-capable devices.\n\n @returns #hipSuccess, #hipErrorNoDevice\n\n\n Returns in @p *count the number of devices that have ability to run compute commands.  If there\n are no such devices, then @ref hipGetDeviceCount will return #hipErrorNoDevice. If 1 or more\n devices can be found, then hipGetDeviceCount returns #hipSuccess."]
    pub unsafe fn hipGetDeviceCount(&self, count: *mut ::std::os::raw::c_int) -> hipError_t {
        (self
            .hipGetDeviceCount
            .as_ref()
            .expect("Expected function, got error."))(count)
    }
    #[doc = " @brief Query for a specific device attribute.\n\n @param [out] pi pointer to value to return\n @param [in] attr attribute to query\n @param [in] deviceId which device to query for information\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub unsafe fn hipDeviceGetAttribute(
        &self,
        pi: *mut ::std::os::raw::c_int,
        attr: hipDeviceAttribute_t,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(pi, attr, deviceId)
    }
    #[doc = " @brief Returns the default memory pool of the specified device\n\n @param [out] mem_pool Default memory pool to return\n @param [in] device    Device index for query the default memory pool\n\n @returns #chipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipDeviceGetDefaultMemPool(
        &self,
        mem_pool: *mut hipMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceGetDefaultMemPool
            .as_ref()
            .expect("Expected function, got error."))(mem_pool, device)
    }
    #[doc = " @brief Sets the current memory pool of a device\n\n The memory pool must be local to the specified device.\n @p hipMallocAsync allocates from the current mempool of the provided stream's device.\n By default, a device's current memory pool is its default memory pool.\n\n @note Use @p hipMallocFromPoolAsync for asynchronous memory allocations from a device\n different than the one the stream runs on.\n\n @param [in] device   Device index for the update\n @param [in] mem_pool Memory pool for update as the current on the specified device\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipDeviceSetMemPool(
        &self,
        device: ::std::os::raw::c_int,
        mem_pool: hipMemPool_t,
    ) -> hipError_t {
        (self
            .hipDeviceSetMemPool
            .as_ref()
            .expect("Expected function, got error."))(device, mem_pool)
    }
    #[doc = " @brief Gets the current memory pool for the specified device\n\n Returns the last pool provided to @p hipDeviceSetMemPool for this device\n or the device's default memory pool if @p hipDeviceSetMemPool has never been called.\n By default the current mempool is the default mempool for a device,\n otherwise the returned pool must have been set with @p hipDeviceSetMemPool.\n\n @param [out] mem_pool Current memory pool on the specified device\n @param [in] device    Device index to query the current memory pool\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipDeviceGetMemPool(
        &self,
        mem_pool: *mut hipMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceGetMemPool
            .as_ref()
            .expect("Expected function, got error."))(mem_pool, device)
    }
    #[doc = " @brief Returns device properties.\n\n @param [out] prop written with device properties\n @param [in]  deviceId which device to query for information\n\n @return #hipSuccess, #hipErrorInvalidDevice\n @bug HCC always returns 0 for maxThreadsPerMultiProcessor\n @bug HCC always returns 0 for regsPerBlock\n @bug HCC always returns 0 for l2CacheSize\n\n Populates hipGetDeviceProperties with information for the specified device."]
    pub unsafe fn hipGetDeviceProperties(
        &self,
        prop: *mut hipDeviceProp_t,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipGetDeviceProperties
            .as_ref()
            .expect("Expected function, got error."))(prop, deviceId)
    }
    #[doc = " @brief Set L1/Shared cache partition.\n\n @param [in] cacheConfig\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored\n on those architectures.\n"]
    pub unsafe fn hipDeviceSetCacheConfig(&self, cacheConfig: hipFuncCache_t) -> hipError_t {
        (self
            .hipDeviceSetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(cacheConfig)
    }
    #[doc = " @brief Get Cache configuration for a specific Device\n\n @param [out] cacheConfig\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored\n on those architectures.\n"]
    pub unsafe fn hipDeviceGetCacheConfig(&self, cacheConfig: *mut hipFuncCache_t) -> hipError_t {
        (self
            .hipDeviceGetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(cacheConfig)
    }
    #[doc = " @brief Get Resource limits of current device\n\n @param [out] pValue\n @param [in]  limit\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n Note: Currently, only hipLimitMallocHeapSize is available\n"]
    pub unsafe fn hipDeviceGetLimit(&self, pValue: *mut usize, limit: hipLimit_t) -> hipError_t {
        (self
            .hipDeviceGetLimit
            .as_ref()
            .expect("Expected function, got error."))(pValue, limit)
    }
    #[doc = " @brief Set Resource limits of current device\n\n @param [in] limit\n @param [in] value\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n"]
    pub unsafe fn hipDeviceSetLimit(&self, limit: hipLimit_t, value: usize) -> hipError_t {
        (self
            .hipDeviceSetLimit
            .as_ref()
            .expect("Expected function, got error."))(limit, value)
    }
    #[doc = " @brief Returns bank width of shared memory for current device\n\n @param [out] pConfig\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub unsafe fn hipDeviceGetSharedMemConfig(
        &self,
        pConfig: *mut hipSharedMemConfig,
    ) -> hipError_t {
        (self
            .hipDeviceGetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(pConfig)
    }
    #[doc = " @brief Gets the flags set for current device\n\n @param [out] flags\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub unsafe fn hipGetDeviceFlags(&self, flags: *mut ::std::os::raw::c_uint) -> hipError_t {
        (self
            .hipGetDeviceFlags
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    #[doc = " @brief The bank width of shared memory on current device is set\n\n @param [in] config\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub unsafe fn hipDeviceSetSharedMemConfig(&self, config: hipSharedMemConfig) -> hipError_t {
        (self
            .hipDeviceSetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(config)
    }
    #[doc = " @brief The current device behavior is changed according the flags passed.\n\n @param [in] flags\n\n The schedule flags impact how HIP waits for the completion of a command running on a device.\n hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the\n work until the command completes.  This offers the lowest latency, but will consume a CPU core\n and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to\n system so that other tasks can use it.  This may increase latency to detect the completion but\n will consume less power and is friendlier to other tasks in the system.\n hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield.\n hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the\n number of HIP contexts is greater than the number of logical processors in the system, use Spin\n scheduling.  Else use Yield scheduling.\n\n\n hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and\n the flag is ignored. hipDeviceLmemResizeToMax      : @warning ROCm silently ignores this flag.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess\n\n"]
    pub unsafe fn hipSetDeviceFlags(&self, flags: ::std::os::raw::c_uint) -> hipError_t {
        (self
            .hipSetDeviceFlags
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    #[doc = " @brief Device which matches hipDeviceProp_t is returned\n\n @param [out] device ID\n @param [in]  device properties pointer\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipChooseDevice(
        &self,
        device: *mut ::std::os::raw::c_int,
        prop: *const hipDeviceProp_t,
    ) -> hipError_t {
        (self
            .hipChooseDevice
            .as_ref()
            .expect("Expected function, got error."))(device, prop)
    }
    #[doc = " @brief Returns the link type and hop count between two devices\n\n @param [in] device1 Ordinal for device1\n @param [in] device2 Ordinal for device2\n @param [out] linktype Returns the link type (See hsa_amd_link_info_type_t) between the two devices\n @param [out] hopcount Returns the hop count between the two devices\n\n Queries and returns the HSA link type and the hop count between the two specified devices.\n\n @returns #hipSuccess, #hipInvalidDevice, #hipErrorRuntimeOther"]
    pub unsafe fn hipExtGetLinkTypeAndHopCount(
        &self,
        device1: ::std::os::raw::c_int,
        device2: ::std::os::raw::c_int,
        linktype: *mut u32,
        hopcount: *mut u32,
    ) -> hipError_t {
        (self
            .hipExtGetLinkTypeAndHopCount
            .as_ref()
            .expect("Expected function, got error."))(device1, device2, linktype, hopcount)
    }
    #[doc = " @brief Gets an interprocess memory handle for an existing device memory\n          allocation\n\n Takes a pointer to the base of an existing device memory allocation created\n with hipMalloc and exports it for use in another process. This is a\n lightweight operation and may be called multiple times on an allocation\n without adverse effects.\n\n If a region of memory is freed with hipFree and a subsequent call\n to hipMalloc returns memory with the same device address,\n hipIpcGetMemHandle will return a unique handle for the\n new memory.\n\n @param handle - Pointer to user allocated hipIpcMemHandle to return\n                    the handle in.\n @param devPtr - Base pointer to previously allocated device memory\n\n @returns\n hipSuccess,\n hipErrorInvalidHandle,\n hipErrorOutOfMemory,\n hipErrorMapFailed,\n"]
    pub unsafe fn hipIpcGetMemHandle(
        &self,
        handle: *mut hipIpcMemHandle_t,
        devPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipIpcGetMemHandle
            .as_ref()
            .expect("Expected function, got error."))(handle, devPtr)
    }
    #[doc = " @brief Opens an interprocess memory handle exported from another process\n          and returns a device pointer usable in the local process.\n\n Maps memory exported from another process with hipIpcGetMemHandle into\n the current device address space. For contexts on different devices\n hipIpcOpenMemHandle can attempt to enable peer access between the\n devices as if the user called hipDeviceEnablePeerAccess. This behavior is\n controlled by the hipIpcMemLazyEnablePeerAccess flag.\n hipDeviceCanAccessPeer can determine if a mapping is possible.\n\n Contexts that may open hipIpcMemHandles are restricted in the following way.\n hipIpcMemHandles from each device in a given process may only be opened\n by one context per device per other process.\n\n Memory returned from hipIpcOpenMemHandle must be freed with\n hipIpcCloseMemHandle.\n\n Calling hipFree on an exported memory region before calling\n hipIpcCloseMemHandle in the importing context will result in undefined\n behavior.\n\n @param devPtr - Returned device pointer\n @param handle - hipIpcMemHandle to open\n @param flags  - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess\n\n @returns\n hipSuccess,\n hipErrorMapFailed,\n hipErrorInvalidHandle,\n hipErrorTooManyPeers\n\n @note During multiple processes, using the same memory handle opened by the current context,\n there is no guarantee that the same device poiter will be returned in @p *devPtr.\n This is diffrent from CUDA.\n"]
    pub unsafe fn hipIpcOpenMemHandle(
        &self,
        devPtr: *mut *mut ::std::os::raw::c_void,
        handle: hipIpcMemHandle_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipIpcOpenMemHandle
            .as_ref()
            .expect("Expected function, got error."))(devPtr, handle, flags)
    }
    #[doc = " @brief Close memory mapped with hipIpcOpenMemHandle\n\n Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation\n in the exporting process as well as imported mappings in other processes\n will be unaffected.\n\n Any resources used to enable peer access will be freed if this is the\n last mapping using them.\n\n @param devPtr - Device pointer returned by hipIpcOpenMemHandle\n\n @returns\n hipSuccess,\n hipErrorMapFailed,\n hipErrorInvalidHandle,\n"]
    pub unsafe fn hipIpcCloseMemHandle(&self, devPtr: *mut ::std::os::raw::c_void) -> hipError_t {
        (self
            .hipIpcCloseMemHandle
            .as_ref()
            .expect("Expected function, got error."))(devPtr)
    }
    #[doc = " @brief Gets an opaque interprocess handle for an event.\n\n This opaque handle may be copied into other processes and opened with hipIpcOpenEventHandle.\n Then hipEventRecord, hipEventSynchronize, hipStreamWaitEvent and hipEventQuery may be used in\n either process. Operations on the imported event after the exported event has been freed with hipEventDestroy\n will result in undefined behavior.\n\n @param[out]  handle Pointer to hipIpcEventHandle to return the opaque event handle\n @param[in]   event  Event allocated with hipEventInterprocess and hipEventDisableTiming flags\n\n @returns #hipSuccess, #hipErrorInvalidConfiguration, #hipErrorInvalidValue\n"]
    pub unsafe fn hipIpcGetEventHandle(
        &self,
        handle: *mut hipIpcEventHandle_t,
        event: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipIpcGetEventHandle
            .as_ref()
            .expect("Expected function, got error."))(handle, event)
    }
    #[doc = " @brief Opens an interprocess event handles.\n\n Opens an interprocess event handle exported from another process with cudaIpcGetEventHandle. The returned\n hipEvent_t behaves like a locally created event with the hipEventDisableTiming flag specified. This event\n need be freed with hipEventDestroy. Operations on the imported event after the exported event has been freed\n with hipEventDestroy will result in undefined behavior. If the function is called within the same process where\n handle is returned by hipIpcGetEventHandle, it will return hipErrorInvalidContext.\n\n @param[out]  event  Pointer to hipEvent_t to return the event\n @param[in]   handle The opaque interprocess handle to open\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext\n"]
    pub unsafe fn hipIpcOpenEventHandle(
        &self,
        event: *mut hipEvent_t,
        handle: hipIpcEventHandle_t,
    ) -> hipError_t {
        (self
            .hipIpcOpenEventHandle
            .as_ref()
            .expect("Expected function, got error."))(event, handle)
    }
    #[doc = " @}\n/\n/**\n\n  @defgroup Execution Execution Control\n  @{\n  This section describes the execution control functions of HIP runtime API.\n\n/\n/**\n @brief Set attribute for a specific function\n\n @param [in] func;\n @param [in] attr;\n @param [in] value;\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub unsafe fn hipFuncSetAttribute(
        &self,
        func: *const ::std::os::raw::c_void,
        attr: hipFuncAttribute,
        value: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipFuncSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(func, attr, value)
    }
    #[doc = " @brief Set Cache configuration for a specific function\n\n @param [in] config;\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored\n on those architectures.\n"]
    pub unsafe fn hipFuncSetCacheConfig(
        &self,
        func: *const ::std::os::raw::c_void,
        config: hipFuncCache_t,
    ) -> hipError_t {
        (self
            .hipFuncSetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(func, config)
    }
    #[doc = " @brief Set shared memory configuation for a specific function\n\n @param [in] func\n @param [in] config\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub unsafe fn hipFuncSetSharedMemConfig(
        &self,
        func: *const ::std::os::raw::c_void,
        config: hipSharedMemConfig,
    ) -> hipError_t {
        (self
            .hipFuncSetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(func, config)
    }
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Error Error Handling\n  @{\n  This section describes the error handling functions of HIP runtime API.\n/\n/**\n @brief Return last error returned by any HIP runtime API call and resets the stored error code to\n #hipSuccess\n\n @returns return code from last HIP called from the active host thread\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread, and then resets the saved error to #hipSuccess.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub unsafe fn hipGetLastError(&self) -> hipError_t {
        (self
            .hipGetLastError
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " @brief Return last error returned by any HIP runtime API call.\n\n @return #hipSuccess\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread. Unlike hipGetLastError, this function does not reset the saved error code.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub unsafe fn hipPeekAtLastError(&self) -> hipError_t {
        (self
            .hipPeekAtLastError
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " @brief Return hip error as text string form.\n\n @param hip_error Error code to convert to name.\n @return const char pointer to the NULL-terminated error name\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub unsafe fn hipGetErrorName(&self, hip_error: hipError_t) -> *const ::std::os::raw::c_char {
        (self
            .hipGetErrorName
            .as_ref()
            .expect("Expected function, got error."))(hip_error)
    }
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param hipError Error code to convert to string.\n @return const char pointer to the NULL-terminated error string\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub unsafe fn hipGetErrorString(&self, hipError: hipError_t) -> *const ::std::os::raw::c_char {
        (self
            .hipGetErrorString
            .as_ref()
            .expect("Expected function, got error."))(hipError)
    }
    #[doc = " @brief Return hip error as text string form.\n\n @param [in] hipError Error code to convert to string.\n @param [out] const char pointer to the NULL-terminated error string\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub unsafe fn hipDrvGetErrorName(
        &self,
        hipError: hipError_t,
        errorString: *mut *const ::std::os::raw::c_char,
    ) -> hipError_t {
        (self
            .hipDrvGetErrorName
            .as_ref()
            .expect("Expected function, got error."))(hipError, errorString)
    }
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param [in] hipError Error code to convert to string.\n @param [out] const char pointer to the NULL-terminated error string\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub unsafe fn hipDrvGetErrorString(
        &self,
        hipError: hipError_t,
        errorString: *mut *const ::std::os::raw::c_char,
    ) -> hipError_t {
        (self
            .hipDrvGetErrorString
            .as_ref()
            .expect("Expected function, got error."))(hipError, errorString)
    }
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the\n newly created stream.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, applicaiton must call hipStreamDestroy.\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub unsafe fn hipStreamCreate(&self, stream: *mut hipStream_t) -> hipError_t {
        (self
            .hipStreamCreate
            .as_ref()
            .expect("Expected function, got error."))(stream)
    }
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, applicaiton must call hipStreamDestroy. Flags controls behavior of the\n stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub unsafe fn hipStreamCreateWithFlags(
        &self,
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamCreateWithFlags
            .as_ref()
            .expect("Expected function, got error."))(stream, flags)
    }
    #[doc = " @brief Create an asynchronous stream with the specified priority.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @param[in ] priority of the stream. Lower numbers represent higher priorities.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified priority.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, applicaiton must call hipStreamDestroy. Flags controls\n behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub unsafe fn hipStreamCreateWithPriority(
        &self,
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipStreamCreateWithPriority
            .as_ref()
            .expect("Expected function, got error."))(stream, flags, priority)
    }
    #[doc = " @brief Returns numerical values that correspond to the least and greatest stream priority.\n\n @param[in, out] leastPriority pointer in which value corresponding to least priority is returned.\n @param[in, out] greatestPriority pointer in which value corresponding to greatest priority is returned.\n\n Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least\n and greatest stream priority respectively. Stream priorities follow a convention where lower numbers\n imply greater priorities. The range of meaningful stream priorities is given by\n [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value\n that is outside the the meaningful range as specified by this API, the priority is automatically\n clamped to within the valid range."]
    pub unsafe fn hipDeviceGetStreamPriorityRange(
        &self,
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceGetStreamPriorityRange
            .as_ref()
            .expect("Expected function, got error."))(leastPriority, greatestPriority)
    }
    #[doc = " @brief Destroys the specified stream.\n\n @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the\n newly created stream.\n @return #hipSuccess #hipErrorInvalidHandle\n\n Destroys the specified stream.\n\n If commands are still executing on the specified stream, some may complete execution before the\n queue is deleted.\n\n The queue may be destroyed while some commands are still inflight, or may wait for all commands\n queued to the stream before destroying it.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery, hipStreamWaitEvent,\n hipStreamSynchronize"]
    pub unsafe fn hipStreamDestroy(&self, stream: hipStream_t) -> hipError_t {
        (self
            .hipStreamDestroy
            .as_ref()
            .expect("Expected function, got error."))(stream)
    }
    #[doc = " @brief Return #hipSuccess if all of the operations in the specified @p stream have completed, or\n #hipErrorNotReady if not.\n\n @param[in] stream stream to query\n\n @return #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle\n\n This is thread-safe and returns a snapshot of the current state of the queue.  However, if other\n host threads are sending work to the stream, the status may change immediately after the function\n is called.  It is typically used for debug.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamSynchronize,\n hipStreamDestroy"]
    pub unsafe fn hipStreamQuery(&self, stream: hipStream_t) -> hipError_t {
        (self
            .hipStreamQuery
            .as_ref()
            .expect("Expected function, got error."))(stream)
    }
    #[doc = " @brief Wait for all commands in stream to complete.\n\n @param[in] stream stream identifier.\n\n @return #hipSuccess, #hipErrorInvalidHandle\n\n This command is host-synchronous : the host will block until the specified stream is empty.\n\n This command follows standard null-stream semantics.  Specifically, specifying the null stream\n will cause the command to wait for other streams on the same device to complete all pending\n operations.\n\n This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active\n or blocking.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamDestroy\n"]
    pub unsafe fn hipStreamSynchronize(&self, stream: hipStream_t) -> hipError_t {
        (self
            .hipStreamSynchronize
            .as_ref()
            .expect("Expected function, got error."))(stream)
    }
    #[doc = " @brief Make the specified compute stream wait for an event\n\n @param[in] stream stream to make wait.\n @param[in] event event to wait on\n @param[in] flags control operation [must be 0]\n\n @return #hipSuccess, #hipErrorInvalidHandle\n\n This function inserts a wait operation into the specified stream.\n All future work submitted to @p stream will wait until @p event reports completion before\n beginning execution.\n\n This function only waits for commands in the current stream to complete.  Notably,, this function\n does not impliciy wait for commands in the default stream to complete, even if the specified\n stream is created with hipStreamNonBlocking = 0.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy"]
    pub unsafe fn hipStreamWaitEvent(
        &self,
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamWaitEvent
            .as_ref()
            .expect("Expected function, got error."))(stream, event, flags)
    }
    #[doc = " @brief Return flags associated with this stream.\n\n @param[in] stream stream to be queried\n @param[in,out] flags Pointer to an unsigned integer in which the stream's flags are returned\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Return flags associated with this stream in *@p flags.\n\n @see hipStreamCreateWithFlags"]
    pub unsafe fn hipStreamGetFlags(
        &self,
        stream: hipStream_t,
        flags: *mut ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamGetFlags
            .as_ref()
            .expect("Expected function, got error."))(stream, flags)
    }
    #[doc = " @brief Query the priority of a stream.\n\n @param[in] stream stream to be queried\n @param[in,out] priority Pointer to an unsigned integer in which the stream's priority is returned\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Query the priority of a stream. The priority is returned in in priority.\n\n @see hipStreamCreateWithFlags"]
    pub unsafe fn hipStreamGetPriority(
        &self,
        stream: hipStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipStreamGetPriority
            .as_ref()
            .expect("Expected function, got error."))(stream, priority)
    }
    #[doc = " @brief Create an asynchronous stream with the specified CU mask.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] cuMaskSize Size of CU mask bit array passed in.\n @param[in ] cuMask Bit-vector representing the CU mask. Each active bit represents using one CU.\n The first 32 bits represent the first 32 CUs, and so on. If its size is greater than physical\n CU number (i.e., multiProcessorCount member of hipDeviceProp_t), the extra elements are ignored.\n It is user's responsibility to make sure the input is meaningful.\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified CU mask.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, application must call hipStreamDestroy.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub unsafe fn hipExtStreamCreateWithCUMask(
        &self,
        stream: *mut hipStream_t,
        cuMaskSize: u32,
        cuMask: *const u32,
    ) -> hipError_t {
        (self
            .hipExtStreamCreateWithCUMask
            .as_ref()
            .expect("Expected function, got error."))(stream, cuMaskSize, cuMask)
    }
    #[doc = " @brief Get CU mask associated with an asynchronous stream\n\n @param[in] stream stream to be queried\n @param[in] cuMaskSize number of the block of memories (uint32_t *) allocated by user\n @param[out] cuMask Pointer to a pre-allocated block of memories (uint32_t *) in which\n the stream's CU mask is returned. The CU mask is returned in a chunck of 32 bits where\n each active bit represents one active CU\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub unsafe fn hipExtStreamGetCUMask(
        &self,
        stream: hipStream_t,
        cuMaskSize: u32,
        cuMask: *mut u32,
    ) -> hipError_t {
        (self
            .hipExtStreamGetCUMask
            .as_ref()
            .expect("Expected function, got error."))(stream, cuMaskSize, cuMask)
    }
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued\n items in the stream have completed.  For each\n hipStreamAddCallback call, a callback will be executed exactly once.\n The callback will block later work in the stream until it is finished.\n @param[in] stream   - Stream to add callback to\n @param[in] callback - The function to call once preceding stream operations are complete\n @param[in] userData - User specified data to be passed to the callback function\n @param[in] flags    - Reserved for future use, must be 0\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,\n hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority\n"]
    pub unsafe fn hipStreamAddCallback(
        &self,
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamAddCallback
            .as_ref()
            .expect("Expected function, got error."))(stream, callback, userData, flags)
    }
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup StreamM Stream Memory Operations\n  @{\n  This section describes Stream Memory Wait and Write functions of HIP runtime API.\n/\n/**\n @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte\n hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value,\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n hipStreamWaitValueGte: waits until *ptr&mask >= value\n hipStreamWaitValueEq : waits until *ptr&mask == value\n hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.\n\n @note Support for hipStreamWaitValue32 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue64, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub unsafe fn hipStreamWaitValue32(
        &self,
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u32,
        flags: ::std::os::raw::c_uint,
        mask: u32,
    ) -> hipError_t {
        (self
            .hipStreamWaitValue32
            .as_ref()
            .expect("Expected function, got error."))(stream, ptr, value, flags, mask)
    }
    #[doc = " @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte\n hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor.\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n hipStreamWaitValueGte: waits until *ptr&mask >= value\n hipStreamWaitValueEq : waits until *ptr&mask == value\n hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.\n\n @note Support for hipStreamWaitValue64 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue32, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub unsafe fn hipStreamWaitValue64(
        &self,
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u64,
        flags: ::std::os::raw::c_uint,
        mask: u64,
    ) -> hipError_t {
        (self
            .hipStreamWaitValue64
            .as_ref()
            .expect("Expected function, got error."))(stream, ptr, value, flags, mask)
    }
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub unsafe fn hipStreamWriteValue32(
        &self,
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u32,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamWriteValue32
            .as_ref()
            .expect("Expected function, got error."))(stream, ptr, value, flags)
    }
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @beta This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub unsafe fn hipStreamWriteValue64(
        &self,
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u64,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamWriteValue64
            .as_ref()
            .expect("Expected function, got error."))(stream, ptr, value, flags)
    }
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Event Event Management\n  @{\n  This section describes the event management functions of HIP runtime API.\n/\n/**\n @brief Create an event with the specified flags\n\n @param[in,out] event Returns the newly created event.\n @param[in] flags     Flags to control event behavior.  Valid values are #hipEventDefault,\n#hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess\n #hipEventDefault : Default flag.  The event will use active synchronization and will support\ntiming.  Blocking synchronization provides lowest possible latency at the expense of dedicating a\nCPU to poll on the event.\n #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is\ncalled on this event, the thread will block until the event completes.  This can increase latency\nfor the synchroniation but can result in lower power and more resources for other CPU threads.\n #hipEventDisableTiming : Disable recording of timing information. Events created with this flag\nwould not record profiling data and provide best performance if used for synchronization.\n #hipEventInterprocess : The event can be used as an interprocess event. hipEventDisableTiming\nflag also must be set when hipEventInterprocess flag is set.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n#hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime"]
    pub unsafe fn hipEventCreateWithFlags(
        &self,
        event: *mut hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipEventCreateWithFlags
            .as_ref()
            .expect("Expected function, got error."))(event, flags)
    }
    #[doc = "  Create an event\n\n @param[in,out] event Returns the newly created event.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,\n hipEventDestroy, hipEventElapsedTime"]
    pub unsafe fn hipEventCreate(&self, event: *mut hipEvent_t) -> hipError_t {
        (self
            .hipEventCreate
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    pub unsafe fn hipEventRecord(&self, event: hipEvent_t, stream: hipStream_t) -> hipError_t {
        (self
            .hipEventRecord
            .as_ref()
            .expect("Expected function, got error."))(event, stream)
    }
    #[doc = "  @brief Destroy the specified event.\n\n  @param[in] event Event to destroy.\n  @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure\n\n  Releases memory associated with the event.  If the event is recording but has not completed\n recording when hipEventDestroy() is called, the function will return immediately and the\n completion_future resources will be released later, when the hipDevice is synchronized.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,\n hipEventElapsedTime\n\n @returns #hipSuccess"]
    pub unsafe fn hipEventDestroy(&self, event: hipEvent_t) -> hipError_t {
        (self
            .hipEventDestroy
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    #[doc = "  @brief Wait for an event to complete.\n\n  This function will block until the event is ready, waiting for all previous work in the stream\n specified when event was recorded with hipEventRecord().\n\n  If hipEventRecord() has not been called on @p event, this function returns immediately.\n\n  TODO-hip- This function needs to support hipEventBlockingSync parameter.\n\n  @param[in] event Event on which to wait.\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorInvalidHandle, #hipErrorLaunchFailure\n\n  @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventElapsedTime"]
    pub unsafe fn hipEventSynchronize(&self, event: hipEvent_t) -> hipError_t {
        (self
            .hipEventSynchronize
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    #[doc = " @brief Return the elapsed time between two events.\n\n @param[out] ms : Return time between start and stop in ms.\n @param[in]   start : Start event.\n @param[in]   stop  : Stop event.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Computes the elapsed time between two events. Time is computed in ms, with\n a resolution of approximately 1 us.\n\n Events which are recorded in a NULL stream will block until all commands\n on all other streams complete execution, and then record the timestamp.\n\n Events which are recorded in a non-NULL stream will record their timestamp\n when they reach the head of the specified stream, after all previous\n commands in that stream have completed executing.  Thus the time that\n the event recorded may be significantly after the host calls hipEventRecord().\n\n If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is\n returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been\n recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at\n least one of the events), then #hipErrorNotReady is returned.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventSynchronize"]
    pub unsafe fn hipEventElapsedTime(
        &self,
        ms: *mut f32,
        start: hipEvent_t,
        stop: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipEventElapsedTime
            .as_ref()
            .expect("Expected function, got error."))(ms, start, stop)
    }
    #[doc = " @brief Query event status\n\n @param[in] event Event to query.\n @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Query the status of the specified event.  This function will return #hipSuccess if all\n commands in the appropriate stream (specified to hipEventRecord()) have completed.  If that work\n has not completed, or if hipEventRecord() was not called on the event, then #hipErrorNotReady is\n returned.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,\n hipEventSynchronize, hipEventElapsedTime"]
    pub unsafe fn hipEventQuery(&self, event: hipEvent_t) -> hipError_t {
        (self
            .hipEventQuery
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Memory Memory Management\n  @{\n  This section describes the memory management functions of HIP runtime API.\n  The following CUDA APIs are not currently supported:\n  - cudaMalloc3D\n  - cudaMalloc3DArray\n  - TODO - more 2D, 3D, array APIs here.\n\n\n/\n/**\n  @brief Return attributes for the specified pointer\n\n  @param [out]  attributes  attributes for the specified pointer\n  @param [in]   ptr         pointer to get attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see hipPointerGetAttribute"]
    pub unsafe fn hipPointerGetAttributes(
        &self,
        attributes: *mut hipPointerAttribute_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipPointerGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(attributes, ptr)
    }
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in, out] data     returned pointer attribute value\n  @param [in]      atribute attribute to query for\n  @param [in]      ptr      pointer to get attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @beta This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n\n  @see hipPointerGetAttributes"]
    pub unsafe fn hipPointerGetAttribute(
        &self,
        data: *mut ::std::os::raw::c_void,
        attribute: hipPointer_attribute,
        ptr: hipDeviceptr_t,
    ) -> hipError_t {
        (self
            .hipPointerGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(data, attribute, ptr)
    }
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in]  numAttributes   number of attributes to query for\n  @param [in]  attributes      attributes to query for\n  @param [in, out] data        a two-dimensional containing pointers to memory locations\n                               where the result of each attribute query will be written to\n  @param [in]  ptr             pointer to get attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @beta This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n\n  @see hipPointerGetAttribute"]
    pub unsafe fn hipDrvPointerGetAttributes(
        &self,
        numAttributes: ::std::os::raw::c_uint,
        attributes: *mut hipPointer_attribute,
        data: *mut *mut ::std::os::raw::c_void,
        ptr: hipDeviceptr_t,
    ) -> hipError_t {
        (self
            .hipDrvPointerGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(numAttributes, attributes, data, ptr)
    }
    #[doc = "  @brief Imports an external semaphore.\n\n  @param[out] extSem_out  External semaphores to be waited on\n  @param[in] semHandleDesc Semaphore import handle descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub unsafe fn hipImportExternalSemaphore(
        &self,
        extSem_out: *mut hipExternalSemaphore_t,
        semHandleDesc: *const hipExternalSemaphoreHandleDesc,
    ) -> hipError_t {
        (self
            .hipImportExternalSemaphore
            .as_ref()
            .expect("Expected function, got error."))(extSem_out, semHandleDesc)
    }
    #[doc = "  @brief Signals a set of external semaphore objects.\n\n  @param[in] extSem_out  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub unsafe fn hipSignalExternalSemaphoresAsync(
        &self,
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreSignalParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipSignalExternalSemaphoresAsync
            .as_ref()
            .expect("Expected function, got error."))(
            extSemArray, paramsArray, numExtSems, stream
        )
    }
    #[doc = "  @brief Waits on a set of external semaphore objects\n\n  @param[in] extSem_out  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub unsafe fn hipWaitExternalSemaphoresAsync(
        &self,
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreWaitParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipWaitExternalSemaphoresAsync
            .as_ref()
            .expect("Expected function, got error."))(
            extSemArray, paramsArray, numExtSems, stream
        )
    }
    #[doc = "  @brief Destroys an external semaphore object and releases any references to the underlying resource. Any outstanding signals or waits must have completed before the semaphore is destroyed.\n\n  @param[in] extSem handle to an external memory object\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub unsafe fn hipDestroyExternalSemaphore(&self, extSem: hipExternalSemaphore_t) -> hipError_t {
        (self
            .hipDestroyExternalSemaphore
            .as_ref()
            .expect("Expected function, got error."))(extSem)
    }
    #[doc = "  @brief Imports an external memory object.\n\n  @param[out] extMem_out  Returned handle to an external memory object\n  @param[in]  memHandleDesc Memory import handle descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub unsafe fn hipImportExternalMemory(
        &self,
        extMem_out: *mut hipExternalMemory_t,
        memHandleDesc: *const hipExternalMemoryHandleDesc,
    ) -> hipError_t {
        (self
            .hipImportExternalMemory
            .as_ref()
            .expect("Expected function, got error."))(extMem_out, memHandleDesc)
    }
    #[doc = "  @brief Maps a buffer onto an imported memory object.\n\n  @param[out] devPtr Returned device pointer to buffer\n  @param[in]  extMem  Handle to external memory object\n  @param[in]  bufferDesc  Buffer descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub unsafe fn hipExternalMemoryGetMappedBuffer(
        &self,
        devPtr: *mut *mut ::std::os::raw::c_void,
        extMem: hipExternalMemory_t,
        bufferDesc: *const hipExternalMemoryBufferDesc,
    ) -> hipError_t {
        (self
            .hipExternalMemoryGetMappedBuffer
            .as_ref()
            .expect("Expected function, got error."))(devPtr, extMem, bufferDesc)
    }
    #[doc = "  @brief Destroys an external memory object.\n\n  @param[in] extMem  External memory object to be destroyed\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub unsafe fn hipDestroyExternalMemory(&self, extMem: hipExternalMemory_t) -> hipError_t {
        (self
            .hipDestroyExternalMemory
            .as_ref()
            .expect("Expected function, got error."))(extMem)
    }
    #[doc = "  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr Pointer to the allocated memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hipHostMalloc"]
    pub unsafe fn hipMalloc(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> hipError_t {
        (self
            .hipMalloc
            .as_ref()
            .expect("Expected function, got error."))(ptr, size)
    }
    #[doc = "  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr Pointer to the allocated memory\n  @param[in]  size Requested memory size\n  @param[in]  flags Type of memory allocation\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hipHostMalloc"]
    pub unsafe fn hipExtMallocWithFlags(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipExtMallocWithFlags
            .as_ref()
            .expect("Expected function, got error."))(ptr, sizeBytes, flags)
    }
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @deprecated use hipHostMalloc() instead"]
    pub unsafe fn hipMallocHost(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> hipError_t {
        (self
            .hipMallocHost
            .as_ref()
            .expect("Expected function, got error."))(ptr, size)
    }
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @deprecated use hipHostMalloc() instead"]
    pub unsafe fn hipMemAllocHost(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> hipError_t {
        (self
            .hipMemAllocHost
            .as_ref()
            .expect("Expected function, got error."))(ptr, size)
    }
    #[doc = "  @brief Allocate device accessible page locked host memory\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n  @param[in]  flags Type of host memory allocation\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipSetDeviceFlags, hipHostFree"]
    pub unsafe fn hipHostMalloc(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipHostMalloc
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, flags)
    }
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @addtogroup MemoryM Managed Memory\n  @{\n  @ingroup Memory\n  This section describes the managed memory management functions of HIP runtime API.\n\n/\n/**\n @brief Allocates memory that will be automatically managed by HIP.\n\n @param [out] dev_ptr - pointer to allocated device memory\n @param [in]  size    - requested allocation size in bytes\n @param [in]  flags   - must be either hipMemAttachGlobal or hipMemAttachHost\n                        (defaults to hipMemAttachGlobal)\n\n @returns #hipSuccess, #hipErrorMemoryAllocation, #hipErrorNotSupported, #hipErrorInvalidValue"]
    pub unsafe fn hipMallocManaged(
        &self,
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMallocManaged
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, size, flags)
    }
    #[doc = " @brief Prefetches memory to the specified destination device using HIP.\n\n @param [in] dev_ptr  pointer to be prefetched\n @param [in] count    size in bytes for prefetching\n @param [in] device   destination device to prefetch to\n @param [in] stream   stream to enqueue prefetch operation\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipMemPrefetchAsync(
        &self,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        device: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemPrefetchAsync
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, count, device, stream)
    }
    #[doc = " @brief Advise about the usage of a given memory range to HIP.\n\n @param [in] dev_ptr  pointer to memory to set the advice for\n @param [in] count    size in bytes of the memory range\n @param [in] advice   advice to be applied for the specified memory range\n @param [in] device   device to apply the advice for\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipMemAdvise(
        &self,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        advice: hipMemoryAdvise,
        device: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipMemAdvise
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, count, advice, device)
    }
    #[doc = " @brief Query an attribute of a given memory range in HIP.\n\n @param [in,out] data   a pointer to a memory location where the result of each\n                        attribute query will be written to\n @param [in] data_size  the size of data\n @param [in] attribute  the attribute to query\n @param [in] dev_ptr    start of the range to query\n @param [in] count      size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipMemRangeGetAttribute(
        &self,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
        attribute: hipMemRangeAttribute,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemRangeGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(
            data, data_size, attribute, dev_ptr, count
        )
    }
    #[doc = " @brief Query attributes of a given memory range in HIP.\n\n @param [in,out] data     a two-dimensional array containing pointers to memory locations\n                          where the result of each attribute query will be written to\n @param [in] data_sizes   an array, containing the sizes of each result\n @param [in] attributes   the attribute to query\n @param [in] num_attributes  an array of attributes to query (numAttributes and the number\n                          of attributes in this array should match)\n @param [in] dev_ptr      start of the range to query\n @param [in] count        size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipMemRangeGetAttributes(
        &self,
        data: *mut *mut ::std::os::raw::c_void,
        data_sizes: *mut usize,
        attributes: *mut hipMemRangeAttribute,
        num_attributes: usize,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemRangeGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(
            data,
            data_sizes,
            attributes,
            num_attributes,
            dev_ptr,
            count,
        )
    }
    #[doc = " @brief Attach memory to a stream asynchronously in HIP.\n\n @param [in] stream     - stream in which to enqueue the attach operation\n @param [in] dev_ptr    - pointer to memory (must be a pointer to managed memory or\n                          to a valid host-accessible region of system-allocated memory)\n @param [in] length     - length of memory (defaults to zero)\n @param [in] flags      - must be one of hipMemAttachGlobal, hipMemAttachHost or\n                          hipMemAttachSingle (defaults to hipMemAttachSingle)\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipStreamAttachMemAsync(
        &self,
        stream: hipStream_t,
        dev_ptr: *mut ::std::os::raw::c_void,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamAttachMemAsync
            .as_ref()
            .expect("Expected function, got error."))(stream, dev_ptr, length, flags)
    }
    #[doc = " @brief Allocates memory with stream ordered semantics\n\n Inserts a memory allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the memory pool associated with the stream's device.\n\n @note The default memory pool of a device contains device memory from that device.\n @note Basic stream ordering allows future work submitted into the same stream to use the allocation.\n Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation\n operation completes before work submitted in a separate stream runs.\n @note During stream capture, this function results in the creation of an allocation node. In this case,\n the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n are used to set the node's creation parameters.\n\n @param [out] dev_ptr  Returned device pointer of memory allocation\n @param [in] size      Number of bytes to allocate\n @param [in] stream    The stream establishing the stream ordering contract and\n                       the memory pool to allocate from\n\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocFromPoolAsync, hipFreeAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMallocAsync(
        &self,
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMallocAsync
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, size, stream)
    }
    #[doc = " @brief Frees memory with stream ordered semantics\n\n Inserts a free operation into @p stream.\n The allocation must not be used after stream execution reaches the free.\n After this API returns, accessing the memory from any subsequent work launched on the GPU\n or querying its pointer attributes results in undefined behavior.\n\n @note During stream capture, this function results in the creation of a free node and\n must therefore be passed the address of a graph allocation.\n\n @param [in] dev_ptr Pointer to device memory to free\n @param [in] stream  The stream, where the destruciton will occur according to the execution order\n\n @returns hipSuccess, hipErrorInvalidValue, hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipFreeAsync(
        &self,
        dev_ptr: *mut ::std::os::raw::c_void,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipFreeAsync
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, stream)
    }
    #[doc = " @brief Releases freed memory back to the OS\n\n Releases memory back to the OS until the pool contains fewer than @p min_bytes_to_keep\n reserved bytes, or there is no more memory that the allocator can safely release.\n The allocator cannot release OS allocations that back outstanding asynchronous allocations.\n The OS allocations may happen at different granularity from the user allocations.\n\n @note: Allocations that have not been freed count as outstanding.\n @note: Allocations that have been asynchronously freed but whose completion has\n not been observed on the host (eg. by a synchronize) can count as outstanding.\n\n @param[in] mem_pool          The memory pool to trim allocations\n @param[in] min_bytes_to_hold If the pool has less than min_bytes_to_hold reserved,\n then the TrimTo operation is a no-op.  Otherwise the memory pool will contain\n at least min_bytes_to_hold bytes reserved after the operation.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolTrimTo(
        &self,
        mem_pool: hipMemPool_t,
        min_bytes_to_hold: usize,
    ) -> hipError_t {
        (self
            .hipMemPoolTrimTo
            .as_ref()
            .expect("Expected function, got error."))(mem_pool, min_bytes_to_hold)
    }
    #[doc = " @brief Sets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to modify\n @param [in] attr     The attribute to modify\n @param [in] value    Pointer to the value to assign\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolSetAttribute(
        &self,
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipMemPoolSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(mem_pool, attr, value)
    }
    #[doc = " @brief Gets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to get attributes of\n @param [in] attr     The attribute to get\n @param [in] value    Retrieved value\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolGetAttribute(
        &self,
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipMemPoolGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(mem_pool, attr, value)
    }
    #[doc = " @brief Controls visibility of the specified pool between devices\n\n @param [in] mem_pool   Memory pool for acccess change\n @param [in] desc_list  Array of access descriptors. Each descriptor instructs the access to enable for a single gpu\n @param [in] count  Number of descriptors in the map array.\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolSetAccess(
        &self,
        mem_pool: hipMemPool_t,
        desc_list: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemPoolSetAccess
            .as_ref()
            .expect("Expected function, got error."))(mem_pool, desc_list, count)
    }
    #[doc = " @brief Returns the accessibility of a pool from a device\n\n Returns the accessibility of the pool's memory from the specified location.\n\n @param [out] flags    Accessibility of the memory pool from the specified location/device\n @param [in] mem_pool   Memory pool being queried\n @param [in] location  Location/device for memory pool access\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolGetAccess(
        &self,
        flags: *mut hipMemAccessFlags,
        mem_pool: hipMemPool_t,
        location: *mut hipMemLocation,
    ) -> hipError_t {
        (self
            .hipMemPoolGetAccess
            .as_ref()
            .expect("Expected function, got error."))(flags, mem_pool, location)
    }
    #[doc = " @brief Creates a memory pool\n\n Creates a HIP memory pool and returns the handle in @p mem_pool. The @p pool_props determines\n the properties of the pool such as the backing device and IPC capabilities.\n\n By default, the memory pool will be accessible from the device it is allocated on.\n\n @param [out] mem_pool    Contains createed memory pool\n @param [in] pool_props   Memory pool properties\n\n @note Specifying hipMemHandleTypeNone creates a memory pool that will not support IPC.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolDestroy,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolCreate(
        &self,
        mem_pool: *mut hipMemPool_t,
        pool_props: *const hipMemPoolProps,
    ) -> hipError_t {
        (self
            .hipMemPoolCreate
            .as_ref()
            .expect("Expected function, got error."))(mem_pool, pool_props)
    }
    #[doc = " @brief Destroys the specified memory pool\n\n If any pointers obtained from this pool haven't been freed or\n the pool has free operations that haven't completed\n when @p hipMemPoolDestroy is invoked, the function will return immediately and the\n resources associated with the pool will be released automatically\n once there are no more outstanding allocations.\n\n Destroying the current mempool of a device sets the default mempool of\n that device as the current mempool for that device.\n\n @param [in] mem_pool Memory pool for destruction\n\n @note A device's default memory pool cannot be destroyed.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolDestroy(&self, mem_pool: hipMemPool_t) -> hipError_t {
        (self
            .hipMemPoolDestroy
            .as_ref()
            .expect("Expected function, got error."))(mem_pool)
    }
    #[doc = " @brief Allocates memory from a specified pool with stream ordered semantics.\n\n Inserts an allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in @p dev_ptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the specified memory pool.\n\n @note The specified memory pool may be from a device different than that of the specified @p stream.\n\n Basic stream ordering allows future work submitted into the same stream to use the allocation.\n Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation\n operation completes before work submitted in a separate stream runs.\n\n @note During stream capture, this function results in the creation of an allocation node. In this case,\n the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n are used to set the node's creation parameters.\n\n @param [out] dev_ptr Returned device pointer\n @param [in] size     Number of bytes to allocate\n @param [in] mem_pool The pool to allocate from\n @param [in] stream   The stream establishing the stream ordering semantic\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess,\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMallocFromPoolAsync(
        &self,
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        mem_pool: hipMemPool_t,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMallocFromPoolAsync
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, size, mem_pool, stream)
    }
    #[doc = " @brief Exports a memory pool to the requested handle type.\n\n Given an IPC capable mempool, create an OS handle to share the pool with another process.\n A recipient process can convert the shareable handle into a mempool with @p hipMemPoolImportFromShareableHandle.\n Individual pointers can then be shared with the @p hipMemPoolExportPointer and @p hipMemPoolImportPointer APIs.\n The implementation of what the shareable handle is and how it can be transferred is defined by the requested\n handle type.\n\n @note: To create an IPC capable mempool, create a mempool with a @p hipMemAllocationHandleType other\n than @p hipMemHandleTypeNone.\n\n @param [out] shared_handle Pointer to the location in which to store the requested handle\n @param [in] mem_pool       Pool to export\n @param [in] handle_type    The type of handle to create\n @param [in] flags          Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportFromShareableHandle\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolExportToShareableHandle(
        &self,
        shared_handle: *mut ::std::os::raw::c_void,
        mem_pool: hipMemPool_t,
        handle_type: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMemPoolExportToShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(
            shared_handle, mem_pool, handle_type, flags
        )
    }
    #[doc = " @brief Imports a memory pool from a shared handle.\n\n Specific allocations can be imported from the imported pool with @p hipMemPoolImportPointer.\n\n @note Imported memory pools do not support creating new allocations.\n As such imported memory pools may not be used in @p hipDeviceSetMemPool\n or @p hipMallocFromPoolAsync calls.\n\n @param [out] mem_pool     Returned memory pool\n @param [in] shared_handle OS handle of the pool to open\n @param [in] handle_type   The type of handle being imported\n @param [in] flags         Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolExportToShareableHandle\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolImportFromShareableHandle(
        &self,
        mem_pool: *mut hipMemPool_t,
        shared_handle: *mut ::std::os::raw::c_void,
        handle_type: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMemPoolImportFromShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(
            mem_pool, shared_handle, handle_type, flags
        )
    }
    #[doc = " @brief Export data to share a memory pool allocation between processes.\n\n Constructs @p export_data for sharing a specific allocation from an already shared memory pool.\n The recipient process can import the allocation with the @p hipMemPoolImportPointer api.\n The data is not a handle and may be shared through any IPC mechanism.\n\n @param[out] export_data  Returned export data\n @param[in] dev_ptr       Pointer to memory being exported\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportPointer\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolExportPointer(
        &self,
        export_data: *mut hipMemPoolPtrExportData,
        dev_ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipMemPoolExportPointer
            .as_ref()
            .expect("Expected function, got error."))(export_data, dev_ptr)
    }
    #[doc = " @brief Import a memory pool allocation from another process.\n\n Returns in @p dev_ptr a pointer to the imported memory.\n The imported memory must not be accessed before the allocation operation completes\n in the exporting process. The imported memory must be freed from all importing processes before\n being freed in the exporting process. The pointer may be freed with @p hipFree\n or @p hipFreeAsync. If @p hipFreeAsync is used, the free must be completed\n on the importing process before the free operation on the exporting process.\n\n @note The @p hipFreeAsync api may be used in the exporting process before\n the @p hipFreeAsync operation completes in its stream as long as the\n @p hipFreeAsync in the exporting process specifies a stream with\n a stream dependency on the importing process's @p hipFreeAsync.\n\n @param [out] dev_ptr     Pointer to imported memory\n @param [in] mem_pool     Memory pool from which to import a pointer\n @param [in] export_data  Data specifying the memory to import\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized, #hipErrorOutOfMemory\n\n @see hipMemPoolExportPointer\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemPoolImportPointer(
        &self,
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        mem_pool: hipMemPool_t,
        export_data: *mut hipMemPoolPtrExportData,
    ) -> hipError_t {
        (self
            .hipMemPoolImportPointer
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, mem_pool, export_data)
    }
    #[doc = "  @brief Allocate device accessible page locked host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n  @param[in]  flags Type of host memory allocation\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @deprecated use hipHostMalloc() instead"]
    pub unsafe fn hipHostAlloc(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipHostAlloc
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, flags)
    }
    #[doc = "  @brief Get Device pointer from Host Pointer allocated through hipHostMalloc\n\n  @param[out] dstPtr Device Pointer mapped to passed host pointer\n  @param[in]  hstPtr Host Pointer allocated through hipHostMalloc\n  @param[in]  flags Flags to be passed for extension\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n  @see hipSetDeviceFlags, hipHostMalloc"]
    pub unsafe fn hipHostGetDevicePointer(
        &self,
        devPtr: *mut *mut ::std::os::raw::c_void,
        hstPtr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipHostGetDevicePointer
            .as_ref()
            .expect("Expected function, got error."))(devPtr, hstPtr, flags)
    }
    #[doc = "  @brief Return flags associated with host pointer\n\n  @param[out] flagsPtr Memory location to store flags\n  @param[in]  hostPtr Host Pointer allocated through hipHostMalloc\n  @return #hipSuccess, #hipErrorInvalidValue\n\n  @see hipHostMalloc"]
    pub unsafe fn hipHostGetFlags(
        &self,
        flagsPtr: *mut ::std::os::raw::c_uint,
        hostPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipHostGetFlags
            .as_ref()
            .expect("Expected function, got error."))(flagsPtr, hostPtr)
    }
    #[doc = "  @brief Register host memory so it can be accessed from the current device.\n\n  @param[out] hostPtr Pointer to host memory to be registered.\n  @param[in] sizeBytes size of the host memory\n  @param[in] flags.  See below.\n\n  Flags:\n  - #hipHostRegisterDefault   Memory is Mapped and Portable\n  - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports\n one context so this is always assumed true.\n  - #hipHostRegisterMapped    Map the allocation into the address space for the current device.\n The device pointer can be obtained with #hipHostGetDevicePointer.\n\n\n  After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer.\n  On many systems, the mapped device pointer will have a different value than the mapped host\n pointer.  Applications must use the device pointer in device code, and the host pointer in device\n code.\n\n  On some systems, registered memory is pinned.  On some systems, registered memory may not be\n actually be pinned but uses OS or hardware facilities to all GPU access to the host memory.\n\n  Developers are strongly encouraged to register memory blocks which are aligned to the host\n cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction).\n\n  If registering non-aligned pointers, the application must take care when register pointers from\n the same cache line on different devices.  HIP's coarse-grained synchronization model does not\n guarantee correct results if different devices write to different parts of the same cache block -\n typically one of the writes will \"win\" and overwrite data from the other registered memory\n region.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer"]
    pub unsafe fn hipHostRegister(
        &self,
        hostPtr: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipHostRegister
            .as_ref()
            .expect("Expected function, got error."))(hostPtr, sizeBytes, flags)
    }
    #[doc = "  @brief Un-register host pointer\n\n  @param[in] hostPtr Host pointer previously registered with #hipHostRegister\n  @return Error code\n\n  @see hipHostRegister"]
    pub unsafe fn hipHostUnregister(&self, hostPtr: *mut ::std::os::raw::c_void) -> hipError_t {
        (self
            .hipHostUnregister
            .as_ref()
            .expect("Expected function, got error."))(hostPtr)
    }
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] ptr Pointer to the allocated device memory\n  @param[out] pitch Pitch for allocation (in bytes)\n  @param[in]  width Requested pitched allocation width (in bytes)\n  @param[in]  height Requested pitched allocation height\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @return Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub unsafe fn hipMallocPitch(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> hipError_t {
        (self
            .hipMallocPitch
            .as_ref()
            .expect("Expected function, got error."))(ptr, pitch, width, height)
    }
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] dptr Pointer to the allocated device memory\n  @param[out] pitch Pitch for allocation (in bytes)\n  @param[in]  width Requested pitched allocation width (in bytes)\n  @param[in]  height Requested pitched allocation height\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n  The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array.\n  Given the row and column of an array element of type T, the address is computed as:\n  T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;\n\n  @return Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub unsafe fn hipMemAllocPitch(
        &self,
        dptr: *mut hipDeviceptr_t,
        pitch: *mut usize,
        widthInBytes: usize,
        height: usize,
        elementSizeBytes: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMemAllocPitch
            .as_ref()
            .expect("Expected function, got error."))(
            dptr,
            pitch,
            widthInBytes,
            height,
            elementSizeBytes,
        )
    }
    #[doc = "  @brief Free memory allocated by the hcc hip memory allocation API.\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @return #hipSuccess\n  @return #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated\n with hipHostMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub unsafe fn hipFree(&self, ptr: *mut ::std::os::raw::c_void) -> hipError_t {
        (self
            .hipFree
            .as_ref()
            .expect("Expected function, got error."))(ptr)
    }
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API.  [Deprecated]\n\n  @param[in] ptr Pointer to memory to be freed\n  @return #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with\nhipMalloc)\n  @deprecated use hipHostFree() instead"]
    pub unsafe fn hipFreeHost(&self, ptr: *mut ::std::os::raw::c_void) -> hipError_t {
        (self
            .hipFreeHost
            .as_ref()
            .expect("Expected function, got error."))(ptr)
    }
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @return #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with\n hipMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub unsafe fn hipHostFree(&self, ptr: *mut ::std::os::raw::c_void) -> hipError_t {
        (self
            .hipHostFree
            .as_ref()
            .expect("Expected function, got error."))(ptr)
    }
    #[doc = "  @brief Copy data from src to dst.\n\n  It supports memory from host to device,\n  device to host, device to device and host to host\n  The src and dst must not overlap.\n\n  For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice).\n  For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the\n  device where the src data is physically located. For optimal peer-to-peer copies, the copy device\n  must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy\n  agent as the current device and src/dest as the peerDevice argument.  if this is not done, the\n  hipMemcpy will still work, but will perform the copy using a staging buffer on the host.\n  Calling hipMemcpy with dst and src pointers that do not match the hipMemcpyKind results in\n  undefined behavior.\n\n  @param[out]  dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  copyType Memory copy type\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknowni\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub unsafe fn hipMemcpy(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, kind)
    }
    pub unsafe fn hipMemcpyWithStream(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyWithStream
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, kind, stream)
    }
    #[doc = "  @brief Copy data from Host to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub unsafe fn hipMemcpyHtoD(
        &self,
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
    ) -> hipError_t {
        (self
            .hipMemcpyHtoD
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes)
    }
    #[doc = "  @brief Copy data from Device to Host\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub unsafe fn hipMemcpyDtoH(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t {
        (self
            .hipMemcpyDtoH
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes)
    }
    #[doc = "  @brief Copy data from Device to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub unsafe fn hipMemcpyDtoD(
        &self,
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t {
        (self
            .hipMemcpyDtoD
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes)
    }
    #[doc = "  @brief Copy data from Host to Device asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub unsafe fn hipMemcpyHtoDAsync(
        &self,
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyHtoDAsync
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, stream)
    }
    #[doc = "  @brief Copy data from Device to Host asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub unsafe fn hipMemcpyDtoHAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyDtoHAsync
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, stream)
    }
    #[doc = "  @brief Copy data from Device to Device asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub unsafe fn hipMemcpyDtoDAsync(
        &self,
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyDtoDAsync
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, stream)
    }
    #[doc = "  @brief Returns a global pointer from a module.\n  Returns in *dptr and *bytes the pointer and size of the global of name name located in module hmod.\n  If no variable of that name exists, it returns hipErrorNotFound. Both parameters dptr and bytes are optional.\n  If one of them is NULL, it is ignored and hipSuccess is returned.\n\n  @param[out]  dptr  Returns global device pointer\n  @param[out]  bytes Returns global size in bytes\n  @param[in]   hmod  Module to retrieve global from\n  @param[in]   name  Name of global to retrieve\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotFound, #hipErrorInvalidContext\n"]
    pub unsafe fn hipModuleGetGlobal(
        &self,
        dptr: *mut hipDeviceptr_t,
        bytes: *mut usize,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t {
        (self
            .hipModuleGetGlobal
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytes, hmod, name)
    }
    #[doc = "  @brief Gets device pointer associated with symbol on the device.\n\n  @param[out]  devPtr  pointer to the device associated the symbole\n  @param[in]   symbol  pointer to the symbole of the device\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub unsafe fn hipGetSymbolAddress(
        &self,
        devPtr: *mut *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipGetSymbolAddress
            .as_ref()
            .expect("Expected function, got error."))(devPtr, symbol)
    }
    #[doc = "  @brief Gets the size of the given symbol on the device.\n\n  @param[in]   symbol  pointer to the device symbole\n  @param[out]  size  pointer to the size\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub unsafe fn hipGetSymbolSize(
        &self,
        size: *mut usize,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipGetSymbolSize
            .as_ref()
            .expect("Expected function, got error."))(size, symbol)
    }
    #[doc = "  @brief Copies data to the given symbol on the device.\n Symbol HIP APIs allow a kernel to define a device-side data symbol which can be accessed on\n the host side. The symbol can be in __constant or device space.\n Note that the symbol name needs to be encased in the HIP_SYMBOL macro.\n This also applies to hipMemcpyFromSymbol, hipGetSymbolAddress, and hipGetSymbolSize.\n For detail usage, see the example at\n https://github.com/ROCm-Developer-Tools/HIP/blob/rocm-5.0.x/docs/markdown/hip_porting_guide.md\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub unsafe fn hipMemcpyToSymbol(
        &self,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpyToSymbol
            .as_ref()
            .expect("Expected function, got error."))(symbol, src, sizeBytes, offset, kind)
    }
    #[doc = "  @brief Copies data to the given symbol on the device asynchronously.\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub unsafe fn hipMemcpyToSymbolAsync(
        &self,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyToSymbolAsync
            .as_ref()
            .expect("Expected function, got error."))(
            symbol, src, sizeBytes, offset, kind, stream
        )
    }
    #[doc = "  @brief Copies data from the given symbol on the device.\n\n  @param[out]  dptr  Returns pointer to destinition memory address\n  @param[in]   symbol  pointer to the symbole address on the device\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from the start of symbole\n  @param[in]   kind  type of memory transfer\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub unsafe fn hipMemcpyFromSymbol(
        &self,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpyFromSymbol
            .as_ref()
            .expect("Expected function, got error."))(dst, symbol, sizeBytes, offset, kind)
    }
    #[doc = "  @brief Copies data from the given symbol on the device asynchronously.\n\n  @param[out]  dptr  Returns pointer to destinition memory address\n  @param[in]   symbol  pointer to the symbole address on the device\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from the start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub unsafe fn hipMemcpyFromSymbolAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyFromSymbolAsync
            .as_ref()
            .expect("Expected function, got error."))(
            dst, symbol, sizeBytes, offset, kind, stream
        )
    }
    #[doc = "  @brief Copy data from src to dst asynchronously.\n\n  @warning If host or dest are not pinned, the memory copy will be performed synchronously.  For\n best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously.\n\n  @warning on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies.\n  For hipMemcpy, the copy is always performed by the device associated with the specified stream.\n\n  For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a\n attached to the device where the src data is physically located. For optimal peer-to-peer copies,\n the copy device must be able to access the src and dst pointers (by calling\n hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice\n argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a\n staging buffer on the host.\n\n  @param[out] dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  accelerator_view Accelerator view which the copy is being enqueued\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,\n hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,\n hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,\n hipMemcpyFromSymbolAsync"]
    pub unsafe fn hipMemcpyAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyAsync
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, kind, stream)
    }
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dst Data being filled\n  @param[in]  constant value to be set\n  @param[in]  sizeBytes Data size in bytes\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub unsafe fn hipMemset(
        &self,
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t {
        (self
            .hipMemset
            .as_ref()
            .expect("Expected function, got error."))(dst, value, sizeBytes)
    }
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub unsafe fn hipMemsetD8(
        &self,
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemsetD8
            .as_ref()
            .expect("Expected function, got error."))(dest, value, count)
    }
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub unsafe fn hipMemsetD8Async(
        &self,
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemsetD8Async
            .as_ref()
            .expect("Expected function, got error."))(dest, value, count, stream)
    }
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub unsafe fn hipMemsetD16(
        &self,
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemsetD16
            .as_ref()
            .expect("Expected function, got error."))(dest, value, count)
    }
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Data ptr to be filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub unsafe fn hipMemsetD16Async(
        &self,
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemsetD16Async
            .as_ref()
            .expect("Expected function, got error."))(dest, value, count, stream)
    }
    #[doc = "  @brief Fills the memory area pointed to by dest with the constant integer\n value for specified number of times.\n\n  @param[out] dst Data being filled\n  @param[in]  constant value to be set\n  @param[in]  number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub unsafe fn hipMemsetD32(
        &self,
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemsetD32
            .as_ref()
            .expect("Expected function, got error."))(dest, value, count)
    }
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant\n byte value value.\n\n  hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value - Value to set for each byte of specified memory\n  @param[in]  sizeBytes - Size in bytes to set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub unsafe fn hipMemsetAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemsetAsync
            .as_ref()
            .expect("Expected function, got error."))(dst, value, sizeBytes, stream)
    }
    #[doc = "  @brief Fills the memory area pointed to by dev with the constant integer\n value for specified number of times.\n\n  hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value - Value to set for each byte of specified memory\n  @param[in]  count - number of values to be set\n  @param[in]  stream - Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub unsafe fn hipMemsetD32Async(
        &self,
        dst: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemsetD32Async
            .as_ref()
            .expect("Expected function, got error."))(dst, value, count, stream)
    }
    #[doc = "  @brief Fills the memory area pointed to by dst with the constant value.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  pitch - data size in bytes\n  @param[in]  value - constant value to be set\n  @param[in]  width\n  @param[in]  height\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub unsafe fn hipMemset2D(
        &self,
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t {
        (self
            .hipMemset2D
            .as_ref()
            .expect("Expected function, got error."))(dst, pitch, value, width, height)
    }
    #[doc = "  @brief Fills asynchronously the memory area pointed to by dst with the constant value.\n\n  @param[in]  dst Pointer to device memory\n  @param[in]  pitch - data size in bytes\n  @param[in]  value - constant value to be set\n  @param[in]  width\n  @param[in]  height\n  @param[in]  stream\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub unsafe fn hipMemset2DAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemset2DAsync
            .as_ref()
            .expect("Expected function, got error."))(
            dst, pitch, value, width, height, stream
        )
    }
    #[doc = "  @brief Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr\n  @param[in]  value - constant value to be set\n  @param[in]  extent\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub unsafe fn hipMemset3D(
        &self,
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
    ) -> hipError_t {
        (self
            .hipMemset3D
            .as_ref()
            .expect("Expected function, got error."))(pitchedDevPtr, value, extent)
    }
    #[doc = "  @brief Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr\n  @param[in]  value - constant value to be set\n  @param[in]  extent\n  @param[in]  stream\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub unsafe fn hipMemset3DAsync(
        &self,
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemset3DAsync
            .as_ref()
            .expect("Expected function, got error."))(pitchedDevPtr, value, extent, stream)
    }
    #[doc = " @brief Query memory info.\n Return snapshot of free memory, and total allocatable memory on the device.\n\n Returns in *free a snapshot of the current free memory.\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n @warning On HCC, the free memory only accounts for memory allocated by this process and may be\noptimistic."]
    pub unsafe fn hipMemGetInfo(&self, free: *mut usize, total: *mut usize) -> hipError_t {
        (self
            .hipMemGetInfo
            .as_ref()
            .expect("Expected function, got error."))(free, total)
    }
    pub unsafe fn hipMemPtrGetInfo(
        &self,
        ptr: *mut ::std::os::raw::c_void,
        size: *mut usize,
    ) -> hipError_t {
        (self
            .hipMemPtrGetInfo
            .as_ref()
            .expect("Expected function, got error."))(ptr, size)
    }
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   width  Requested array allocation width\n  @param[in]   height Requested array allocation height\n  @param[in]   flags  Requested properties of allocated array\n  @return      #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub unsafe fn hipMallocArray(
        &self,
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMallocArray
            .as_ref()
            .expect("Expected function, got error."))(array, desc, width, height, flags)
    }
    pub unsafe fn hipArrayCreate(
        &self,
        pHandle: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
    ) -> hipError_t {
        (self
            .hipArrayCreate
            .as_ref()
            .expect("Expected function, got error."))(pHandle, pAllocateArray)
    }
    pub unsafe fn hipArrayDestroy(&self, array: *mut hipArray) -> hipError_t {
        (self
            .hipArrayDestroy
            .as_ref()
            .expect("Expected function, got error."))(array)
    }
    pub unsafe fn hipArray3DCreate(
        &self,
        array: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
    ) -> hipError_t {
        (self
            .hipArray3DCreate
            .as_ref()
            .expect("Expected function, got error."))(array, pAllocateArray)
    }
    pub unsafe fn hipMalloc3D(
        &self,
        pitchedDevPtr: *mut hipPitchedPtr,
        extent: hipExtent,
    ) -> hipError_t {
        (self
            .hipMalloc3D
            .as_ref()
            .expect("Expected function, got error."))(pitchedDevPtr, extent)
    }
    #[doc = "  @brief Frees an array on the device.\n\n  @param[in]  array  Pointer to array to free\n  @return     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree"]
    pub unsafe fn hipFreeArray(&self, array: *mut hipArray) -> hipError_t {
        (self
            .hipFreeArray
            .as_ref()
            .expect("Expected function, got error."))(array)
    }
    #[doc = " @brief Frees a mipmapped array on the device\n\n @param[in] mipmappedArray - Pointer to mipmapped array to free\n\n @return #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipFreeMipmappedArray(&self, mipmappedArray: hipMipmappedArray_t) -> hipError_t {
        (self
            .hipFreeMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(mipmappedArray)
    }
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   extent Requested array allocation width, height and depth\n  @param[in]   flags  Requested properties of allocated array\n  @return      #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub unsafe fn hipMalloc3DArray(
        &self,
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMalloc3DArray
            .as_ref()
            .expect("Expected function, got error."))(array, desc, extent, flags)
    }
    #[doc = " @brief Allocate a mipmapped array on the device\n\n @param[out] mipmappedArray  - Pointer to allocated mipmapped array in device memory\n @param[in]  desc            - Requested channel format\n @param[in]  extent          - Requested allocation size (width field in elements)\n @param[in]  numLevels       - Number of mipmap levels to allocate\n @param[in]  flags           - Flags for extensions\n\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation"]
    pub unsafe fn hipMallocMipmappedArray(
        &self,
        mipmappedArray: *mut hipMipmappedArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        numLevels: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMallocMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(
            mipmappedArray,
            desc,
            extent,
            numLevels,
            flags,
        )
    }
    #[doc = " @brief Gets a mipmap level of a HIP mipmapped array\n\n @param[out] levelArray     - Returned mipmap level HIP array\n @param[in]  mipmappedArray - HIP mipmapped array\n @param[in]  level          - Mipmap level\n\n @return #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipGetMipmappedArrayLevel(
        &self,
        levelArray: *mut hipArray_t,
        mipmappedArray: hipMipmappedArray_const_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipGetMipmappedArrayLevel
            .as_ref()
            .expect("Expected function, got error."))(levelArray, mipmappedArray, level)
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy2D(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy2D
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, spitch, width, height, kind
        )
    }
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub unsafe fn hipMemcpyParam2D(&self, pCopy: *const hip_Memcpy2D) -> hipError_t {
        (self
            .hipMemcpyParam2D
            .as_ref()
            .expect("Expected function, got error."))(pCopy)
    }
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @param[in]   stream Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub unsafe fn hipMemcpyParam2DAsync(
        &self,
        pCopy: *const hip_Memcpy2D,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyParam2DAsync
            .as_ref()
            .expect("Expected function, got error."))(pCopy, stream)
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @param[in]   stream Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy2DAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy2DAsync
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, spitch, width, height, kind, stream,
        )
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy2DToArray(
        &self,
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy2DToArray
            .as_ref()
            .expect("Expected function, got error."))(
            dst, wOffset, hOffset, src, spitch, width, height, kind,
        )
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy2DToArrayAsync(
        &self,
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy2DToArrayAsync
            .as_ref()
            .expect("Expected function, got error."))(
            dst, wOffset, hOffset, src, spitch, width, height, kind, stream,
        )
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   count   size in bytes to copy\n  @param[in]   kind    Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpyToArray(
        &self,
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpyToArray
            .as_ref()
            .expect("Expected function, got error."))(
            dst, wOffset, hOffset, src, count, kind
        )
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source memory address\n  @param[in]   woffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   count     Size in bytes to copy\n  @param[in]   kind      Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpyFromArray(
        &self,
        dst: *mut ::std::os::raw::c_void,
        srcArray: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpyFromArray
            .as_ref()
            .expect("Expected function, got error."))(
            dst, srcArray, wOffset, hOffset, count, kind
        )
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy2DFromArray(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy2DFromArray
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, wOffset, hOffset, width, height, kind,
        )
    }
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy2DFromArrayAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy2DFromArrayAsync
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, wOffset, hOffset, width, height, kind, stream,
        )
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source array\n  @param[in]   srcoffset Offset in bytes of source array\n  @param[in]   count     Size of memory copy in bytes\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpyAtoH(
        &self,
        dst: *mut ::std::os::raw::c_void,
        srcArray: *mut hipArray,
        srcOffset: usize,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemcpyAtoH
            .as_ref()
            .expect("Expected function, got error."))(dst, srcArray, srcOffset, count)
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dstArray   Destination memory address\n  @param[in]   dstOffset  Offset in bytes of destination array\n  @param[in]   srcHost    Source host pointer\n  @param[in]   count      Size of memory copy in bytes\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpyHtoA(
        &self,
        dstArray: *mut hipArray,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemcpyHtoA
            .as_ref()
            .expect("Expected function, got error."))(dstArray, dstOffset, srcHost, count)
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   p   3D memory copy parameters\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy3D(&self, p: *const hipMemcpy3DParms) -> hipError_t {
        (self
            .hipMemcpy3D
            .as_ref()
            .expect("Expected function, got error."))(p)
    }
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   p        3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipMemcpy3DAsync(
        &self,
        p: *const hipMemcpy3DParms,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy3DAsync
            .as_ref()
            .expect("Expected function, got error."))(p, stream)
    }
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   pCopy   3D memory copy parameters\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipDrvMemcpy3D(&self, pCopy: *const HIP_MEMCPY3D) -> hipError_t {
        (self
            .hipDrvMemcpy3D
            .as_ref()
            .expect("Expected function, got error."))(pCopy)
    }
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   pCopy    3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub unsafe fn hipDrvMemcpy3DAsync(
        &self,
        pCopy: *const HIP_MEMCPY3D,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipDrvMemcpy3DAsync
            .as_ref()
            .expect("Expected function, got error."))(pCopy, stream)
    }
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup PeerToPeer PeerToPeer Device Memory Access\n  @{\n  @warning PeerToPeer support is experimental.\n  This section describes the PeerToPeer device memory access functions of HIP runtime API.\n/\n/**\n @brief Determine if a device can access a peer's memory.\n\n @param [out] canAccessPeer Returns the peer access capability (0 or 1)\n @param [in] device - device from where memory may be accessed.\n @param [in] peerDevice - device where memory is physically located\n\n Returns \"1\" in @p canAccessPeer if the specified @p device is capable\n of directly accessing memory physically located on peerDevice , or \"0\" if not.\n\n Returns \"0\" in @p canAccessPeer if deviceId == peerDeviceId, and both are valid devices : a\n device is not a peer of itself.\n\n @returns #hipSuccess,\n @returns #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices"]
    pub unsafe fn hipDeviceCanAccessPeer(
        &self,
        canAccessPeer: *mut ::std::os::raw::c_int,
        deviceId: ::std::os::raw::c_int,
        peerDeviceId: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceCanAccessPeer
            .as_ref()
            .expect("Expected function, got error."))(canAccessPeer, deviceId, peerDeviceId)
    }
    #[doc = " @brief Enable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerDeviceId\n @param [in] flags\n\n Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n @returns #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device."]
    pub unsafe fn hipDeviceEnablePeerAccess(
        &self,
        peerDeviceId: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipDeviceEnablePeerAccess
            .as_ref()
            .expect("Expected function, got error."))(peerDeviceId, flags)
    }
    #[doc = " @brief Disable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerDeviceId\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    pub unsafe fn hipDeviceDisablePeerAccess(
        &self,
        peerDeviceId: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDeviceDisablePeerAccess
            .as_ref()
            .expect("Expected function, got error."))(peerDeviceId)
    }
    #[doc = " @brief Get information on memory allocations.\n\n @param [out] pbase - BAse pointer address\n @param [out] psize - Size of allocation\n @param [in]  dptr- Device Pointer\n\n @returns #hipSuccess, #hipErrorInvalidDevicePointer\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipMemGetAddressRange(
        &self,
        pbase: *mut hipDeviceptr_t,
        psize: *mut usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t {
        (self
            .hipMemGetAddressRange
            .as_ref()
            .expect("Expected function, got error."))(pbase, psize, dptr)
    }
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDeviceId - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDeviceId - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub unsafe fn hipMemcpyPeer(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDeviceId: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t {
        (self
            .hipMemcpyPeer
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dstDeviceId, src, srcDeviceId, sizeBytes
        )
    }
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDevice - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDevice - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n @param [in] stream - Stream identifier\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub unsafe fn hipMemcpyPeerAsync(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyPeerAsync
            .as_ref()
            .expect("Expected function, got error."))(
            dst,
            dstDeviceId,
            src,
            srcDevice,
            sizeBytes,
            stream,
        )
    }
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Context Context Management\n  @{\n  This section describes the context management functions of HIP runtime API.\n/\n/**\n\n  @addtogroup ContextD Context Management [Deprecated]\n  @{\n  @ingroup Context\n  This section describes the deprecated context management functions of HIP runtime API.\n/\n/**\n @brief Create a context and set it as current/ default context\n\n @param [out] ctx\n @param [in] flags\n @param [in] associated device handle\n\n @return #hipSuccess\n\n @see hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,\n hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxCreate(
        &self,
        ctx: *mut hipCtx_t,
        flags: ::std::os::raw::c_uint,
        device: hipDevice_t,
    ) -> hipError_t {
        (self
            .hipCtxCreate
            .as_ref()
            .expect("Expected function, got error."))(ctx, flags, device)
    }
    #[doc = " @brief Destroy a HIP context.\n\n @param [in] ctx Context to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub unsafe fn hipCtxDestroy(&self, ctx: hipCtx_t) -> hipError_t {
        (self
            .hipCtxDestroy
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " @brief Pop the current/default context and return the popped context.\n\n @param [out] ctx\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxPopCurrent(&self, ctx: *mut hipCtx_t) -> hipError_t {
        (self
            .hipCtxPopCurrent
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " @brief Push the context to be set as current/ default context\n\n @param [in] ctx\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub unsafe fn hipCtxPushCurrent(&self, ctx: hipCtx_t) -> hipError_t {
        (self
            .hipCtxPushCurrent
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " @brief Set the passed context as current/default\n\n @param [in] ctx\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub unsafe fn hipCtxSetCurrent(&self, ctx: hipCtx_t) -> hipError_t {
        (self
            .hipCtxSetCurrent
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " @brief Get the handle of the current/ default context\n\n @param [out] ctx\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxGetCurrent(&self, ctx: *mut hipCtx_t) -> hipError_t {
        (self
            .hipCtxGetCurrent
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " @brief Get the handle of the device associated with current/default context\n\n @param [out] device\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize"]
    pub unsafe fn hipCtxGetDevice(&self, device: *mut hipDevice_t) -> hipError_t {
        (self
            .hipCtxGetDevice
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    #[doc = " @brief Returns the approximate HIP api version.\n\n @param [in]  ctx Context to check\n @param [out] apiVersion\n\n @return #hipSuccess\n\n @warning The HIP feature set does not correspond to an exact CUDA SDK api revision.\n This function always set *apiVersion to 4 as an approximation though HIP supports\n some features which were introduced in later CUDA SDK revisions.\n HIP apps code should not rely on the api revision number here and should\n use arch feature flags to test device capabilities or conditional compilation.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxGetApiVersion(
        &self,
        ctx: hipCtx_t,
        apiVersion: *mut ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipCtxGetApiVersion
            .as_ref()
            .expect("Expected function, got error."))(ctx, apiVersion)
    }
    #[doc = " @brief Set Cache configuration for a specific function\n\n @param [out] cacheConfiguration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxGetCacheConfig(&self, cacheConfig: *mut hipFuncCache_t) -> hipError_t {
        (self
            .hipCtxGetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(cacheConfig)
    }
    #[doc = " @brief Set L1/Shared cache partition.\n\n @param [in] cacheConfiguration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxSetCacheConfig(&self, cacheConfig: hipFuncCache_t) -> hipError_t {
        (self
            .hipCtxSetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(cacheConfig)
    }
    #[doc = " @brief Set Shared memory bank configuration.\n\n @param [in] sharedMemoryConfiguration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxSetSharedMemConfig(&self, config: hipSharedMemConfig) -> hipError_t {
        (self
            .hipCtxSetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(config)
    }
    #[doc = " @brief Get Shared memory bank configuration.\n\n @param [out] sharedMemoryConfiguration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxGetSharedMemConfig(&self, pConfig: *mut hipSharedMemConfig) -> hipError_t {
        (self
            .hipCtxGetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(pConfig)
    }
    #[doc = " @brief Blocks until the default context has completed all preceding requested tasks.\n\n @return #hipSuccess\n\n @warning This function waits for all streams on the default context to complete execution, and\n then returns.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice"]
    pub unsafe fn hipCtxSynchronize(&self) -> hipError_t {
        (self
            .hipCtxSynchronize
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " @brief Return flags used for creating default context.\n\n @param [out] flags\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipCtxGetFlags(&self, flags: *mut ::std::os::raw::c_uint) -> hipError_t {
        (self
            .hipCtxGetFlags
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    #[doc = " @brief Enables direct access to memory allocations in a peer context.\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerCtx\n @param [in] flags\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n #hipErrorPeerAccessAlreadyEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental."]
    pub unsafe fn hipCtxEnablePeerAccess(
        &self,
        peerCtx: hipCtx_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipCtxEnablePeerAccess
            .as_ref()
            .expect("Expected function, got error."))(peerCtx, flags)
    }
    #[doc = " @brief Disable direct access from current context's virtual address space to memory allocations\n physically located on a peer context.Disables direct access to memory allocations in a peer\n context and unregisters any registered allocations.\n\n Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerCtx\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental."]
    pub unsafe fn hipCtxDisablePeerAccess(&self, peerCtx: hipCtx_t) -> hipError_t {
        (self
            .hipCtxDisablePeerAccess
            .as_ref()
            .expect("Expected function, got error."))(peerCtx)
    }
    #[doc = " @}\n/\n/**\n @brief Get the state of the primary context.\n\n @param [in] Device to get primary context flags for\n @param [out] Pointer to store flags\n @param [out] Pointer to store context state; 0 = inactive, 1 = active\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipDevicePrimaryCtxGetState(
        &self,
        dev: hipDevice_t,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipDevicePrimaryCtxGetState
            .as_ref()
            .expect("Expected function, got error."))(dev, flags, active)
    }
    #[doc = " @brief Release the primary context on the GPU.\n\n @param [in] Device which primary context is released\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning This function return #hipSuccess though doesn't release the primaryCtx by design on\n HIP/HCC path."]
    pub unsafe fn hipDevicePrimaryCtxRelease(&self, dev: hipDevice_t) -> hipError_t {
        (self
            .hipDevicePrimaryCtxRelease
            .as_ref()
            .expect("Expected function, got error."))(dev)
    }
    #[doc = " @brief Retain the primary context on the GPU.\n\n @param [out] Returned context handle of the new context\n @param [in] Device which primary context is released\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipDevicePrimaryCtxRetain(
        &self,
        pctx: *mut hipCtx_t,
        dev: hipDevice_t,
    ) -> hipError_t {
        (self
            .hipDevicePrimaryCtxRetain
            .as_ref()
            .expect("Expected function, got error."))(pctx, dev)
    }
    #[doc = " @brief Resets the primary context on the GPU.\n\n @param [in] Device which primary context is reset\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipDevicePrimaryCtxReset(&self, dev: hipDevice_t) -> hipError_t {
        (self
            .hipDevicePrimaryCtxReset
            .as_ref()
            .expect("Expected function, got error."))(dev)
    }
    #[doc = " @brief Set flags for the primary context.\n\n @param [in] Device for which the primary context flags are set\n @param [in] New flags for the device\n\n @returns #hipSuccess, #hipErrorContextAlreadyInUse\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub unsafe fn hipDevicePrimaryCtxSetFlags(
        &self,
        dev: hipDevice_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipDevicePrimaryCtxSetFlags
            .as_ref()
            .expect("Expected function, got error."))(dev, flags)
    }
    #[doc = " @}\n/\n/**\n\n  @defgroup Module Module Management\n  @{\n  This section describes the module management functions of HIP runtime API.\n\n/\n/**\n @brief Loads code object from file into a hipModule_t\n\n @param [in] fname\n @param [out] module\n\n @warning File/memory resources allocated in this function are released only in hipModuleUnload.\n\n @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorFileNotFound,\n hipErrorOutOfMemory, hipErrorSharedObjectInitFailed, hipErrorNotInitialized\n\n"]
    pub unsafe fn hipModuleLoad(
        &self,
        module: *mut hipModule_t,
        fname: *const ::std::os::raw::c_char,
    ) -> hipError_t {
        (self
            .hipModuleLoad
            .as_ref()
            .expect("Expected function, got error."))(module, fname)
    }
    #[doc = " @brief Frees the module\n\n @param [in] module\n\n @returns hipSuccess, hipInvalidValue\n module is freed and the code objects associated with it are destroyed\n"]
    pub unsafe fn hipModuleUnload(&self, module: hipModule_t) -> hipError_t {
        (self
            .hipModuleUnload
            .as_ref()
            .expect("Expected function, got error."))(module)
    }
    #[doc = " @brief Function with kname will be extracted if present in module\n\n @param [in] module\n @param [in] kname\n @param [out] function\n\n @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorNotInitialized,\n hipErrorNotFound,"]
    pub unsafe fn hipModuleGetFunction(
        &self,
        function: *mut hipFunction_t,
        module: hipModule_t,
        kname: *const ::std::os::raw::c_char,
    ) -> hipError_t {
        (self
            .hipModuleGetFunction
            .as_ref()
            .expect("Expected function, got error."))(function, module, kname)
    }
    #[doc = " @brief Find out attributes for a given function.\n\n @param [out] attr\n @param [in] func\n\n @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub unsafe fn hipFuncGetAttributes(
        &self,
        attr: *mut hipFuncAttributes,
        func: *const ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipFuncGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(attr, func)
    }
    #[doc = " @brief Find out a specific attribute for a given function.\n\n @param [out] value\n @param [in]  attrib\n @param [in]  hfunc\n\n @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub unsafe fn hipFuncGetAttribute(
        &self,
        value: *mut ::std::os::raw::c_int,
        attrib: hipFunction_attribute,
        hfunc: hipFunction_t,
    ) -> hipError_t {
        (self
            .hipFuncGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(value, attrib, hfunc)
    }
    #[doc = " @brief returns the handle of the texture reference with the name from the module.\n\n @param [in] hmod\n @param [in] name\n @param [out] texRef\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorNotFound, hipErrorInvalidValue"]
    pub unsafe fn hipModuleGetTexRef(
        &self,
        texRef: *mut *mut textureReference,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t {
        (self
            .hipModuleGetTexRef
            .as_ref()
            .expect("Expected function, got error."))(texRef, hmod, name)
    }
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location.\n\n @param [in] image\n @param [out] module\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub unsafe fn hipModuleLoadData(
        &self,
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipModuleLoadData
            .as_ref()
            .expect("Expected function, got error."))(module, image)
    }
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location. Options are not used. hipModuleLoadData is called.\n\n @param [in] image\n @param [out] module\n @param [in] number of options\n @param [in] options for JIT\n @param [in] option values for JIT\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub unsafe fn hipModuleLoadDataEx(
        &self,
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipModuleLoadDataEx
            .as_ref()
            .expect("Expected function, got error."))(
            module,
            image,
            numOptions,
            options,
            optionValues,
        )
    }
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra\n\n @param [in] f         Kernel to launch.\n @param [in] gridDimX  X grid dimension specified as multiple of blockDimX.\n @param [in] gridDimY  Y grid dimension specified as multiple of blockDimY.\n @param [in] gridDimZ  Z grid dimension specified as multiple of blockDimZ.\n @param [in] blockDimX X block dimensions specified in work-items\n @param [in] blockDimY Y grid dimension specified in work-items\n @param [in] blockDimZ Z grid dimension specified in work-items\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n @param [in] kernelParams\n @param [in] extra     Pointer to kernel arguments.   These are passed directly to the kernel and\n must be in the memory layout and alignment expected by the kernel.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32. So gridDim.x * blockDim.x, gridDim.y * blockDim.y\n and gridDim.z * blockDim.z are always less than 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n\n @warning kernellParams argument is not yet implemented in HIP. Please use extra instead. Please\n refer to hip_porting_driver_api.md for sample usage."]
    pub unsafe fn hipModuleLaunchKernel(
        &self,
        f: hipFunction_t,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipModuleLaunchKernel
            .as_ref()
            .expect("Expected function, got error."))(
            f,
            gridDimX,
            gridDimY,
            gridDimZ,
            blockDimX,
            blockDimY,
            blockDimZ,
            sharedMemBytes,
            stream,
            kernelParams,
            extra,
        )
    }
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra, where thread blocks can cooperate and synchronize as they execute\n\n @param [in] f         Kernel to launch.\n @param [in] gridDim   Grid dimensions specified as multiple of blockDim.\n @param [in] blockDim  Block dimensions specified in work-items\n @param [in] kernelParams A list of kernel arguments\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge"]
    pub unsafe fn hipLaunchCooperativeKernel(
        &self,
        f: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDimX: dim3,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipLaunchCooperativeKernel
            .as_ref()
            .expect("Expected function, got error."))(
            f,
            gridDim,
            blockDimX,
            kernelParams,
            sharedMemBytes,
            stream,
        )
    }
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and\n synchronize as they execute.\n\n @param [in] launchParamsList         List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge"]
    pub unsafe fn hipLaunchCooperativeKernelMultiDevice(
        &self,
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipLaunchCooperativeKernelMultiDevice
            .as_ref()
            .expect("Expected function, got error."))(launchParamsList, numDevices, flags)
    }
    #[doc = " @brief Launches kernels on multiple devices and guarantees all specified kernels are dispatched\n on respective streams before enqueuing any other work on the specified streams from any other threads\n\n\n @param [in] hipLaunchParams          List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    pub unsafe fn hipExtLaunchMultiKernelMultiDevice(
        &self,
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipExtLaunchMultiKernelMultiDevice
            .as_ref()
            .expect("Expected function, got error."))(launchParamsList, numDevices, flags)
    }
    #[doc = " @}\n/\n/**\n\n  @defgroup Occupancy Occupancy\n  @{\n  This section describes the occupancy functions of HIP runtime API.\n\n/\n/**\n @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub unsafe fn hipModuleOccupancyMaxPotentialBlockSize(
        &self,
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipModuleOccupancyMaxPotentialBlockSize
            .as_ref()
            .expect("Expected function, got error."))(
            gridSize,
            blockSize,
            f,
            dynSharedMemPerBlk,
            blockSizeLimit,
        )
    }
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub unsafe fn hipModuleOccupancyMaxPotentialBlockSizeWithFlags(
        &self,
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipModuleOccupancyMaxPotentialBlockSizeWithFlags
            .as_ref()
            .expect("Expected function, got error."))(
            gridSize,
            blockSize,
            f,
            dynSharedMemPerBlk,
            blockSizeLimit,
            flags,
        )
    }
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  func             Kernel function (hipFunction) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub unsafe fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(
        &self,
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t {
        (self
            .hipModuleOccupancyMaxActiveBlocksPerMultiprocessor
            .as_ref()
            .expect("Expected function, got error."))(
            numBlocks, f, blockSize, dynSharedMemPerBlk
        )
    }
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function(hipFunction_t) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)"]
    pub unsafe fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        &self,
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
            .as_ref()
            .expect("Expected function, got error."))(
            numBlocks,
            f,
            blockSize,
            dynSharedMemPerBlk,
            flags,
        )
    }
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  func             Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub unsafe fn hipOccupancyMaxActiveBlocksPerMultiprocessor(
        &self,
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t {
        (self
            .hipOccupancyMaxActiveBlocksPerMultiprocessor
            .as_ref()
            .expect("Expected function, got error."))(
            numBlocks, f, blockSize, dynSharedMemPerBlk
        )
    }
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (currently ignored)"]
    pub unsafe fn hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        &self,
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
            .as_ref()
            .expect("Expected function, got error."))(
            numBlocks,
            f,
            blockSize,
            dynSharedMemPerBlk,
            flags,
        )
    }
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub unsafe fn hipOccupancyMaxPotentialBlockSize(
        &self,
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipOccupancyMaxPotentialBlockSize
            .as_ref()
            .expect("Expected function, got error."))(
            gridSize,
            blockSize,
            f,
            dynSharedMemPerBlk,
            blockSizeLimit,
        )
    }
    #[doc = " @brief Start recording of profiling information\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @warning : hipProfilerStart API is under development."]
    pub unsafe fn hipProfilerStart(&self) -> hipError_t {
        (self
            .hipProfilerStart
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " @brief Stop recording of profiling information.\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @warning : hipProfilerStop API is under development."]
    pub unsafe fn hipProfilerStop(&self) -> hipError_t {
        (self
            .hipProfilerStop
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Clang Launch API to support the triple-chevron syntax\n  @{\n  This section describes the API to support the triple-chevron syntax.\n/\n/**\n @brief Configure a kernel launch.\n\n @param [in] gridDim   grid dimension specified as multiple of blockDim.\n @param [in] blockDim  block dimensions specified in work-items\n @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n"]
    pub unsafe fn hipConfigureCall(
        &self,
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipConfigureCall
            .as_ref()
            .expect("Expected function, got error."))(gridDim, blockDim, sharedMem, stream)
    }
    #[doc = " @brief Set a kernel argument.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n\n @param [in] arg    Pointer the argument in host memory.\n @param [in] size   Size of the argument.\n @param [in] offset Offset of the argument on the argument stack.\n"]
    pub unsafe fn hipSetupArgument(
        &self,
        arg: *const ::std::os::raw::c_void,
        size: usize,
        offset: usize,
    ) -> hipError_t {
        (self
            .hipSetupArgument
            .as_ref()
            .expect("Expected function, got error."))(arg, size, offset)
    }
    #[doc = " @brief Launch a kernel.\n\n @param [in] func Kernel to launch.\n\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue\n"]
    pub unsafe fn hipLaunchByPtr(&self, func: *const ::std::os::raw::c_void) -> hipError_t {
        (self
            .hipLaunchByPtr
            .as_ref()
            .expect("Expected function, got error."))(func)
    }
    #[doc = " @brief C compliant kernel launch API\n\n @param [in] function_address - kernel stub function pointer.\n @param [in] numBlocks - number of blocks\n @param [in] dimBlocks - dimension of a block\n @param [in] args - kernel arguments\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th\n  default stream is used with associated synchronization rules.\n\n @returns #hipSuccess, #hipErrorInvalidValue, hipInvalidDevice\n"]
    pub unsafe fn hipLaunchKernel(
        &self,
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipLaunchKernel
            .as_ref()
            .expect("Expected function, got error."))(
            function_address,
            numBlocks,
            dimBlocks,
            args,
            sharedMemBytes,
            stream,
        )
    }
    #[doc = " @brief Enqueues a host function call in a stream.\n\n @param [in] stream - stream to enqueue work to.\n @param [in] fn - function to call once operations enqueued preceeding are complete.\n @param [in] userData - User-specified data to be passed to the function.\n @returns #hipSuccess, #hipErrorInvalidResourceHandle, #hipErrorInvalidValue,\n #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipLaunchHostFunc(
        &self,
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipLaunchHostFunc
            .as_ref()
            .expect("Expected function, got error."))(stream, fn_, userData)
    }
    #[doc = " Copies memory for 2D arrays.\n\n @param pCopy           - Parameters for the memory copy\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub unsafe fn hipDrvMemcpy2DUnaligned(&self, pCopy: *const hip_Memcpy2D) -> hipError_t {
        (self
            .hipDrvMemcpy2DUnaligned
            .as_ref()
            .expect("Expected function, got error."))(pCopy)
    }
    #[doc = " @brief Launches kernel from the pointer address, with arguments and shared memory on stream.\n\n @param [in] function_address pointer to the Kernel to launch.\n @param [in] numBlocks number of blocks.\n @param [in] dimBlocks dimension of a block.\n @param [in] args pointer to kernel arguments.\n @param [in] sharedMemBytes  Amount of dynamic shared memory to allocate for this kernel.\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream  Stream where the kernel should be dispatched.\n @param [in] startEvent  If non-null, specified event will be updated to track the start time of\n the kernel launch. The event must be created before calling this API.\n @param [in] stopEvent  If non-null, specified event will be updated to track the stop time of\n the kernel launch. The event must be created before calling this API.\n May be 0, in which case the default stream is used with associated synchronization rules.\n @param [in] flags. The value of hipExtAnyOrderLaunch, signifies if kernel can be\n launched in any order.\n @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue.\n"]
    pub unsafe fn hipExtLaunchKernel(
        &self,
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
        startEvent: hipEvent_t,
        stopEvent: hipEvent_t,
        flags: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipExtLaunchKernel
            .as_ref()
            .expect("Expected function, got error."))(
            function_address,
            numBlocks,
            dimBlocks,
            args,
            sharedMemBytes,
            stream,
            startEvent,
            stopEvent,
            flags,
        )
    }
    #[doc = " @brief  Binds a mipmapped array to a texture.\n\n @param [in] tex  pointer to the texture reference to bind\n @param [in] mipmappedArray  memory mipmapped array on the device\n @param [in] desc  opointer to the channel format\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipBindTextureToMipmappedArray(
        &self,
        tex: *const textureReference,
        mipmappedArray: hipMipmappedArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t {
        (self
            .hipBindTextureToMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(tex, mipmappedArray, desc)
    }
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to the texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns hipSuccess, hipErrorInvalidValue, hipErrorNotSupported, hipErrorOutOfMemory\n\n @note 3D liner filter isn't supported on GFX90A boards, on which the API @p hipCreateTextureObject will\n return hipErrorNotSupported.\n"]
    pub unsafe fn hipCreateTextureObject(
        &self,
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const hipResourceDesc,
        pTexDesc: *const hipTextureDesc,
        pResViewDesc: *const hipResourceViewDesc,
    ) -> hipError_t {
        (self
            .hipCreateTextureObject
            .as_ref()
            .expect("Expected function, got error."))(
            pTexObject, pResDesc, pTexDesc, pResViewDesc
        )
    }
    #[doc = " @brief Destroys a texture object.\n\n @param [in] textureObject  texture object to destroy\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipDestroyTextureObject(&self, textureObject: hipTextureObject_t) -> hipError_t {
        (self
            .hipDestroyTextureObject
            .as_ref()
            .expect("Expected function, got error."))(textureObject)
    }
    #[doc = " @brief Gets the channel descriptor in an array.\n\n @param [in] desc  pointer to channel format descriptor\n @param [out] array  memory array on the device\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipGetChannelDesc(
        &self,
        desc: *mut hipChannelFormatDesc,
        array: hipArray_const_t,
    ) -> hipError_t {
        (self
            .hipGetChannelDesc
            .as_ref()
            .expect("Expected function, got error."))(desc, array)
    }
    #[doc = " @brief Gets resource descriptor for the texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] textureObject  texture object\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipGetTextureObjectResourceDesc(
        &self,
        pResDesc: *mut hipResourceDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t {
        (self
            .hipGetTextureObjectResourceDesc
            .as_ref()
            .expect("Expected function, got error."))(pResDesc, textureObject)
    }
    #[doc = " @brief Gets resource view descriptor for the texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] textureObject  texture object\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipGetTextureObjectResourceViewDesc(
        &self,
        pResViewDesc: *mut hipResourceViewDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t {
        (self
            .hipGetTextureObjectResourceViewDesc
            .as_ref()
            .expect("Expected function, got error."))(pResViewDesc, textureObject)
    }
    #[doc = " @brief Gets texture descriptor for the texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] textureObject  texture object\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipGetTextureObjectTextureDesc(
        &self,
        pTexDesc: *mut hipTextureDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t {
        (self
            .hipGetTextureObjectTextureDesc
            .as_ref()
            .expect("Expected function, got error."))(pTexDesc, textureObject)
    }
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipTexObjectCreate(
        &self,
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const HIP_RESOURCE_DESC,
        pTexDesc: *const HIP_TEXTURE_DESC,
        pResViewDesc: *const HIP_RESOURCE_VIEW_DESC,
    ) -> hipError_t {
        (self
            .hipTexObjectCreate
            .as_ref()
            .expect("Expected function, got error."))(
            pTexObject, pResDesc, pTexDesc, pResViewDesc
        )
    }
    #[doc = " @brief Destroys a texture object.\n\n @param [in] texObject  texture object to destroy\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipTexObjectDestroy(&self, texObject: hipTextureObject_t) -> hipError_t {
        (self
            .hipTexObjectDestroy
            .as_ref()
            .expect("Expected function, got error."))(texObject)
    }
    #[doc = " @brief Gets resource descriptor of a texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] texObject  texture object\n\n @returns hipSuccess, hipErrorNotSupported, hipErrorInvalidValue\n"]
    pub unsafe fn hipTexObjectGetResourceDesc(
        &self,
        pResDesc: *mut HIP_RESOURCE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t {
        (self
            .hipTexObjectGetResourceDesc
            .as_ref()
            .expect("Expected function, got error."))(pResDesc, texObject)
    }
    #[doc = " @brief Gets resource view descriptor of a texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] texObject  texture object\n\n @returns hipSuccess, hipErrorNotSupported, hipErrorInvalidValue\n"]
    pub unsafe fn hipTexObjectGetResourceViewDesc(
        &self,
        pResViewDesc: *mut HIP_RESOURCE_VIEW_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t {
        (self
            .hipTexObjectGetResourceViewDesc
            .as_ref()
            .expect("Expected function, got error."))(pResViewDesc, texObject)
    }
    #[doc = " @brief Gets texture descriptor of a texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] texObject  texture object\n\n @returns hipSuccess, hipErrorNotSupported, hipErrorInvalidValue\n"]
    pub unsafe fn hipTexObjectGetTextureDesc(
        &self,
        pTexDesc: *mut HIP_TEXTURE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t {
        (self
            .hipTexObjectGetTextureDesc
            .as_ref()
            .expect("Expected function, got error."))(pTexDesc, texObject)
    }
    #[doc = "  @addtogroup TextureD Texture Management [Deprecated]\n  @{\n  @ingroup Texture\n  This section describes the deprecated texture management functions of HIP runtime API.\n/\n/**\n @brief Gets the texture reference related with the symbol.\n\n @param [out] texref  texture reference\n @param [in] symbol  pointer to the symbol related with the texture for the reference\n\n @returns hipSuccess, hipErrorInvalidValue\n"]
    pub unsafe fn hipGetTextureReference(
        &self,
        texref: *mut *const textureReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipGetTextureReference
            .as_ref()
            .expect("Expected function, got error."))(texref, symbol)
    }
    pub unsafe fn hipTexRefSetAddressMode(
        &self,
        texRef: *mut textureReference,
        dim: ::std::os::raw::c_int,
        am: hipTextureAddressMode,
    ) -> hipError_t {
        (self
            .hipTexRefSetAddressMode
            .as_ref()
            .expect("Expected function, got error."))(texRef, dim, am)
    }
    pub unsafe fn hipTexRefSetArray(
        &self,
        tex: *mut textureReference,
        array: hipArray_const_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipTexRefSetArray
            .as_ref()
            .expect("Expected function, got error."))(tex, array, flags)
    }
    pub unsafe fn hipTexRefSetFilterMode(
        &self,
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t {
        (self
            .hipTexRefSetFilterMode
            .as_ref()
            .expect("Expected function, got error."))(texRef, fm)
    }
    pub unsafe fn hipTexRefSetFlags(
        &self,
        texRef: *mut textureReference,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipTexRefSetFlags
            .as_ref()
            .expect("Expected function, got error."))(texRef, Flags)
    }
    pub unsafe fn hipTexRefSetFormat(
        &self,
        texRef: *mut textureReference,
        fmt: hipArray_Format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipTexRefSetFormat
            .as_ref()
            .expect("Expected function, got error."))(texRef, fmt, NumPackedComponents)
    }
    pub unsafe fn hipBindTexture(
        &self,
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        size: usize,
    ) -> hipError_t {
        (self
            .hipBindTexture
            .as_ref()
            .expect("Expected function, got error."))(offset, tex, devPtr, desc, size)
    }
    pub unsafe fn hipBindTexture2D(
        &self,
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        pitch: usize,
    ) -> hipError_t {
        (self
            .hipBindTexture2D
            .as_ref()
            .expect("Expected function, got error."))(
            offset, tex, devPtr, desc, width, height, pitch,
        )
    }
    pub unsafe fn hipBindTextureToArray(
        &self,
        tex: *const textureReference,
        array: hipArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t {
        (self
            .hipBindTextureToArray
            .as_ref()
            .expect("Expected function, got error."))(tex, array, desc)
    }
    pub unsafe fn hipGetTextureAlignmentOffset(
        &self,
        offset: *mut usize,
        texref: *const textureReference,
    ) -> hipError_t {
        (self
            .hipGetTextureAlignmentOffset
            .as_ref()
            .expect("Expected function, got error."))(offset, texref)
    }
    pub unsafe fn hipUnbindTexture(&self, tex: *const textureReference) -> hipError_t {
        (self
            .hipUnbindTexture
            .as_ref()
            .expect("Expected function, got error."))(tex)
    }
    pub unsafe fn hipTexRefGetAddress(
        &self,
        dev_ptr: *mut hipDeviceptr_t,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetAddress
            .as_ref()
            .expect("Expected function, got error."))(dev_ptr, texRef)
    }
    pub unsafe fn hipTexRefGetAddressMode(
        &self,
        pam: *mut hipTextureAddressMode,
        texRef: *const textureReference,
        dim: ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipTexRefGetAddressMode
            .as_ref()
            .expect("Expected function, got error."))(pam, texRef, dim)
    }
    pub unsafe fn hipTexRefGetFilterMode(
        &self,
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetFilterMode
            .as_ref()
            .expect("Expected function, got error."))(pfm, texRef)
    }
    pub unsafe fn hipTexRefGetFlags(
        &self,
        pFlags: *mut ::std::os::raw::c_uint,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetFlags
            .as_ref()
            .expect("Expected function, got error."))(pFlags, texRef)
    }
    pub unsafe fn hipTexRefGetFormat(
        &self,
        pFormat: *mut hipArray_Format,
        pNumChannels: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetFormat
            .as_ref()
            .expect("Expected function, got error."))(pFormat, pNumChannels, texRef)
    }
    pub unsafe fn hipTexRefGetMaxAnisotropy(
        &self,
        pmaxAnsio: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetMaxAnisotropy
            .as_ref()
            .expect("Expected function, got error."))(pmaxAnsio, texRef)
    }
    pub unsafe fn hipTexRefGetMipmapFilterMode(
        &self,
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetMipmapFilterMode
            .as_ref()
            .expect("Expected function, got error."))(pfm, texRef)
    }
    pub unsafe fn hipTexRefGetMipmapLevelBias(
        &self,
        pbias: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetMipmapLevelBias
            .as_ref()
            .expect("Expected function, got error."))(pbias, texRef)
    }
    pub unsafe fn hipTexRefGetMipmapLevelClamp(
        &self,
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetMipmapLevelClamp
            .as_ref()
            .expect("Expected function, got error."))(
            pminMipmapLevelClamp,
            pmaxMipmapLevelClamp,
            texRef,
        )
    }
    pub unsafe fn hipTexRefGetMipMappedArray(
        &self,
        pArray: *mut hipMipmappedArray_t,
        texRef: *const textureReference,
    ) -> hipError_t {
        (self
            .hipTexRefGetMipMappedArray
            .as_ref()
            .expect("Expected function, got error."))(pArray, texRef)
    }
    pub unsafe fn hipTexRefSetAddress(
        &self,
        ByteOffset: *mut usize,
        texRef: *mut textureReference,
        dptr: hipDeviceptr_t,
        bytes: usize,
    ) -> hipError_t {
        (self
            .hipTexRefSetAddress
            .as_ref()
            .expect("Expected function, got error."))(ByteOffset, texRef, dptr, bytes)
    }
    pub unsafe fn hipTexRefSetAddress2D(
        &self,
        texRef: *mut textureReference,
        desc: *const HIP_ARRAY_DESCRIPTOR,
        dptr: hipDeviceptr_t,
        Pitch: usize,
    ) -> hipError_t {
        (self
            .hipTexRefSetAddress2D
            .as_ref()
            .expect("Expected function, got error."))(texRef, desc, dptr, Pitch)
    }
    pub unsafe fn hipTexRefSetMaxAnisotropy(
        &self,
        texRef: *mut textureReference,
        maxAniso: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipTexRefSetMaxAnisotropy
            .as_ref()
            .expect("Expected function, got error."))(texRef, maxAniso)
    }
    pub unsafe fn hipTexRefSetBorderColor(
        &self,
        texRef: *mut textureReference,
        pBorderColor: *mut f32,
    ) -> hipError_t {
        (self
            .hipTexRefSetBorderColor
            .as_ref()
            .expect("Expected function, got error."))(texRef, pBorderColor)
    }
    pub unsafe fn hipTexRefSetMipmapFilterMode(
        &self,
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t {
        (self
            .hipTexRefSetMipmapFilterMode
            .as_ref()
            .expect("Expected function, got error."))(texRef, fm)
    }
    pub unsafe fn hipTexRefSetMipmapLevelBias(
        &self,
        texRef: *mut textureReference,
        bias: f32,
    ) -> hipError_t {
        (self
            .hipTexRefSetMipmapLevelBias
            .as_ref()
            .expect("Expected function, got error."))(texRef, bias)
    }
    pub unsafe fn hipTexRefSetMipmapLevelClamp(
        &self,
        texRef: *mut textureReference,
        minMipMapLevelClamp: f32,
        maxMipMapLevelClamp: f32,
    ) -> hipError_t {
        (self
            .hipTexRefSetMipmapLevelClamp
            .as_ref()
            .expect("Expected function, got error."))(
            texRef,
            minMipMapLevelClamp,
            maxMipMapLevelClamp,
        )
    }
    pub unsafe fn hipTexRefSetMipmappedArray(
        &self,
        texRef: *mut textureReference,
        mipmappedArray: *mut hipMipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipTexRefSetMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(texRef, mipmappedArray, Flags)
    }
    #[doc = "  @addtogroup TextureU Texture Management [Not supported]\n  @{\n  @ingroup Texture\n  This section describes the texture management functions currently unsupported in HIP runtime."]
    pub unsafe fn hipMipmappedArrayCreate(
        &self,
        pHandle: *mut hipMipmappedArray_t,
        pMipmappedArrayDesc: *mut HIP_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMipmappedArrayCreate
            .as_ref()
            .expect("Expected function, got error."))(
            pHandle, pMipmappedArrayDesc, numMipmapLevels
        )
    }
    pub unsafe fn hipMipmappedArrayDestroy(
        &self,
        hMipmappedArray: hipMipmappedArray_t,
    ) -> hipError_t {
        (self
            .hipMipmappedArrayDestroy
            .as_ref()
            .expect("Expected function, got error."))(hMipmappedArray)
    }
    pub unsafe fn hipMipmappedArrayGetLevel(
        &self,
        pLevelArray: *mut hipArray_t,
        hMipMappedArray: hipMipmappedArray_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipMipmappedArrayGetLevel
            .as_ref()
            .expect("Expected function, got error."))(pLevelArray, hMipMappedArray, level)
    }
    #[doc = "  @defgroup Callback Callback Activity APIs\n  @{\n  This section describes the callback/Activity of HIP runtime API."]
    pub unsafe fn hipApiName(&self, id: u32) -> *const ::std::os::raw::c_char {
        (self
            .hipApiName
            .as_ref()
            .expect("Expected function, got error."))(id)
    }
    pub unsafe fn hipKernelNameRef(&self, f: hipFunction_t) -> *const ::std::os::raw::c_char {
        (self
            .hipKernelNameRef
            .as_ref()
            .expect("Expected function, got error."))(f)
    }
    pub unsafe fn hipKernelNameRefByPtr(
        &self,
        hostFunction: *const ::std::os::raw::c_void,
        stream: hipStream_t,
    ) -> *const ::std::os::raw::c_char {
        (self
            .hipKernelNameRefByPtr
            .as_ref()
            .expect("Expected function, got error."))(hostFunction, stream)
    }
    pub unsafe fn hipGetStreamDeviceId(&self, stream: hipStream_t) -> ::std::os::raw::c_int {
        (self
            .hipGetStreamDeviceId
            .as_ref()
            .expect("Expected function, got error."))(stream)
    }
    #[doc = " @brief Begins graph capture on a stream.\n\n @param [in] stream - Stream to initiate capture.\n @param [in] mode - Controls the interaction of this capture sequence with other API calls that\n are not safe.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipStreamBeginCapture(
        &self,
        stream: hipStream_t,
        mode: hipStreamCaptureMode,
    ) -> hipError_t {
        (self
            .hipStreamBeginCapture
            .as_ref()
            .expect("Expected function, got error."))(stream, mode)
    }
    #[doc = " @brief Ends capture on a stream, returning the captured graph.\n\n @param [in] stream - Stream to end capture.\n @param [out] pGraph - returns the graph captured.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipStreamEndCapture(
        &self,
        stream: hipStream_t,
        pGraph: *mut hipGraph_t,
    ) -> hipError_t {
        (self
            .hipStreamEndCapture
            .as_ref()
            .expect("Expected function, got error."))(stream, pGraph)
    }
    #[doc = " @brief Get capture status of a stream.\n\n @param [in] stream - Stream under capture.\n @param [out] pCaptureStatus - returns current status of the capture.\n @param [out] pId - unique ID of the capture.\n\n @returns #hipSuccess, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipStreamGetCaptureInfo(
        &self,
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> hipError_t {
        (self
            .hipStreamGetCaptureInfo
            .as_ref()
            .expect("Expected function, got error."))(stream, pCaptureStatus, pId)
    }
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream under capture.\n @param [out] captureStatus_out - returns current status of the capture.\n @param [out] id_out - unique ID of the capture.\n @param [in] graph_out - returns the graph being captured into.\n @param [out] dependencies_out - returns pointer to an array of nodes.\n @param [out] numDependencies_out - returns size of the array returned in dependencies_out.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipStreamGetCaptureInfo_v2(
        &self,
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t {
        (self
            .hipStreamGetCaptureInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(
            stream,
            captureStatus_out,
            id_out,
            graph_out,
            dependencies_out,
            numDependencies_out,
        )
    }
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream under capture.\n @param [out] pCaptureStatus - returns current status of the capture.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipStreamIsCapturing(
        &self,
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t {
        (self
            .hipStreamIsCapturing
            .as_ref()
            .expect("Expected function, got error."))(stream, pCaptureStatus)
    }
    #[doc = " @brief Update the set of dependencies in a capturing stream\n\n @param [in] stream - Stream under capture.\n @param [in] dependencies - pointer to an array of nodes to Add/Replace.\n @param [in] numDependencies - size of the array in dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorIllegalState\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipStreamUpdateCaptureDependencies(
        &self,
        stream: hipStream_t,
        dependencies: *mut hipGraphNode_t,
        numDependencies: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamUpdateCaptureDependencies
            .as_ref()
            .expect("Expected function, got error."))(
            stream, dependencies, numDependencies, flags
        )
    }
    #[doc = " @brief Swaps the stream capture mode of a thread.\n\n @param [in] mode - Pointer to mode value to swap with the current mode\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipThreadExchangeStreamCaptureMode(
        &self,
        mode: *mut hipStreamCaptureMode,
    ) -> hipError_t {
        (self
            .hipThreadExchangeStreamCaptureMode
            .as_ref()
            .expect("Expected function, got error."))(mode)
    }
    #[doc = " @brief Creates a graph\n\n @param [out] pGraph - pointer to graph to create.\n @param [in] flags - flags for graph creation, must be 0.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphCreate(
        &self,
        pGraph: *mut hipGraph_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipGraphCreate
            .as_ref()
            .expect("Expected function, got error."))(pGraph, flags)
    }
    #[doc = " @brief Destroys a graph\n\n @param [in] graph - instance of graph to destroy.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphDestroy(&self, graph: hipGraph_t) -> hipError_t {
        (self
            .hipGraphDestroy
            .as_ref()
            .expect("Expected function, got error."))(graph)
    }
    #[doc = " @brief Adds dependency edges to a graph.\n\n @param [in] graph - instance of the graph to add dependencies.\n @param [in] from - pointer to the graph nodes with dependenties to add from.\n @param [in] to - pointer to the graph nodes to add dependenties to.\n @param [in] numDependencies - the number of dependencies to add.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphAddDependencies(
        &self,
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t {
        (self
            .hipGraphAddDependencies
            .as_ref()
            .expect("Expected function, got error."))(graph, from, to, numDependencies)
    }
    #[doc = " @brief Removes dependency edges from a graph.\n\n @param [in] graph - instance of the graph to remove dependencies.\n @param [in] from - Array of nodes that provide the dependencies.\n @param [in] to - Array of dependent nodes.\n @param [in] numDependencies - the number of dependencies to remove.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphRemoveDependencies(
        &self,
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t {
        (self
            .hipGraphRemoveDependencies
            .as_ref()
            .expect("Expected function, got error."))(graph, from, to, numDependencies)
    }
    #[doc = " @brief Returns a graph's dependency edges.\n\n @param [in] graph - instance of the graph to get the edges from.\n @param [out] from - pointer to the graph nodes to return edge endpoints.\n @param [out] to - pointer to the graph nodes to return edge endpoints.\n @param [out] numEdges - returns number of edges.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n from and to may both be NULL, in which case this function only returns the number of edges in\n numEdges. Otherwise, numEdges entries will be filled in. If numEdges is higher than the actual\n number of edges, the remaining entries in from and to will be set to NULL, and the number of\n edges actually returned will be written to numEdges\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphGetEdges(
        &self,
        graph: hipGraph_t,
        from: *mut hipGraphNode_t,
        to: *mut hipGraphNode_t,
        numEdges: *mut usize,
    ) -> hipError_t {
        (self
            .hipGraphGetEdges
            .as_ref()
            .expect("Expected function, got error."))(graph, from, to, numEdges)
    }
    #[doc = " @brief Returns graph nodes.\n\n @param [in] graph - instance of graph to get the nodes.\n @param [out] nodes - pointer to return the  graph nodes.\n @param [out] numNodes - returns number of graph nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n nodes may be NULL, in which case this function will return the number of nodes in numNodes.\n Otherwise, numNodes entries will be filled in. If numNodes is higher than the actual number of\n nodes, the remaining entries in nodes will be set to NULL, and the number of nodes actually\n obtained will be returned in numNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphGetNodes(
        &self,
        graph: hipGraph_t,
        nodes: *mut hipGraphNode_t,
        numNodes: *mut usize,
    ) -> hipError_t {
        (self
            .hipGraphGetNodes
            .as_ref()
            .expect("Expected function, got error."))(graph, nodes, numNodes)
    }
    #[doc = " @brief Returns graph's root nodes.\n\n @param [in] graph - instance of the graph to get the nodes.\n @param [out] pRootNodes - pointer to return the graph's root nodes.\n @param [out] pNumRootNodes - returns the number of graph's root nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pRootNodes may be NULL, in which case this function will return the number of root nodes in\n pNumRootNodes. Otherwise, pNumRootNodes entries will be filled in. If pNumRootNodes is higher\n than the actual number of root nodes, the remaining entries in pRootNodes will be set to NULL,\n and the number of nodes actually obtained will be returned in pNumRootNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphGetRootNodes(
        &self,
        graph: hipGraph_t,
        pRootNodes: *mut hipGraphNode_t,
        pNumRootNodes: *mut usize,
    ) -> hipError_t {
        (self
            .hipGraphGetRootNodes
            .as_ref()
            .expect("Expected function, got error."))(graph, pRootNodes, pNumRootNodes)
    }
    #[doc = " @brief Returns a node's dependencies.\n\n @param [in] node - graph node to get the dependencies from.\n @param [out] pDependencies - pointer to to return the dependencies.\n @param [out] pNumDependencies -  returns the number of graph node dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pDependencies may be NULL, in which case this function will return the number of dependencies in\n pNumDependencies. Otherwise, pNumDependencies entries will be filled in. If pNumDependencies is\n higher than the actual number of dependencies, the remaining entries in pDependencies will be set\n to NULL, and the number of nodes actually obtained will be returned in pNumDependencies.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphNodeGetDependencies(
        &self,
        node: hipGraphNode_t,
        pDependencies: *mut hipGraphNode_t,
        pNumDependencies: *mut usize,
    ) -> hipError_t {
        (self
            .hipGraphNodeGetDependencies
            .as_ref()
            .expect("Expected function, got error."))(node, pDependencies, pNumDependencies)
    }
    #[doc = " @brief Returns a node's dependent nodes.\n\n @param [in] node - graph node to get the Dependent nodes from.\n @param [out] pDependentNodes - pointer to return the graph dependent nodes.\n @param [out] pNumDependentNodes - returns the number of graph node dependent nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n DependentNodes may be NULL, in which case this function will return the number of dependent nodes\n in pNumDependentNodes. Otherwise, pNumDependentNodes entries will be filled in. If\n pNumDependentNodes is higher than the actual number of dependent nodes, the remaining entries in\n pDependentNodes will be set to NULL, and the number of nodes actually obtained will be returned\n in pNumDependentNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphNodeGetDependentNodes(
        &self,
        node: hipGraphNode_t,
        pDependentNodes: *mut hipGraphNode_t,
        pNumDependentNodes: *mut usize,
    ) -> hipError_t {
        (self
            .hipGraphNodeGetDependentNodes
            .as_ref()
            .expect("Expected function, got error."))(
            node, pDependentNodes, pNumDependentNodes
        )
    }
    #[doc = " @brief Returns a node's type.\n\n @param [in] node - instance of the graph to add dependencies.\n @param [out] pType - pointer to the return the type\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphNodeGetType(
        &self,
        node: hipGraphNode_t,
        pType: *mut hipGraphNodeType,
    ) -> hipError_t {
        (self
            .hipGraphNodeGetType
            .as_ref()
            .expect("Expected function, got error."))(node, pType)
    }
    #[doc = " @brief Remove a node from the graph.\n\n @param [in] node - graph node to remove\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphDestroyNode(&self, node: hipGraphNode_t) -> hipError_t {
        (self
            .hipGraphDestroyNode
            .as_ref()
            .expect("Expected function, got error."))(node)
    }
    #[doc = " @brief Clones a graph.\n\n @param [out] pGraphClone - Returns newly created cloned graph.\n @param [in] originalGraph - original graph to clone from.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphClone(
        &self,
        pGraphClone: *mut hipGraph_t,
        originalGraph: hipGraph_t,
    ) -> hipError_t {
        (self
            .hipGraphClone
            .as_ref()
            .expect("Expected function, got error."))(pGraphClone, originalGraph)
    }
    #[doc = " @brief Finds a cloned version of a node.\n\n @param [out] pNode - Returns the cloned node.\n @param [in] originalNode - original node handle.\n @param [in] clonedGraph - Cloned graph to query.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphNodeFindInClone(
        &self,
        pNode: *mut hipGraphNode_t,
        originalNode: hipGraphNode_t,
        clonedGraph: hipGraph_t,
    ) -> hipError_t {
        (self
            .hipGraphNodeFindInClone
            .as_ref()
            .expect("Expected function, got error."))(pNode, originalNode, clonedGraph)
    }
    #[doc = " @brief Creates an executable graph from a graph\n\n @param [out] pGraphExec - pointer to instantiated executable graph that is created.\n @param [in] graph - instance of graph to instantiate.\n @param [out] pErrorNode - pointer to error node in case error occured in graph instantiation,\n  it could modify the correponding node.\n @param [out] pLogBuffer - pointer to log buffer.\n @param [out] bufferSize - the size of log buffer.\n\n @returns #hipSuccess, #hipErrorOutOfMemory\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphInstantiate(
        &self,
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        pErrorNode: *mut hipGraphNode_t,
        pLogBuffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> hipError_t {
        (self
            .hipGraphInstantiate
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphExec, graph, pErrorNode, pLogBuffer, bufferSize,
        )
    }
    #[doc = " @brief Creates an executable graph from a graph.\n\n @param [out] pGraphExec - pointer to instantiated executable graph that is created.\n @param [in] graph - instance of graph to instantiate.\n @param [in] flags - Flags to control instantiation.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub unsafe fn hipGraphInstantiateWithFlags(
        &self,
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t {
        (self
            .hipGraphInstantiateWithFlags
            .as_ref()
            .expect("Expected function, got error."))(pGraphExec, graph, flags)
    }
    #[doc = " @brief launches an executable graph in a stream\n\n @param [in] graphExec - instance of executable graph to launch.\n @param [in] stream - instance of stream in which to launch executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphLaunch(
        &self,
        graphExec: hipGraphExec_t,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipGraphLaunch
            .as_ref()
            .expect("Expected function, got error."))(graphExec, stream)
    }
    #[doc = " @brief uploads an executable graph in a stream\n\n @param [in] graphExec - instance of executable graph to launch.\n @param [in] stream - instance of stream in which to launch executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphUpload(
        &self,
        graphExec: hipGraphExec_t,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipGraphUpload
            .as_ref()
            .expect("Expected function, got error."))(graphExec, stream)
    }
    #[doc = " @brief Destroys an executable graph\n\n @param [in] pGraphExec - instance of executable graph to destry.\n\n @returns #hipSuccess.\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecDestroy(&self, graphExec: hipGraphExec_t) -> hipError_t {
        (self
            .hipGraphExecDestroy
            .as_ref()
            .expect("Expected function, got error."))(graphExec)
    }
    #[doc = " @brief Check whether an executable graph can be updated with a graph and perform the update if  *\n possible.\n\n @param [in] hGraphExec - instance of executable graph to update.\n @param [in] hGraph - graph that contains the updated parameters.\n @param [in] hErrorNode_out -  node which caused the permissibility check to forbid the update.\n @param [in] updateResult_out - Whether the graph update was permitted.\n @returns #hipSuccess, #hipErrorGraphExecUpdateFailure\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecUpdate(
        &self,
        hGraphExec: hipGraphExec_t,
        hGraph: hipGraph_t,
        hErrorNode_out: *mut hipGraphNode_t,
        updateResult_out: *mut hipGraphExecUpdateResult,
    ) -> hipError_t {
        (self
            .hipGraphExecUpdate
            .as_ref()
            .expect("Expected function, got error."))(
            hGraphExec,
            hGraph,
            hErrorNode_out,
            updateResult_out,
        )
    }
    #[doc = " @brief Creates a kernel execution node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - pointer to the dependencies on the kernel execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pNodeParams - pointer to the parameters to the kernel execution node on the GPU.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddKernelNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphAddKernelNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            pNodeParams,
        )
    }
    #[doc = " @brief Gets kernel node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphKernelNodeGetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *mut hipKernelNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphKernelNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets a kernel node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphKernelNodeSetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphKernelNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets the parameters for a kernel node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecKernelNodeSetParams(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphExecKernelNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, node, pNodeParams)
    }
    #[doc = " @brief Creates a memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pCopyParams - const pointer to the parameters for the memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddMemcpyNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pCopyParams: *const hipMemcpy3DParms,
    ) -> hipError_t {
        (self
            .hipGraphAddMemcpyNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            pCopyParams,
        )
    }
    #[doc = " @brief Gets a memcpy node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphMemcpyNodeGetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t {
        (self
            .hipGraphMemcpyNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets a memcpy node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphMemcpyNodeSetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *const hipMemcpy3DParms,
    ) -> hipError_t {
        (self
            .hipGraphMemcpyNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets a node attribute.\n\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] attr - the attribute node is set to.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphKernelNodeSetAttribute(
        &self,
        hNode: hipGraphNode_t,
        attr: hipKernelNodeAttrID,
        value: *const hipKernelNodeAttrValue,
    ) -> hipError_t {
        (self
            .hipGraphKernelNodeSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(hNode, attr, value)
    }
    #[doc = " @brief Gets a node attribute.\n\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] attr - the attribute node is set to.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphKernelNodeGetAttribute(
        &self,
        hNode: hipGraphNode_t,
        attr: hipKernelNodeAttrID,
        value: *mut hipKernelNodeAttrValue,
    ) -> hipError_t {
        (self
            .hipGraphKernelNodeGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(hNode, attr, value)
    }
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecMemcpyNodeSetParams(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t {
        (self
            .hipGraphExecMemcpyNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, node, pNodeParams)
    }
    #[doc = " @brief Creates a 1D memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddMemcpyNode1D(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphAddMemcpyNode1D
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            dst,
            src,
            count,
            kind,
        )
    }
    #[doc = " @brief Sets a memcpy node's parameters to perform a 1-dimensional copy.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphMemcpyNodeSetParams1D(
        &self,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphMemcpyNodeSetParams1D
            .as_ref()
            .expect("Expected function, got error."))(node, dst, src, count, kind)
    }
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to perform a 1-dimensional\n copy.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecMemcpyNodeSetParams1D(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphExecMemcpyNodeSetParams1D
            .as_ref()
            .expect("Expected function, got error."))(
            hGraphExec, node, dst, src, count, kind
        )
    }
    #[doc = " @brief Creates a memcpy node to copy from a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddMemcpyNodeFromSymbol(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphAddMemcpyNodeFromSymbol
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            dst,
            symbol,
            count,
            offset,
            kind,
        )
    }
    #[doc = " @brief Sets a memcpy node's parameters to copy from a symbol on the device.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphMemcpyNodeSetParamsFromSymbol(
        &self,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphMemcpyNodeSetParamsFromSymbol
            .as_ref()
            .expect("Expected function, got error."))(node, dst, symbol, count, offset, kind)
    }
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy from a symbol on the\n * device.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecMemcpyNodeSetParamsFromSymbol(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphExecMemcpyNodeSetParamsFromSymbol
            .as_ref()
            .expect("Expected function, got error."))(
            hGraphExec, node, dst, symbol, count, offset, kind,
        )
    }
    #[doc = " @brief Creates a memcpy node to copy to a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddMemcpyNodeToSymbol(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphAddMemcpyNodeToSymbol
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            symbol,
            src,
            count,
            offset,
            kind,
        )
    }
    #[doc = " @brief Sets a memcpy node's parameters to copy to a symbol on the device.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphMemcpyNodeSetParamsToSymbol(
        &self,
        node: hipGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphMemcpyNodeSetParamsToSymbol
            .as_ref()
            .expect("Expected function, got error."))(node, symbol, src, count, offset, kind)
    }
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy to a symbol on the\n device.\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecMemcpyNodeSetParamsToSymbol(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipGraphExecMemcpyNodeSetParamsToSymbol
            .as_ref()
            .expect("Expected function, got error."))(
            hGraphExec, node, symbol, src, count, offset, kind,
        )
    }
    #[doc = " @brief Creates a memset node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pMemsetParams - const pointer to the parameters for the memory set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddMemsetNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pMemsetParams: *const hipMemsetParams,
    ) -> hipError_t {
        (self
            .hipGraphAddMemsetNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            pMemsetParams,
        )
    }
    #[doc = " @brief Gets a memset node's parameters.\n\n @param [in] node - instane of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphMemsetNodeGetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemsetParams,
    ) -> hipError_t {
        (self
            .hipGraphMemsetNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets a memset node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphMemsetNodeSetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t {
        (self
            .hipGraphMemsetNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets the parameters for a memset node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecMemsetNodeSetParams(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t {
        (self
            .hipGraphExecMemsetNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, node, pNodeParams)
    }
    #[doc = " @brief Creates a host execution node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pNodeParams -pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddHostNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphAddHostNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            pNodeParams,
        )
    }
    #[doc = " @brief Returns a host node's parameters.\n\n @param [in] node - instane of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphHostNodeGetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *mut hipHostNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphHostNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets a host node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphHostNodeSetParams(
        &self,
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphHostNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(node, pNodeParams)
    }
    #[doc = " @brief Sets the parameters for a host node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecHostNodeSetParams(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t {
        (self
            .hipGraphExecHostNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, node, pNodeParams)
    }
    #[doc = " @brief Creates a child graph node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] childGraph - the graph to clone into this node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddChildGraphNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        childGraph: hipGraph_t,
    ) -> hipError_t {
        (self
            .hipGraphAddChildGraphNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            childGraph,
        )
    }
    #[doc = " @brief Gets a handle to the embedded graph of a child graph node.\n\n @param [in] node - instane of the node to get child graph.\n @param [out] pGraph - pointer to get the graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphChildGraphNodeGetGraph(
        &self,
        node: hipGraphNode_t,
        pGraph: *mut hipGraph_t,
    ) -> hipError_t {
        (self
            .hipGraphChildGraphNodeGetGraph
            .as_ref()
            .expect("Expected function, got error."))(node, pGraph)
    }
    #[doc = " @brief Updates node parameters in the child graph node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - node from the graph which was used to instantiate graphExec.\n @param [in] childGraph - child graph with updated parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecChildGraphNodeSetParams(
        &self,
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        childGraph: hipGraph_t,
    ) -> hipError_t {
        (self
            .hipGraphExecChildGraphNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, node, childGraph)
    }
    #[doc = " @brief Creates an empty node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node is add to.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddEmptyNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t {
        (self
            .hipGraphAddEmptyNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
        )
    }
    #[doc = " @brief Creates an event record node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node to be added.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @param [in] event - Event for the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddEventRecordNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphAddEventRecordNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            event,
        )
    }
    #[doc = " @brief Returns the event associated with an event record node.\n\n @param [in] node -  instane of the node to get event from.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphEventRecordNodeGetEvent(
        &self,
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphEventRecordNodeGetEvent
            .as_ref()
            .expect("Expected function, got error."))(node, event_out)
    }
    #[doc = " @brief Sets an event record node's event.\n\n @param [in] node - instane of the node to set event to.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphEventRecordNodeSetEvent(
        &self,
        node: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphEventRecordNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(node, event)
    }
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecEventRecordNodeSetEvent(
        &self,
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphExecEventRecordNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, event)
    }
    #[doc = " @brief Creates an event wait node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node to be added.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @param [in] event - Event for the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphAddEventWaitNode(
        &self,
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphAddEventWaitNode
            .as_ref()
            .expect("Expected function, got error."))(
            pGraphNode,
            graph,
            pDependencies,
            numDependencies,
            event,
        )
    }
    #[doc = " @brief Returns the event associated with an event wait node.\n\n @param [in] node -  instane of the node to get event from.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphEventWaitNodeGetEvent(
        &self,
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphEventWaitNodeGetEvent
            .as_ref()
            .expect("Expected function, got error."))(node, event_out)
    }
    #[doc = " @brief Sets an event wait node's event.\n\n @param [in] node - instane of the node to set event to.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphEventWaitNodeSetEvent(
        &self,
        node: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphEventWaitNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(node, event)
    }
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphExecEventWaitNodeSetEvent(
        &self,
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t {
        (self
            .hipGraphExecEventWaitNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, event)
    }
    #[doc = " @brief Get the mem attribute for graphs.\n\n @param [in] device - device the attr is get for.\n @param [in] attr - attr to get.\n @param [out] value - value for specific attr.\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipDeviceGetGraphMemAttribute(
        &self,
        device: ::std::os::raw::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipDeviceGetGraphMemAttribute
            .as_ref()
            .expect("Expected function, got error."))(device, attr, value)
    }
    #[doc = " @brief Set the mem attribute for graphs.\n\n @param [in] device - device the attr is set for.\n @param [in] attr - attr to set.\n @param [in] value - value for specific attr.\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipDeviceSetGraphMemAttribute(
        &self,
        device: ::std::os::raw::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipDeviceSetGraphMemAttribute
            .as_ref()
            .expect("Expected function, got error."))(device, attr, value)
    }
    #[doc = " @brief Free unused memory on specific device used for graph back to OS.\n\n @param [in] device - device the memory is used for graphs\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipDeviceGraphMemTrim(&self, device: ::std::os::raw::c_int) -> hipError_t {
        (self
            .hipDeviceGraphMemTrim
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    #[doc = " @brief Create an instance of userObject to manage lifetime of a resource.\n\n @param [out] object_out - pointer to instace of userobj.\n @param [in] ptr - pointer to pass to destroy function.\n @param [in] destroy - destroy callback to remove resource.\n @param [in] initialRefcount - reference to resource.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipUserObjectCreate(
        &self,
        object_out: *mut hipUserObject_t,
        ptr: *mut ::std::os::raw::c_void,
        destroy: hipHostFn_t,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipUserObjectCreate
            .as_ref()
            .expect("Expected function, got error."))(
            object_out,
            ptr,
            destroy,
            initialRefcount,
            flags,
        )
    }
    #[doc = " @brief Release number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipUserObjectRelease(
        &self,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipUserObjectRelease
            .as_ref()
            .expect("Expected function, got error."))(object, count)
    }
    #[doc = " @brief Retain number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipUserObjectRetain(
        &self,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipUserObjectRetain
            .as_ref()
            .expect("Expected function, got error."))(object, count)
    }
    #[doc = " @brief Retain user object for graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphRetainUserObject(
        &self,
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipGraphRetainUserObject
            .as_ref()
            .expect("Expected function, got error."))(graph, object, count, flags)
    }
    #[doc = " @brief Release user object from graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipGraphReleaseUserObject(
        &self,
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipGraphReleaseUserObject
            .as_ref()
            .expect("Expected function, got error."))(graph, object, count)
    }
    #[doc = " @brief Frees an address range reservation made via hipMemAddressReserve\n\n @param [in] devPtr - starting address of the range.\n @param [in] size - size of the range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemAddressFree(
        &self,
        devPtr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> hipError_t {
        (self
            .hipMemAddressFree
            .as_ref()
            .expect("Expected function, got error."))(devPtr, size)
    }
    #[doc = " @brief Reserves an address range\n\n @param [out] ptr - starting address of the reserved range.\n @param [in] size - size of the reservation.\n @param [in] alignment - alignment of the address.\n @param [in] addr - requested starting address of the range.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemAddressReserve(
        &self,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        addr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t {
        (self
            .hipMemAddressReserve
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, alignment, addr, flags)
    }
    #[doc = " @brief Creates a memory allocation described by the properties and size\n\n @param [out] handle - value of the returned handle.\n @param [in] size - size of the allocation.\n @param [in] prop - properties of the allocation.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemCreate(
        &self,
        handle: *mut hipMemGenericAllocationHandle_t,
        size: usize,
        prop: *const hipMemAllocationProp,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t {
        (self
            .hipMemCreate
            .as_ref()
            .expect("Expected function, got error."))(handle, size, prop, flags)
    }
    #[doc = " @brief Exports an allocation to a requested shareable handle type.\n\n @param [out] shareableHandle - value of the returned handle.\n @param [in] handle - handle to share.\n @param [in] handleType - type of the shareable handle.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemExportToShareableHandle(
        &self,
        shareableHandle: *mut ::std::os::raw::c_void,
        handle: hipMemGenericAllocationHandle_t,
        handleType: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t {
        (self
            .hipMemExportToShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(
            shareableHandle, handle, handleType, flags
        )
    }
    #[doc = " @brief Get the access flags set for the given location and ptr.\n\n @param [out] flags - flags for this location.\n @param [in] location - target location.\n @param [in] ptr - address to check the access flags.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemGetAccess(
        &self,
        flags: *mut ::std::os::raw::c_ulonglong,
        location: *const hipMemLocation,
        ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipMemGetAccess
            .as_ref()
            .expect("Expected function, got error."))(flags, location, ptr)
    }
    #[doc = " @brief Calculates either the minimal or recommended granularity.\n\n @param [out] granularity - returned granularity.\n @param [in] prop - location properties.\n @param [in] option - determines which granularity to return.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemGetAllocationGranularity(
        &self,
        granularity: *mut usize,
        prop: *const hipMemAllocationProp,
        option: hipMemAllocationGranularity_flags,
    ) -> hipError_t {
        (self
            .hipMemGetAllocationGranularity
            .as_ref()
            .expect("Expected function, got error."))(granularity, prop, option)
    }
    #[doc = " @brief Retrieve the property structure of the given handle.\n\n @param [out] prop - properties of the given handle.\n @param [in] handle - handle to perform the query on.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemGetAllocationPropertiesFromHandle(
        &self,
        prop: *mut hipMemAllocationProp,
        handle: hipMemGenericAllocationHandle_t,
    ) -> hipError_t {
        (self
            .hipMemGetAllocationPropertiesFromHandle
            .as_ref()
            .expect("Expected function, got error."))(prop, handle)
    }
    #[doc = " @brief Imports an allocation from a requested shareable handle type.\n\n @param [out] handle - returned value.\n @param [in] osHandle - shareable handle representing the memory allocation.\n @param [in] shHandleType - handle type.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemImportFromShareableHandle(
        &self,
        handle: *mut hipMemGenericAllocationHandle_t,
        osHandle: *mut ::std::os::raw::c_void,
        shHandleType: hipMemAllocationHandleType,
    ) -> hipError_t {
        (self
            .hipMemImportFromShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(handle, osHandle, shHandleType)
    }
    #[doc = " @brief Maps an allocation handle to a reserved virtual address range.\n\n @param [in] ptr - address where the memory will be mapped.\n @param [in] size - size of the mapping.\n @param [in] offset - offset into the memory, currently must be zero.\n @param [in] handle - memory allocation to be mapped.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemMap(
        &self,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        offset: usize,
        handle: hipMemGenericAllocationHandle_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t {
        (self
            .hipMemMap
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, offset, handle, flags)
    }
    #[doc = " @brief Maps or unmaps subregions of sparse HIP arrays and sparse HIP mipmapped arrays.\n\n @param [in] mapInfoList - list of hipArrayMapInfo.\n @param [in] count - number of hipArrayMapInfo in mapInfoList.\n @param [in] stream - stream identifier for the stream to use for map or unmap operations.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemMapArrayAsync(
        &self,
        mapInfoList: *mut hipArrayMapInfo,
        count: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemMapArrayAsync
            .as_ref()
            .expect("Expected function, got error."))(mapInfoList, count, stream)
    }
    #[doc = " @brief Release a memory handle representing a memory allocation which was previously allocated through hipMemCreate.\n\n @param [in] handle - handle of the memory allocation.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemRelease(&self, handle: hipMemGenericAllocationHandle_t) -> hipError_t {
        (self
            .hipMemRelease
            .as_ref()
            .expect("Expected function, got error."))(handle)
    }
    #[doc = " @brief Returns the allocation handle of the backing memory allocation given the address.\n\n @param [out] handle - handle representing addr.\n @param [in] addr - address to look up.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemRetainAllocationHandle(
        &self,
        handle: *mut hipMemGenericAllocationHandle_t,
        addr: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipMemRetainAllocationHandle
            .as_ref()
            .expect("Expected function, got error."))(handle, addr)
    }
    #[doc = " @brief Set the access flags for each location specified in desc for the given virtual address range.\n\n @param [in] ptr - starting address of the virtual address range.\n @param [in] size - size of the range.\n @param [in] desc - array of hipMemAccessDesc.\n @param [in] count - number of hipMemAccessDesc in desc.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemSetAccess(
        &self,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        desc: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t {
        (self
            .hipMemSetAccess
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, desc, count)
    }
    #[doc = " @brief Unmap memory allocation of a given address range.\n\n @param [in] ptr - starting address of the range to unmap.\n @param [in] size - size of the virtual address range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub unsafe fn hipMemUnmap(&self, ptr: *mut ::std::os::raw::c_void, size: usize) -> hipError_t {
        (self
            .hipMemUnmap
            .as_ref()
            .expect("Expected function, got error."))(ptr, size)
    }
    pub unsafe fn hipGLGetDevices(
        &self,
        pHipDeviceCount: *mut ::std::os::raw::c_uint,
        pHipDevices: *mut ::std::os::raw::c_int,
        hipDeviceCount: ::std::os::raw::c_uint,
        deviceList: hipGLDeviceList,
    ) -> hipError_t {
        (self
            .hipGLGetDevices
            .as_ref()
            .expect("Expected function, got error."))(
            pHipDeviceCount,
            pHipDevices,
            hipDeviceCount,
            deviceList,
        )
    }
    pub unsafe fn hipGraphicsGLRegisterBuffer(
        &self,
        resource: *mut *mut hipGraphicsResource,
        buffer: GLuint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipGraphicsGLRegisterBuffer
            .as_ref()
            .expect("Expected function, got error."))(resource, buffer, flags)
    }
    pub unsafe fn hipGraphicsGLRegisterImage(
        &self,
        resource: *mut *mut hipGraphicsResource,
        image: GLuint,
        target: GLenum,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipGraphicsGLRegisterImage
            .as_ref()
            .expect("Expected function, got error."))(resource, image, target, flags)
    }
    pub unsafe fn hipGraphicsMapResources(
        &self,
        count: ::std::os::raw::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipGraphicsMapResources
            .as_ref()
            .expect("Expected function, got error."))(count, resources, stream)
    }
    pub unsafe fn hipGraphicsSubResourceGetMappedArray(
        &self,
        array: *mut hipArray_t,
        resource: hipGraphicsResource_t,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipGraphicsSubResourceGetMappedArray
            .as_ref()
            .expect("Expected function, got error."))(array, resource, arrayIndex, mipLevel)
    }
    pub unsafe fn hipGraphicsResourceGetMappedPointer(
        &self,
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
        resource: hipGraphicsResource_t,
    ) -> hipError_t {
        (self
            .hipGraphicsResourceGetMappedPointer
            .as_ref()
            .expect("Expected function, got error."))(devPtr, size, resource)
    }
    pub unsafe fn hipGraphicsUnmapResources(
        &self,
        count: ::std::os::raw::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipGraphicsUnmapResources
            .as_ref()
            .expect("Expected function, got error."))(count, resources, stream)
    }
    pub unsafe fn hipGraphicsUnregisterResource(
        &self,
        resource: hipGraphicsResource_t,
    ) -> hipError_t {
        (self
            .hipGraphicsUnregisterResource
            .as_ref()
            .expect("Expected function, got error."))(resource)
    }
    pub unsafe fn hipMemcpy_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy_spt
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, kind)
    }
    pub unsafe fn hipMemcpyToSymbol_spt(
        &self,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpyToSymbol_spt
            .as_ref()
            .expect("Expected function, got error."))(symbol, src, sizeBytes, offset, kind)
    }
    pub unsafe fn hipMemcpyFromSymbol_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpyFromSymbol_spt
            .as_ref()
            .expect("Expected function, got error."))(dst, symbol, sizeBytes, offset, kind)
    }
    pub unsafe fn hipMemcpy2D_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy2D_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, spitch, width, height, kind
        )
    }
    pub unsafe fn hipMemcpy2DFromArray_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy2DFromArray_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, wOffset, hOffset, width, height, kind,
        )
    }
    pub unsafe fn hipMemcpy3D_spt(&self, p: *const hipMemcpy3DParms) -> hipError_t {
        (self
            .hipMemcpy3D_spt
            .as_ref()
            .expect("Expected function, got error."))(p)
    }
    pub unsafe fn hipMemset_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t {
        (self
            .hipMemset_spt
            .as_ref()
            .expect("Expected function, got error."))(dst, value, sizeBytes)
    }
    pub unsafe fn hipMemsetAsync_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemsetAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(dst, value, sizeBytes, stream)
    }
    pub unsafe fn hipMemset2D_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t {
        (self
            .hipMemset2D_spt
            .as_ref()
            .expect("Expected function, got error."))(dst, pitch, value, width, height)
    }
    pub unsafe fn hipMemset2DAsync_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemset2DAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, pitch, value, width, height, stream
        )
    }
    pub unsafe fn hipMemset3DAsync_spt(
        &self,
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemset3DAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(pitchedDevPtr, value, extent, stream)
    }
    pub unsafe fn hipMemset3D_spt(
        &self,
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
    ) -> hipError_t {
        (self
            .hipMemset3D_spt
            .as_ref()
            .expect("Expected function, got error."))(pitchedDevPtr, value, extent)
    }
    pub unsafe fn hipMemcpyAsync_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(dst, src, sizeBytes, kind, stream)
    }
    pub unsafe fn hipMemcpy3DAsync_spt(
        &self,
        p: *const hipMemcpy3DParms,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy3DAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(p, stream)
    }
    pub unsafe fn hipMemcpy2DAsync_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy2DAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, spitch, width, height, kind, stream,
        )
    }
    pub unsafe fn hipMemcpyFromSymbolAsync_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyFromSymbolAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, symbol, sizeBytes, offset, kind, stream
        )
    }
    pub unsafe fn hipMemcpyToSymbolAsync_spt(
        &self,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpyToSymbolAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(
            symbol, src, sizeBytes, offset, kind, stream
        )
    }
    pub unsafe fn hipMemcpyFromArray_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpyFromArray_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, src, wOffsetSrc, hOffset, count, kind
        )
    }
    pub unsafe fn hipMemcpy2DToArray_spt(
        &self,
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t {
        (self
            .hipMemcpy2DToArray_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, wOffset, hOffset, src, spitch, width, height, kind,
        )
    }
    pub unsafe fn hipMemcpy2DFromArrayAsync_spt(
        &self,
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy2DFromArrayAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, dpitch, src, wOffsetSrc, hOffsetSrc, width, height, kind, stream,
        )
    }
    pub unsafe fn hipMemcpy2DToArrayAsync_spt(
        &self,
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipMemcpy2DToArrayAsync_spt
            .as_ref()
            .expect("Expected function, got error."))(
            dst, wOffset, hOffset, src, spitch, width, height, kind, stream,
        )
    }
    pub unsafe fn hipStreamQuery_spt(&self, stream: hipStream_t) -> hipError_t {
        (self
            .hipStreamQuery_spt
            .as_ref()
            .expect("Expected function, got error."))(stream)
    }
    pub unsafe fn hipStreamSynchronize_spt(&self, stream: hipStream_t) -> hipError_t {
        (self
            .hipStreamSynchronize_spt
            .as_ref()
            .expect("Expected function, got error."))(stream)
    }
    pub unsafe fn hipStreamGetPriority_spt(
        &self,
        stream: hipStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> hipError_t {
        (self
            .hipStreamGetPriority_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, priority)
    }
    pub unsafe fn hipStreamWaitEvent_spt(
        &self,
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamWaitEvent_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, event, flags)
    }
    pub unsafe fn hipStreamGetFlags_spt(
        &self,
        stream: hipStream_t,
        flags: *mut ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamGetFlags_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, flags)
    }
    pub unsafe fn hipStreamAddCallback_spt(
        &self,
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t {
        (self
            .hipStreamAddCallback_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, callback, userData, flags)
    }
    pub unsafe fn hipEventRecord_spt(&self, event: hipEvent_t, stream: hipStream_t) -> hipError_t {
        (self
            .hipEventRecord_spt
            .as_ref()
            .expect("Expected function, got error."))(event, stream)
    }
    pub unsafe fn hipLaunchCooperativeKernel_spt(
        &self,
        f: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDim: dim3,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: u32,
        hStream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipLaunchCooperativeKernel_spt
            .as_ref()
            .expect("Expected function, got error."))(
            f,
            gridDim,
            blockDim,
            kernelParams,
            sharedMemBytes,
            hStream,
        )
    }
    pub unsafe fn hipLaunchKernel_spt(
        &self,
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipLaunchKernel_spt
            .as_ref()
            .expect("Expected function, got error."))(
            function_address,
            numBlocks,
            dimBlocks,
            args,
            sharedMemBytes,
            stream,
        )
    }
    pub unsafe fn hipGraphLaunch_spt(
        &self,
        graphExec: hipGraphExec_t,
        stream: hipStream_t,
    ) -> hipError_t {
        (self
            .hipGraphLaunch_spt
            .as_ref()
            .expect("Expected function, got error."))(graphExec, stream)
    }
    pub unsafe fn hipStreamBeginCapture_spt(
        &self,
        stream: hipStream_t,
        mode: hipStreamCaptureMode,
    ) -> hipError_t {
        (self
            .hipStreamBeginCapture_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, mode)
    }
    pub unsafe fn hipStreamEndCapture_spt(
        &self,
        stream: hipStream_t,
        pGraph: *mut hipGraph_t,
    ) -> hipError_t {
        (self
            .hipStreamEndCapture_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, pGraph)
    }
    pub unsafe fn hipStreamIsCapturing_spt(
        &self,
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t {
        (self
            .hipStreamIsCapturing_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, pCaptureStatus)
    }
    pub unsafe fn hipStreamGetCaptureInfo_spt(
        &self,
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> hipError_t {
        (self
            .hipStreamGetCaptureInfo_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, pCaptureStatus, pId)
    }
    pub unsafe fn hipStreamGetCaptureInfo_v2_spt(
        &self,
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t {
        (self
            .hipStreamGetCaptureInfo_v2_spt
            .as_ref()
            .expect("Expected function, got error."))(
            stream,
            captureStatus_out,
            id_out,
            graph_out,
            dependencies_out,
            numDependencies_out,
        )
    }
    pub unsafe fn hipLaunchHostFunc_spt(
        &self,
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> hipError_t {
        (self
            .hipLaunchHostFunc_spt
            .as_ref()
            .expect("Expected function, got error."))(stream, fn_, userData)
    }
}
